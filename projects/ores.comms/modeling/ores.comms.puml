' -*- mode: plantuml; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*-
'
' Copyright (C) 2025 Marco Craveiro <marco.craveiro@gmail.com>
'
' This program is free software; you can redistribute it and/or modify it under
' the terms of the GNU General Public License as published by the Free Software
' Foundation; either version 3 of the License, or (at your option) any later
' version.
'
' This program is distributed in the hope that it will be useful, but WITHOUT
'  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
' FOR A PARTICULAR PURPOSE. See the GNU General Public License for more details.
'
' You should have received a copy of the GNU General Public License along with
' GNU Emacs; see the file COPYING. If not, write to the Free Software
' Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.
@startuml

title ores.comms Component

set namespaceSeparator ::

namespace ores #F2F2F2 {

    note "Communications library providing client-server connectivity for ORE Studio.\n\n Implements a custom binary protocol over SSL/TLS for secure client-server communication." as ores_comms_note
    comms --- ores_comms_note
    namespace comms #F2F2F2 {
        namespace net #F2F2F2 {
            class server_options #F7E5FF {
                +{field} port std::uint16_t
                +{field} max_connections std::uint32_t
                +{field} certificate_file std::string
                +{field} private_key_file std::string
                +{field} server_identifier std::string
                +{field} certificate_chain_content std::optional<std::string>
                +{field} private_key_content std::optional<std::string>
                +{field} enable_signal_watching bool
            }

            note top of server_options
            Configuration for the server.

            Fields:

            - port: Server port number.
            - max_connections: Maximum number of concurrent connections.
            - certificate_file: Path to the SSL certificate file.
            - private_key_file: Path to the SSL private key file.
            - server_identifier: Server identifier string sent in handshake.
            - certificate_chain_content: Optional certificate chain content (takes precedence over file).
            - private_key_content: Optional private key content (takes precedence over file).
            - enable_signal_watching: Whether to enable signal watching.
            end note

            class server #ECECEC {
                +server(server_options options)
                +register_handler(messaging::message_type_range range, std::shared_ptr<messaging::message_handler> handler) void
                +run(boost::asio::io_context& io_context, std::function<void(std::uint16_t)> on_listening) boost::asio::awaitable<void>
                +stop() void
                -accept_loop(boost::asio::io_context& io_context, std::function<void(std::uint16_t)> on_listening) boost::asio::awaitable<void>
                -setup_ssl_context() void
                -watch_for_stop_signals(boost::asio::io_context& io_context) boost::asio::awaitable<void>
                -{field} options_ server_options
                -{field} ssl_ctx_ ssl::context
                -{field} dispatcher_ std::shared_ptr<messaging::message_dispatcher>
                -{field} active_connections_ std::atomic<std::size_t>
                -{field} stop_signal_ boost::asio::cancellation_signal
                -{field} active_sessions_ std::list<std::shared_ptr<session>>
                -{field} sessions_mutex_ std::mutex
            }

            note top of server
            ORES protocol server.

            Accepts SSL connections, performs handshake, and manages client sessions.
            end note

            server o-u- ores::comms::net::server_options
            server o-u- ores::comms::messaging::message_dispatcher
            server o-u- ores::comms::net::session

        class client_options #F7E5FF {
            +{field} host std::string
            +{field} port std::uint16_t
            +{field} client_identifier std::string
            +{field} verify_certificate bool
            +{field} heartbeat_enabled bool
            +{field} heartbeat_interval_seconds std::uint32_t
        }

        note top of client_options
        Configuration for the client.

        Fields:

        - host: Host to connect to.
        - port: Port to connect to.
        - client_identifier: Client identifier to send in handshake.
        - verify_certificate: Whether to verify server certificate.
        - heartbeat_enabled: Enable heartbeat for disconnect detection (default: true).
        - heartbeat_interval_seconds: Heartbeat interval in seconds (default: 30).
        end note

        class client #ECECEC {
            +client(client_options config)
            +client(client_options config, boost::asio::any_io_executor executor)
            +connect() boost::asio::awaitable<void>
            +connect_sync() void
            +disconnect() void
            +is_connected() bool
            +set_disconnect_callback(disconnect_callback_t callback) void
            +send_request(messaging::frame request_frame) boost::asio::awaitable<std::expected<messaging::frame, messaging::error_code>>
            +send_request_sync(messaging::frame request_frame) std::expected<messaging::frame, messaging::error_code>
            -perform_handshake() boost::asio::awaitable<void>
            -run_heartbeat() boost::asio::awaitable<void>
            -run_message_loop() boost::asio::awaitable<void>
            -write_frame(const messaging::frame& f) boost::asio::awaitable<void>
            -next_correlation_id() std::uint32_t
            -setup_ssl_context() void
            -{field} config_ client_options
            -{field} io_ctx_ std::unique_ptr<boost::asio::io_context>
            -{field} executor_ boost::asio::any_io_executor
            -{field} ssl_ctx_ boost::asio::ssl::context
            -{field} conn_ std::unique_ptr<connection>
            -{field} sequence_number_ std::uint32_t
            -{field} connected_ bool
            -{field} state_mutex_ std::mutex
            -{field} disconnect_callback_ disconnect_callback_t
            -{field} write_strand_ std::unique_ptr<boost::asio::strand<boost::asio::any_io_executor>>
            -{field} pending_requests_ std::unique_ptr<pending_request_map>
            -{field} correlation_id_counter_ std::atomic<std::uint32_t>
            -{field} message_loop_running_ bool
        }

        note top of client
        ORES protocol client.

        Connects to server via SSL, performs handshake, and manages communication.
        Uses a unified message loop for reading all incoming frames and matching
        responses to pending requests via correlation IDs. Supports optional
        heartbeat for proactive disconnect detection.
        end note

            client o-u- ores::comms::net::client_options
            client o-u- ores::comms::net::connection
            client o-u- ores::comms::net::pending_request_map
            client ..> ores::comms::messaging::frame
            client ..> ores::comms::messaging::error_code
            client ..> ores::comms::service::handshake_service : uses
            client ..> ores::comms::messaging::ping : uses
            client ..> ores::comms::messaging::pong : uses

        class pending_request_map #ECECEC {
            +pending_request_map(boost::asio::any_io_executor executor)
            +register_request(std::uint32_t correlation_id) std::shared_ptr<response_channel>
            +complete(std::uint32_t correlation_id, messaging::frame response) bool
            +fail(std::uint32_t correlation_id, messaging::error_code ec) bool
            +fail_all(messaging::error_code ec) void
            +remove(std::uint32_t correlation_id) void
            +size() std::size_t
            +empty() bool
            -{field} executor_ boost::asio::any_io_executor
            -{field} mutex_ std::mutex
            -{field} pending_ std::unordered_map<std::uint32_t, std::shared_ptr<response_channel>>
        }

        note top of pending_request_map
        Thread-safe map for tracking pending requests by correlation ID.

        Used by the client to match incoming responses to their originating
        requests. When a request is sent, a response_channel is registered
        with its correlation ID. When a response arrives, the message loop
        looks up the channel by correlation ID and delivers the response.
        end note

            pending_request_map o-u- ores::comms::net::response_channel
            pending_request_map ..> ores::comms::messaging::frame
            pending_request_map ..> ores::comms::messaging::error_code

        class response_channel #ECECEC {
            +response_channel(boost::asio::any_io_executor executor)
            +set_value(messaging::frame response) void
            +set_error(messaging::error_code ec) void
            +get() boost::asio::awaitable<std::expected<messaging::frame, messaging::error_code>>
            +is_ready() bool
            -{field} signal_ boost::asio::steady_timer
            -{field} mutex_ std::mutex
            -{field} response_ std::optional<messaging::frame>
            -{field} error_ std::optional<messaging::error_code>
            -{field} ready_ bool
        }

        note top of response_channel
        Single-value async channel for delivering a response frame.

        Used by the message loop to deliver responses to waiting coroutines.
        Each channel can hold exactly one response (or error). The consumer
        calls get() which blocks until set_value() or set_error() is called
        by the producer (message loop).
        end note

            response_channel ..> ores::comms::messaging::frame
            response_channel ..> ores::comms::messaging::error_code

            class connection #ECECEC {
            +connection(ssl_socket socket)
            +ssl_handshake_server() boost::asio::awaitable<void>
            +ssl_handshake_client() boost::asio::awaitable<void>
            +read_frame() boost::asio::awaitable<std::expected<messaging::frame, messaging::error_code>>
            +write_frame(const messaging::frame& frame) boost::asio::awaitable<void>
            +is_open() bool
            +close() void
            +remote_address() std::string
            -{field} socket_ ssl_socket
        }

        note top of connection
        SSL connection wrapper for frame-based communication.

        Provides async read/write operations for protocol frames over SSL/TLS.
        end note

            connection ..> ores::comms::messaging::frame
            connection ..> ores::comms::messaging::error_code

            class session #ECECEC {
            +session(std::unique_ptr<connection> conn, std::string server_id, std::shared_ptr<messaging::message_dispatcher> dispatcher)
            +run() boost::asio::awaitable<void>
            -perform_handshake() boost::asio::awaitable<bool>
            -process_messages() boost::asio::awaitable<void>
            -{field} conn_ std::unique_ptr<connection>
            -{field} server_id_ std::string
            -{field} dispatcher_ std::shared_ptr<messaging::message_dispatcher>
            -{field} sequence_number_ std::uint32_t
            -{field} handshake_complete_ bool
        }

        note top of session
        Represents a client session on the server side.

        Manages the lifecycle of a single client connection, including
        handshake, message processing, and cleanup.
        end note

            session o-u- ores::comms::net::connection
            session o-u- ores::comms::messaging::message_dispatcher
            session ..> ores::comms::service::handshake_service : uses
            session ..> ores::comms::service::heartbeat_service : uses
            session ..> ores::comms::messaging::error_response : uses
        }

        namespace messaging #F2F2F2 {
            class result #ECECEC {
                +result(const T& value)
                +result(T&& value)
                +result(const E& error)
                +result(E&& error)
                +has_value() bool
                +has_error() bool
                +value() T&
                +error() E&
                -{field} data_ std::variant<T, E>
            }

            note top of result
            Simple result type for C++20 (std::expected replacement).

            Holds either a value of type T or an error of type E.
            end note

            class message_type_range #F7E5FF {
                +{field} min std::uint16_t
                +{field} max std::uint16_t
                +contains(message_type type) bool
            }

            note top of message_type_range
            Range of message types handled by a subsystem.

            Defines an inclusive range [min, max] of message types.

            Fields:

            - min: Minimum message type value.
            - max: Maximum message type value.
            end note

            interface message_handler #ECECEC {
                +{abstract} handle_message(message_type type, std::span<const std::uint8_t> payload, const std::string& remote_address) boost::asio::awaitable<std::expected<std::vector<std::uint8_t>, error_code>>
            }

            note top of message_handler
            Abstract interface for handling messages from a subsystem.

            Subsystems implement this interface to process their domain-specific messages.
            The handler is responsible for:
            - Deserializing the payload into subsystem-specific types
            - Executing the requested operation
            - Serializing the response back into bytes
            end note

            class frame_header <<message>> #E1F5FF {
                +{field} magic std::uint32_t
                +{field} version_major std::uint16_t
                +{field} version_minor std::uint16_t
                +{field} type message_type
                +{field} reserved1 std::uint16_t
                +{field} payload_size std::uint32_t
                +{field} sequence std::uint32_t
                +{field} crc std::uint32_t
                +{field} reserved2 std::array<std::uint8_t, 8>
            }

            note top of frame_header
            Frame header structure for the ORES protocol.

            Frame layout (32 bytes header):
            +0:  magic (4 bytes)       - Protocol identifier (0x4F524553 = "ORES")
            +4:  version_major (2 bytes) - Protocol major version
            +6:  version_minor (2 bytes) - Protocol minor version
            +8:  type (2 bytes)        - Message type
            +10: reserved1 (2 bytes)   - Reserved for future use
            +12: payload_size (4 bytes) - Size of payload in bytes
            +16: sequence (4 bytes)    - Sequence number for ordering
            +20: crc (4 bytes)         - CRC32 checksum of header + payload
            +24: reserved2 (8 bytes)   - Reserved for future use
            +32: payload (N bytes)     - Message payload

            Fields:

            - magic: Protocol identifier.
            - version_major: Protocol major version.
            - version_minor: Protocol minor version.
            - type: Message type.
            - reserved1: Reserved for future use.
            - payload_size: Size of payload in bytes.
            - sequence: Sequence number for ordering.
            - crc: CRC32 checksum of header and payload.
            - reserved2: Reserved for future use.
            end note

            frame_header ..> ores::comms::messaging::message_type

            class frame <<message>> #E1F5FF {
                +frame()
                +frame(message_type type, std::uint32_t sequence, std::vector<std::uint8_t> payload)
                +header() frame_header
                +payload() std::vector<std::uint8_t>
                +serialize() std::vector<std::uint8_t>
                +{static} deserialize_header(std::span<const std::uint8_t> data) std::expected<frame_header, error_code>
                +{static} deserialize(const frame_header& header, std::span<const std::uint8_t> data) std::expected<frame, error_code>
                +validate() std::expected<void, error_code>
                -calculate_crc() std::uint32_t
                -serialize_header(frame_header header, std::span<std::uint8_t> buffer) void
                -{field} header_ frame_header
                -{field} payload_ std::vector<std::uint8_t>
            }

            note top of frame
            Complete frame with header and payload.
            end note

            frame o-u- ores::comms::messaging::frame_header
            frame ..> ores::comms::messaging::error_code

            class message_dispatcher #ECECEC {
                +message_dispatcher()
                +register_handler(message_type_range range, std::shared_ptr<message_handler> handler) void
                +dispatch(const frame& request_frame, std::uint32_t sequence, const std::string& remote_address) boost::asio::awaitable<std::expected<frame, error_code>>
                -find_handler(message_type type) message_handler*
                -get_response_type(message_type request_type) message_type
                -{field} handlers_ std::map<message_type_range, std::shared_ptr<message_handler>>
            }

            note top of message_dispatcher
            Dispatches incoming messages to registered subsystem handlers.

            The dispatcher maintains a registry of message handlers for different
            message type ranges. When a message arrives, it routes it to the appropriate
            handler based on the message type, and converts the handler's response
            back into a frame.

            Thread-safety: This class is not thread-safe. Registration should happen
            during initialization before concurrent access begins.
            end note

            message_dispatcher o-u- ores::comms::messaging::message_type_range
            message_dispatcher o-u- ores::comms::messaging::message_handler
            message_dispatcher ..> ores::comms::messaging::frame
            message_dispatcher ..> ores::comms::messaging::error_code
            message_dispatcher ..> ores::comms::messaging::message_type

            class ping <<message>> #E1F5FF {
                +{static} serialize(ping v) std::vector<std::byte>
                +{static} deserialize(std::span<const std::byte> data) std::expected<ping, error_code>
            }

            note top of ping
            Ping message sent by client to check connection liveness.

            Lightweight keepalive message with no payload.
            end note

            ping ..> ores::comms::messaging::error_code

            class pong <<message>> #E1F5FF {
                +{static} serialize(pong v) std::vector<std::byte>
                +{static} deserialize(std::span<const std::byte> data) std::expected<pong, error_code>
            }

            note top of pong
            Pong message sent by server in response to ping.

            Lightweight response message confirming connection is alive.
            end note

            pong ..> ores::comms::messaging::error_code

            class handshake_request <<message>> #E1F5FF {
                +{field} client_version_major std::uint16_t
                +{field} client_version_minor std::uint16_t
                +{field} client_identifier std::string
                +{static} serialize(handshake_request v) std::vector<std::uint8_t>
                +{static} deserialize(std::span<const std::uint8_t> data) std::expected<handshake_request, error_code>
            }

            note top of handshake_request
            Handshake request message sent by client to initiate connection.

            Fields:

            - client_version_major: Client protocol major version.
            - client_version_minor: Client protocol minor version.
            - client_identifier: Client identifier string.
            end note

            handshake_request ..> ores::comms::messaging::error_code

            class handshake_response <<message>> #E1F5FF {
                +{field} server_version_major std::uint16_t
                +{field} server_version_minor std::uint16_t
                +{field} version_compatible bool
                +{field} server_identifier std::string
                +{field} status error_code
                +{static} serialize(handshake_response v) std::vector<std::uint8_t>
                +{static} deserialize(std::span<const std::uint8_t> data) std::expected<handshake_response, error_code>
            }

            note top of handshake_response
            Handshake response message sent by server to client.

            Fields:

            - server_version_major: Server protocol major version.
            - server_version_minor: Server protocol minor version.
            - version_compatible: Whether the versions are compatible.
            - server_identifier: Server identifier string.
            - status: Error code indicating handshake status.
            end note

            handshake_response ..> ores::comms::messaging::error_code

            class handshake_ack <<message>> #E1F5FF {
                +{field} status error_code
                +{static} serialize(handshake_ack v) std::vector<std::uint8_t>
                +{static} deserialize(std::span<const std::uint8_t> data) std::expected<handshake_ack, error_code>
            }

            note top of handshake_ack
            Handshake acknowledgment message sent by client to complete handshake.

            Fields:

            - status: Error code indicating acknowledgment status.
            end note

            handshake_ack ..> ores::comms::messaging::error_code

            class error_response <<message>> #E1F5FF {
                +{field} code error_code
                +{field} message std::string
                +{static} serialize(error_response v) std::vector<std::uint8_t>
                +{static} deserialize(std::span<const std::uint8_t> data) std::expected<error_response, error_code>
            }

            note top of error_response
            Error response message sent when request processing fails.

            Fields:

            - code: Error code indicating the error type.
            - message: Human-readable error message.
            end note

            error_response ..> ores::comms::messaging::error_code

            enum message_type {
                handshake_request
                handshake_response
                handshake_ack
                error_response
                ping
                pong
                get_currencies_request
                get_currencies_response
                save_currency_request
                save_currency_response
                delete_currency_request
                delete_currency_response
                get_currency_history_request
                get_currency_history_response
                save_currency_request
                save_currency_response
                create_account_request
                create_account_response
                list_accounts_request
                list_accounts_response
                login_request
                login_response
                unlock_account_request
                unlock_account_response
                last_value
            }

            enum error_code {
                none
                version_mismatch
                crc_validation_failed
                invalid_message_type
                handshake_timeout
                handshake_failed
                payload_too_large
                network_error
                handler_error
                database_error
                authentication_failed
                authorization_failed
                invalid_request
                last_value
            }
        }

        namespace service #F2F2F2 {
            class handshake_service #ECECEC {
                +{static} perform_client_handshake(net::connection& conn, const std::function<std::uint32_t()>& sequence_generator, const std::string& client_identifier) boost::asio::awaitable<void>
                +{static} perform_server_handshake(net::connection& conn, std::uint32_t sequence, const std::string& server_identifier) boost::asio::awaitable<bool>
            }

            note top of handshake_service
            Service for managing protocol handshake between client and server.

            Encapsulates the handshake protocol logic for both client and server sides,
            handling the three-way handshake:
            1. Client sends handshake_request
            2. Server responds with handshake_response (including version compatibility)
            3. Client sends handshake_ack to complete
            end note

            handshake_service ..> ores::comms::messaging::handshake_request : uses
            handshake_service ..> ores::comms::messaging::handshake_response : uses
            handshake_service ..> ores::comms::messaging::handshake_ack : uses

            class heartbeat_service #ECECEC {
                +{static} handle_ping(net::connection& conn, std::uint32_t sequence, std::uint32_t correlation_id) boost::asio::awaitable<void>
            }

            note top of heartbeat_service
            Service for handling heartbeat (ping/pong) protocol on the server.

            Provides server-side handling of ping messages by sending pong responses.
            Client-side heartbeat is handled by the client's message loop using
            correlation IDs for response matching.
            end note

            heartbeat_service ..> ores::comms::messaging::ping : uses
            heartbeat_service ..> ores::comms::messaging::pong : uses
        }

        namespace tests #F2F2F2 {
            class frame_tests <<test suite>> #C5E1A5 {
                +test_frame_serialization() void
                +test_frame_serialization_empty_payload() void
                +test_frame_serialization_large_payload() void
                +test_frame_deserialization_invalid_data() void
                +test_frame_deserialization_corrupted_data() void
                +test_frame_roundtrip_multiple_message_types() void
                +test_frame_version_mismatch_strict_mode() void
                +test_frame_version_mismatch_lenient_mode() void
                +test_frame_version_mismatch_handshake_scenario() void
            }

            note top of frame_tests
            Test suite for protocol frame functionality.

            Tests cover frame serialization/deserialization,
            payload handling (empty/large), data corruption,
            roundtrip validation, and version mismatch scenarios.
            end note

            frame_tests ..> ores::comms::messaging::frame : tests
            frame_tests ..> ores::comms::messaging::frame_header : tests

            class net_client_tests <<test suite>> #C5E1A5 {
                +test_client_server_connection() void
                +test_session_cancellation_on_server_stop() void
                +test_heartbeat_configuration() void
                +test_heartbeat_disconnect_detection() void
                +test_heartbeat_disabled() void
            }

            note top of net_client_tests
            Test suite for client-server communication.

            Tests cover client-server connection establishment,
            handshake protocol, session lifecycle management
            including graceful cancellation on server shutdown,
            and heartbeat functionality for disconnect detection.
            end note

            net_client_tests ..> ores::comms::net::client : tests
            net_client_tests ..> ores::comms::net::server : tests
            net_client_tests ..> ores::comms::net::session : tests

            class message_handler_tests <<test suite>> #C5E1A5 {
                +test_request_serialization_roundtrip() void
                +test_response_serialization_roundtrip() void
                +test_handler_processes_test_request() void
                +test_handler_processes_echo_request() void
                +test_handler_rejects_invalid_message_type() void
                +test_dispatcher_with_registered_handler() void
                +test_dispatcher_without_handler_returns_error() void
                +test_dispatcher_preserves_correlation_id() void
                +test_handler_table_driven_values() void
                +test_echo_request_various_payloads() void
            }

            note top of message_handler_tests
            Test suite for message handler infrastructure.

            Tests cover test request/response serialization,
            message handler processing, dispatcher registration
            and dispatch, correlation ID preservation, and
            table-driven value testing.
            end note

            message_handler_tests ..> ores::comms::messaging::message_handler : tests
            message_handler_tests ..> ores::comms::messaging::message_dispatcher : tests
        }
    }
}

' Local Variables:
' compile-command: "java -Djava.awt.headless=true -DPLANTUML_SECURITY_PROFILE=UNSECURE -DPLANTUML_LIMIT_SIZE=65535 -jar /usr/share/plantuml/plantuml.jar ores.comms.puml"
' End:
@enduml
