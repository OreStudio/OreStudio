' -*- mode: plantuml; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*'
'
' Copyright (C) 2025 Marco Craveiro <marco.craveiro@gmail.com>
'
' This program is free software; you can redistribute it and/or modify it under
' the terms of the GNU General Public License as published by the Free Software
' Foundation; either version 3 of the License, or (at your option) any later
' version.
'
' This program is distributed in the hope that it will be useful, but WITHOUT
'  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
' FOR A PARTICULAR PURPOSE. See the GNU General Public License for more details.
'
' You should have received a copy of the GNU General Public License along with
' GNU Emacs; see the file COPYING. If not, write to the Free Software
' Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.
@startuml

title ores.telemetry Component - Observability (Tracing, Logging, Export)

set namespaceSeparator ::

namespace ores #F2F2F2 {
    note "Unified observability component providing:\n- Distributed tracing (OpenTelemetry-aligned)\n- Logging infrastructure (Boost.Log-based)\n- Log correlation with traces\n- Telemetry export (JSON, OTLP)" as ores_telemetry_note
    telemetry --- ores_telemetry_note

    namespace telemetry #E8F4E8 {

        namespace domain #D4E8D4 {
            class trace_id <<struct>> {
                +bytes : array<byte, 16>
                --
                +is_valid() : bool
                +to_hex() : string
                {static} +from_hex(hex) : trace_id
            }
            note right of trace_id
                128-bit trace identifier
                Bytes 0-5: timestamp (ms)
                Bytes 6-7: machine_id
                Bytes 8-15: random
            end note

            class span_id <<struct>> {
                +bytes : array<byte, 8>
                --
                +is_valid() : bool
                +to_hex() : string
                {static} +from_hex(hex) : span_id
            }
            note right of span_id
                64-bit span identifier
                Bytes 0-5: timestamp (ms)
                Bytes 6-7: sequence
            end note

            class span_context <<struct>> {
                +trace : trace_id
                +span : span_id
                +trace_flags : uint8
                --
                +is_valid() : bool
                +is_sampled() : bool
            }

            enum span_kind {
                internal
                server
                client
                producer
                consumer
            }

            enum span_status_code {
                unset
                ok
                error
            }

            class span_link <<struct>> {
                +context : span_context
                +attrs : attributes
            }
            note bottom of span_link
                Hypergraph edge linking
                spans across traces
            end note

            class span <<struct>> {
                +context : span_context
                +parent_span_id : optional<span_id>
                +links : vector<span_link>
                +name : string
                +kind : span_kind
                +start_time : time_point
                +end_time : optional<time_point>
                +status_code : span_status_code
                +status_message : string
                +attrs : attributes
                --
                +is_session() : bool
                +is_root() : bool
                +duration() : optional<nanoseconds>
            }

            class resource <<struct>> {
                +attrs : attributes
                --
                +service_name() : optional<string>
                +host_name() : optional<string>
                +host_id() : optional<string>
                {static} +from_environment(name, version) : resource
            }
            note right of resource
                Machine/service identity
                Locally derived host_id
            end note

            class log_record <<struct>> {
                +timestamp : time_point
                +observed_timestamp : optional<time_point>
                +severity : severity_level
                +body : string
                +trace : optional<trace_id>
                +span : optional<span_id>
                +logger_name : string
                +attrs : attributes
                +source_resource : shared_ptr<resource>
            }

            class telemetry_context <<class>> {
                -ctx_ : span_context
                -resource_ : shared_ptr<resource>
                --
                +context() : span_context
                +get_trace_id() : trace_id
                +get_span_id() : span_id
                +get_resource() : resource
                +start_span(name, kind) : pair<context, span>
                +start_linked_trace(name, kind) : pair<context, span>
                +is_valid() : bool
            }
            note bottom of telemetry_context
                Immutable context passed
                through call chain for
                coroutine-safe tracing
            end note

            ' Server-side persistence types
            enum telemetry_source {
                client
                server
            }

            class telemetry_log_entry <<struct>> {
                +id : uuid
                +timestamp : time_point
                +source : telemetry_source
                +source_name : string
                +session_id : optional<uuid>
                +account_id : optional<uuid>
                +level : string
                +component : string
                +message : string
                +tag : string
                +recorded_at : time_point
            }
            note right of telemetry_log_entry
                Persisted log entry for
                server-side telemetry.
                Simpler than log_record.
            end note

            class telemetry_query <<struct>> {
                +start_time : time_point
                +end_time : time_point
                +source : optional<telemetry_source>
                +source_name : optional<string>
                +session_id : optional<uuid>
                +account_id : optional<uuid>
                +level : optional<string>
                +min_level : optional<string>
                +component : optional<string>
                +limit : uint32
                +offset : uint32
            }

            enum stats_granularity {
                hourly
                daily
            }

            class telemetry_stats_query <<struct>> {
                +start_time : time_point
                +end_time : time_point
                +granularity : stats_granularity
                +source : optional<telemetry_source>
                +source_name : optional<string>
                +level : optional<string>
            }

            class telemetry_stats <<struct>> {
                +period_start : time_point
                +source : telemetry_source
                +source_name : string
                +component : string
                +level : string
                +log_count : uint64
                +unique_sessions : uint32
                +unique_accounts : uint32
            }

            span_context *-- trace_id
            span_context *-- span_id
            span *-- span_context
            span *-- span_kind
            span *-- span_status_code
            span o-- span_link
            span_link *-- span_context
            log_record o-- trace_id
            log_record o-- span_id
            log_record o-- resource
            telemetry_context *-- span_context
            telemetry_context o-- resource
            telemetry_log_entry o-- telemetry_source
            telemetry_query o-- telemetry_source
            telemetry_stats_query o-- stats_granularity
            telemetry_stats o-- telemetry_source
        }

        namespace generators #D4D4E8 {
            class trace_id_generator <<class>> {
                -machine_id_ : uint16
                -random_engine_ : mt19937_64
                -mutex_ : mutex
                --
                +trace_id_generator()
                +trace_id_generator(machine_id)
                +operator()() : trace_id
                +machine_id() : uint16
                {static} -derive_machine_id() : uint16
            }

            class span_id_generator <<class>> {
                -sequence_ : atomic<uint16>
                -last_timestamp_ms_ : uint64
                -random_engine_ : mt19937
                -mutex_ : mutex
                --
                +span_id_generator()
                +operator()() : span_id
            }

            trace_id_generator ..> domain::trace_id : creates
            span_id_generator ..> domain::span_id : creates
        }

        namespace log #E8E8F4 {
            note "Logging infrastructure built on Boost.Log\nwith telemetry integration for log correlation." as log_note

            enum boost_severity {
                trace
                debug
                info
                warn
                error
            }
            note right of boost_severity
                Internal enum for Boost.Log.
                Maps to domain::severity_level.
            end note

            class lifecycle_manager <<class>> {
                -file_sink_ : shared_ptr<file_sink_type>
                -console_sink_ : shared_ptr<console_sink_type>
                -telemetry_sink_ : shared_ptr<telemetry_sink_type>
                --
                +lifecycle_manager(options)
                +~lifecycle_manager()
                +add_telemetry_sink(resource, handler)
            }
            note right of lifecycle_manager
                Manages Boost.Log sinks:
                console, file, and telemetry.
            end note

            class telemetry_sink_backend <<class>> {
                -resource_ : shared_ptr<resource>
                -handler_ : log_record_handler
                --
                +telemetry_sink_backend(resource, handler)
                +consume(record_view)
            }
            note bottom of telemetry_sink_backend
                Boost.Log sink that converts
                log records to telemetry format
                with trace/span correlation.
            end note

            class logging_options <<struct>> {
                +severity : string
                +filename : string
                +output_to_console : bool
                +output_directory : path
                +tag : string
            }

            lifecycle_manager o-- telemetry_sink_backend
            telemetry_sink_backend ..> domain::log_record : creates
            telemetry_sink_backend o-- domain::resource
        }

        namespace exporting #F4E8E8 {
            note "Exporters for telemetry data." as exporting_note

            interface log_exporter <<interface>> {
                +export_record(log_record)
                +flush()
                +shutdown()
            }

            class file_log_exporter <<class>> {
                -mutex_ : mutex
                -file_ : ofstream
                -is_open_ : bool
                --
                +file_log_exporter(path)
                +export_record(log_record)
                +flush()
                +shutdown()
            }
            note right of file_log_exporter
                Exports log records as
                JSON Lines format.
            end note

            class hybrid_log_exporter <<class>> {
                -file_ : ofstream
                -send_callback_ : function
                -batch_ : vector<log_record>
                -batch_size_ : size_t
                --
                +hybrid_log_exporter(path, options, callback)
                +export_record(log_record)
                +flush()
                +shutdown()
            }
            note right of hybrid_log_exporter
                Writes to file AND optionally
                streams to server via callback.
            end note

            file_log_exporter ..|> log_exporter
            hybrid_log_exporter ..|> log_exporter
            log_exporter ..> domain::log_record : exports
        }

        namespace messaging #E8D4F4 {
            note "Protocol messages for server-side\ntelemetry persistence." as messaging_note

            class submit_telemetry_response <<struct>> {
                +success : bool
                +entries_accepted : uint32
                +message : string
                --
                +serialize() : vector<byte>
                {static} +deserialize(data) : expected
            }

            class get_telemetry_logs_request <<struct>> {
                +query : telemetry_query
                --
                +serialize() : vector<byte>
                {static} +deserialize(data) : expected
            }

            class get_telemetry_logs_response <<struct>> {
                +success : bool
                +entries : vector<telemetry_log_entry>
                +total_count : uint64
                +message : string
                --
                +serialize() : vector<byte>
                {static} +deserialize(data) : expected
            }

            class get_telemetry_stats_request <<struct>> {
                +query : telemetry_stats_query
                --
                +serialize() : vector<byte>
                {static} +deserialize(data) : expected
            }

            class get_telemetry_stats_response <<struct>> {
                +success : bool
                +stats : vector<telemetry_stats>
                +message : string
                --
                +serialize() : vector<byte>
                {static} +deserialize(data) : expected
            }

            get_telemetry_logs_request o-- domain::telemetry_query
            get_telemetry_logs_response o-- domain::telemetry_log_entry
            get_telemetry_stats_request o-- domain::telemetry_stats_query
            get_telemetry_stats_response o-- domain::telemetry_stats
        }

        namespace repository #F4E8D4 {
            note "Database persistence for telemetry logs.\nUses TimescaleDB hypertables." as repository_note

            class telemetry_entity <<struct>> {
                +id : uuid
                +timestamp : time_point
                +source : string
                +source_name : string
                +session_id : optional<uuid>
                +account_id : optional<uuid>
                +level : string
                +component : string
                +message : string
                +tag : string
                +recorded_at : time_point
            }

            class telemetry_mapper <<class>> {
                +to_entity(entry) : telemetry_entity
                +to_domain(entity) : telemetry_log_entry
            }

            class telemetry_repository <<class>> {
                -context_ : database::context
                --
                +create(entries) : size_t
                +query_logs(query) : vector<telemetry_log_entry>
                +query_stats(query) : vector<telemetry_stats>
                +count_logs(query) : uint64
            }
            note right of telemetry_repository
                Uses TimescaleDB hypertable
                for efficient time-series
                storage and queries.
            end note

            telemetry_repository ..> telemetry_mapper : uses
            telemetry_mapper ..> telemetry_entity : creates
            telemetry_mapper ..> domain::telemetry_log_entry : creates
        }
    }
}

' External dependencies
namespace ores::logging #FAFAFA {
    class lifecycle_manager <<abstract>>
    class logging_options <<struct>>
}

ores::telemetry::log::lifecycle_manager --|> ores::logging::lifecycle_manager
ores::telemetry::log::logging_options --|> ores::logging::logging_options

' Layout hints
domain::telemetry_context -[hidden]down- generators::trace_id_generator

' Local Variables:
' compile-command: "java -Djava.awt.headless=true -DPLANTUML_SECURITY_PROFILE=UNSECURE -DPLANTUML_LIMIT_SIZE=65535 -jar /usr/share/plantuml/plantuml.jar ores.telemetry.puml"
' End:
@enduml
