:PROPERTIES:
:ID: 2A3C7481-0984-D344-575B-7BFBB8D5A98B
:END:
#+title: Sprint Backlog 05
#+options: <:nil c:nil ^:nil d:nil date:nil author:nil toc:nil html-postamble:nil
#+todo: STARTED | COMPLETED CANCELLED POSTPONED BLOCKED
#+tags: { code(c) infra(i) analysis(n) agile(a) }
#+startup: inlineimages

* Sprint Mission

- implement bootstrap mode.
- finish up all remaining tasks around domain entities.

* Stories

** Active

#+begin: clocktable :maxlevel 3 :scope subtree :tags t :indent nil :emphasize nil :scope file :narrow 75 :formula % :block today
#+TBLNAME: today_summary
#+CAPTION: Clock summary at [2025-11-20 Thu 00:42], for Thursday, November 20, 2025.
|      | <75>                                                     |        |      |      |       |
| Tags | Headline                                                 | Time   |      |      |     % |
|------+----------------------------------------------------------+--------+------+------+-------|
|      | *Total time*                                             | *0:41* |      |      | 100.0 |
|------+----------------------------------------------------------+--------+------+------+-------|
|      | Stories                                                  | 0:41   |      |      | 100.0 |
|      | Active                                                   |        | 0:41 |      | 100.0 |
| code | Update =ores.client= with REPL commands for all entities |        |      | 0:41 | 100.0 |
#+end:

#+begin: clocktable :maxlevel 3 :scope subtree :tags t :indent nil :emphasize nil :scope file :narrow 75 :formula %
#+TBLNAME: sprint_summary
#+CAPTION: Clock summary at [2025-11-20 Thu 00:42]
|       | <75>                                                     |         |       |      |       |
| Tags  | Headline                                                 | Time    |       |      |     % |
|-------+----------------------------------------------------------+---------+-------+------+-------|
|       | *Total time*                                             | *20:09* |       |      | 100.0 |
|-------+----------------------------------------------------------+---------+-------+------+-------|
|       | Stories                                                  | 20:09   |       |      | 100.0 |
|       | Active                                                   |         | 20:09 |      | 100.0 |
| agile | Sprint and product backlog refinement                    |         |       | 2:35 |  12.8 |
| infra | Add AI generated sprint summary                          |         |       | 1:38 |   8.1 |
| infra | Add skill to generate release notes                      |         |       | 0:27 |   2.2 |
| code  | Version of =ores.qt= does not update                     |         |       | 0:54 |   4.5 |
| code  | Minor updates to UML diagrams                            |         |       | 0:13 |   1.1 |
| infra | Add support for project planning                         |         |       | 2:24 |  11.9 |
| code  | Add a "detached" mode                                    |         |       | 1:18 |   6.5 |
| code  | Merge update and create currency messages                |         |       | 1:07 |   5.5 |
| code  | Uninformative incompatible protocol version error in qt  |         |       | 1:11 |   5.9 |
| code  | Implement delete account                                 |         |       | 0:20 |   1.7 |
| code  | Reorganise CLI structure by entity                       |         |       | 4:43 |  23.4 |
| code  | Update =ores.client= with REPL commands for all entities |         |       | 3:19 |  16.5 |
#+end:

*** STARTED Sprint and product backlog refinement                     :agile:
    :LOGBOOK:
    CLOCK: [2025-11-18 Tue 09:16]--[2025-11-18 Tue 09:29] =>  0:13
    CLOCK: [2025-11-17 Mon 22:11]--[2025-11-17 Mon 22:21] =>  0:10
    CLOCK: [2025-11-17 Mon 09:50]--[2025-11-17 Mon 10:16] =>  0:26
    CLOCK: [2025-11-17 Mon 08:58]--[2025-11-17 Mon 09:10] =>  0:12
    CLOCK: [2025-11-17 Mon 08:50]--[2025-11-17 Mon 08:57] =>  0:07
    CLOCK: [2025-11-16 Sun 23:48]--[2025-11-16 Sun 23:57] =>  0:09
    CLOCK: [2025-11-16 Sun 23:37]--[2025-11-16 Sun 23:47] =>  0:10
    CLOCK: [2025-11-16 Sun 12:01]--[2025-11-16 Sun 13:09] =>  1:08
    :END:

Updates to sprint and product backlog.

#+begin_src emacs-lisp :exports none
;; agenda
(org-agenda-file-to-front)
#+end_src

#+name: pie-stories-chart
#+begin_src R :var sprint_summary=sprint_summary :results file graphics :exports results :file sprint_backlog_05_stories_pie_sorted.png :width 1920 :height 1080
library(conflicted)
library(ggplot2)
library(tidyverse)
library(tibble)

# Remove unnecessary rows (Total time, Stories, Active)
clean_sprint_summary <- tail(sprint_summary, -4)
stories <- unlist(clean_sprint_summary[2])
percent_values <- as.numeric(unlist(clean_sprint_summary[6]))

# Create a data frame and explicitly sort the stories by defining factor levels
df <- data.frame(
  stories = stories,
  percent = percent_values
) %>%
  # 1. Sort the data frame by percentage in descending order
  arrange(desc(percent)) %>%
  # 2. Convert 'stories' to a factor, setting the levels based on the sorted order.
  # This makes the order of the slices explicit for ggplot.
  mutate(
    stories = factor(stories, levels = stories),
    lab.pos = cumsum(percent) - 0.5 * percent
  )

# Manually selected colors to resemble the screenshot
custom_palette <- c(
  "#21518f", "#f37735", "#ffc425", "#81b214", "#d7385e",
  "#662e91", "#00a9ae", "#5c5c5c", "#a0c6e0", "#f8b195",
  "#ffe385", "#bde0fe", "#c5e0d4", "#e0b8a0", "#a56f8f",
  "#7a448a", "#4a9a9b", "#9b9b9b", "#6fa8dc", "#f7a072",
  "#ffd166", "#99d98c", "#ef5d60", "#9d529f", "#3a86ff",
  "#c1d6e1", "#f9e0ac", "#c2d6a4", "#e69a8d", "#a07d9f"
)

# Ensure the palette has enough colors for all stories.
if (length(custom_palette) < length(df$stories)) {
  warning("Not enough custom colors for all stories. Colors will repeat.")
  custom_palette <- rep(custom_palette, length.out = length(df$stories))
}


p <- ggplot(df, aes(x = "", y = percent, fill = stories)) +
  geom_bar(width = 1, stat = "identity") +
  coord_polar("y", start = 0) +
  scale_fill_manual(values = custom_palette) +
  ggtitle("Sprint 5: Resourcing per Story")  +
  labs(x = NULL, y = NULL, fill = "Stories") +
  theme_minimal() +
  theme(
    axis.text.x = element_blank(),
    panel.grid.major = element_blank(),
    panel.grid.minor = element_blank(),
    plot.title = element_text(hjust = 0.5, size = 18),
    legend.position = "right",
    legend.title = element_text(size = 14),
    legend.text = element_text(size = 12)
  )

print(p)
#+end_src

#+RESULTS: pie-stories-chart
[[file:sprint_backlog_05_stories_pie_sorted.png]]

#+name: stories-chart
#+begin_src R :var sprint_summary=sprint_summary :results file graphics :exports results :file sprint_backlog_05_stories.png :width 1200 :height 650
library(conflicted)
library(grid)
library(tidyverse)
library(tibble)

# Remove unnecessary rows.
clean_sprint_summary <- tail(sprint_summary, -4)
names <- unlist(clean_sprint_summary[2])
values <- as.numeric(unlist(clean_sprint_summary[6]))

# Create a data frame.
df <- data.frame(
  cost = values,
  stories = factor(names, levels = names[order(values, decreasing = FALSE)]),
  y = seq(length(names)) * 0.9
)

# Setup the colors
blue <- "#076fa2"

p <- ggplot(df) +
  aes(x = cost, y = stories) +
  geom_col(fill = blue, width = 0.6) +
  ggtitle("Sprint 5: Resourcing per Story") +
  xlab("Resourcing (%)") + ylab("Stories") +
  theme(text = element_text(size = 15))

print(p)
#+end_src

#+RESULTS: stories-chart
[[file:sprint_backlog_05_stories.png]]

#+name: tags-chart
#+begin_src R :var sprint_summary=sprint_summary :results file graphics :exports results :file sprint_backlog_05_tags.png :width 600 :height 400
library(conflicted)
library(grid)
library(tidyverse)
library(tibble)

# Remove unnecessary rows.
clean_sprint_summary <- tail(sprint_summary, -4)
names <- unlist(clean_sprint_summary[1])
values <- as.numeric(unlist(clean_sprint_summary[6]))

# Create a data frame.
df <- data.frame(
  cost = values,
  tags = names,
  y = seq(length(names)) * 0.9
)
# factor(names, levels = names[order(values, decreasing = FALSE)])

df2 <- setNames(aggregate(df$cost, by = list(df$tags), FUN = sum),  c("cost", "tags"))
# Setup the colors
blue <- "#076fa2"

p <- ggplot(df2) +
  aes(x = cost, y = tags) +
  geom_col(fill = blue, width = 0.6) +
  ggtitle("Sprint 5: Resourcing per Tag") +
  xlab("Resourcing (%)") + ylab("Story types") +
  theme(text = element_text(size = 15))

print(p)
#+end_src

#+RESULTS: tags-chart
[[file:sprint_backlog_05_tags.png]]

[[file:sprint_backlog_05_plan.png]]

[[file:sprint_backlog_05_plan.png]]

*** COMPLETED Add AI generated sprint summary                         :infra:
    :LOGBOOK:
    CLOCK: [2025-11-16 Sun 21:58]--[2025-11-16 Sun 22:19] =>  0:21
    CLOCK: [2025-11-16 Sun 19:22]--[2025-11-16 Sun 19:38] =>  0:16
    CLOCK: [2025-11-16 Sun 17:21]--[2025-11-16 Sun 18:22] =>  1:01
    :END:

It is a bit difficult to make sense of a sprint with all the story details. We
should use AI to make a human readable summary. Also, add a skill for this.

*** COMPLETED Add skill to generate release notes                     :infra:
    :LOGBOOK:
    CLOCK: [2025-11-16 Sun 23:10]--[2025-11-16 Sun 23:37] =>  0:27
    :END:

It should be quite straightforward to do this, based on the spr

*** COMPLETED Create a claude code skill to open a new sprint          :code:

Needs to update all of the version strings, copy backlog etc. Create the skill
as part of opening next sprint.

Created, just needs to be tested at the end of this sprint.

*** COMPLETED Resolve all of the OpenSSL leaks in valgrind             :code:

*Rationale*: According to LLMs, all the leaks left are just initialisation and
can be ignored. Added them to suppression.

We are freeing up open SSL memory and still have leaks. For now just apply the
suppression suggestions and deal with this later.

*** COMPLETED Investigate valgrind leak on sqlgen                      :code:

*Rationale*: All the sqlgen leaks we were aware of were fixed and patched upstream.

Is this a real leak:

#+begin_src valgrind-leak
==2599359==
==2599359== HEAP SUMMARY:
==2599359==     in use at exit: 11,421 bytes in 78 blocks
==2599359==   total heap usage: 403,744 allocs, 403,666 frees, 161,473,513 bytes allocated
==2599359==
==2599359== 1,944 bytes in 9 blocks are definitely lost in loss record 20 of 21
==2599359==    at 0x4F2B818: malloc (vg_replace_malloc.c:446)
==2599359==    by 0x5AE29FF: PQmakeEmptyPGresult (fe-exec.c:161)
==2599359==    by 0x5AEA9F2: pqParseInput3 (fe-protocol3.c:264)
==2599359==    by 0x5AE5853: parseInput (fe-exec.c:1997)
==2599359==    by 0x5AE5975: PQgetResult (fe-exec.c:2083)
==2599359==    by 0x5AE5FB7: PQexecFinish (fe-exec.c:2388)
==2599359==    by 0x5AE5D98: PQprepare (fe-exec.c:2275)
==2599359==    by 0x5A7F688: sqlgen::postgres::Connection::insert(sqlgen::dynamic::Insert const&, std::vector<std::vector<std::optional<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > >, std::allocator<std::optional<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > > > >, std::allocator<std::vector<std::optional<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > >, std::allocator<std::optional<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > > > > > > const&) (Connection.cpp:44)
==2599359==    by 0x525189F: sqlgen::Session<sqlgen::postgres::Connection>::insert(sqlgen::dynamic::Insert const&, std::vector<std::vector<std::optional<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > >, std::allocator<std::optional<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > > > >, std::allocator<std::vector<std::optional<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > >, std::allocator<std::optional<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > > > > > > const&) (Session.hpp:50)
==2599359==    by 0x523F4FF: sqlgen::Transaction<sqlgen::Session<sqlgen::postgres::Connection> >::insert(sqlgen::dynamic::Insert const&, std::vector<std::vector<std::optional<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > >, std::allocator<std::optional<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > > > >, std::allocator<std::vector<std::optional<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > >, std::allocator<std::optional<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > > > > > > const&) (Transaction.hpp:61)
==2599359==    by 0x523EE20: rfl::Result<rfl::Ref<sqlgen::Transaction<sqlgen::Session<sqlgen::postgres::Connection> > > > sqlgen::insert_impl<__gnu_cxx::__normal_iterator<ores::accounts::repository::account_entity const*, std::vector<ores::accounts::repository::account_entity, std::allocator<ores::accounts::repository::account_entity> > >, __gnu_cxx::__normal_iterator<ores::accounts::repository::account_entity const*, std::vector<ores::accounts::repository::account_entity, std::allocator<ores::accounts::repository::account_entity> > >, sqlgen::Transaction<sqlgen::Session<sqlgen::postgres::Connection> > >(rfl::Ref<sqlgen::Transaction<sqlgen::Session<sqlgen::postgres::Connection> > > const&, __gnu_cxx::__normal_iterator<ores::accounts::repository::account_entity const*, std::vector<ores::accounts::repository::account_entity, std::allocator<ores::accounts::repository::account_entity> > >, __gnu_cxx::__normal_iterator<ores::accounts::repository::account_entity const*, std::vector<ores::accounts::repository::account_entity, std::allocator<ores::accounts::repository::account_entity> > >, bool) requires is_connection<sqlgen::Transaction<sqlgen::Session<sqlgen::postgres::Connection> > > (insert.hpp:46)
==2599359==    by 0x523EB55: auto sqlgen::insert_impl<std::vector<ores::accounts::repository::account_entity, std::allocator<ores::accounts::repository::account_entity> >, rfl::Ref<sqlgen::Transaction<sqlgen::Session<sqlgen::postgres::Connection> > > >(rfl::Ref<sqlgen::Transaction<sqlgen::Session<sqlgen::postgres::Connection> > > const&, std::vector<ores::accounts::repository::account_entity, std::allocator<ores::accounts::repository::account_entity> > const&, bool) (insert.hpp:69)
==2599359==
==2599359== 3,672 bytes in 17 blocks are definitely lost in loss record 21 of 21
==2599359==    at 0x4F2B818: malloc (vg_replace_malloc.c:446)
==2599359==    by 0x5AE29FF: PQmakeEmptyPGresult (fe-exec.c:161)
==2599359==    by 0x5AEA78E: pqParseInput3 (fe-protocol3.c:200)
==2599359==    by 0x5AE5853: parseInput (fe-exec.c:1997)
==2599359==    by 0x5AE5975: PQgetResult (fe-exec.c:2083)
==2599359==    by 0x5AE5FB7: PQexecFinish (fe-exec.c:2388)
==2599359==    by 0x5AE5E15: PQexecPrepared (fe-exec.c:2298)
==2599359==    by 0x5A7FB5B: sqlgen::postgres::Connection::insert(sqlgen::dynamic::Insert const&, std::vector<std::vector<std::optional<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > >, std::allocator<std::optional<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > > > >, std::allocator<std::vector<std::optional<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > >, std::allocator<std::optional<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > > > > > > const&) (Connection.cpp:72)
==2599359==    by 0x525189F: sqlgen::Session<sqlgen::postgres::Connection>::insert(sqlgen::dynamic::Insert const&, std::vector<std::vector<std::optional<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > >, std::allocator<std::optional<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > > > >, std::allocator<std::vector<std::optional<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > >, std::allocator<std::optional<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > > > > > > const&) (Session.hpp:50)
==2599359==    by 0x523F4FF: sqlgen::Transaction<sqlgen::Session<sqlgen::postgres::Connection> >::insert(sqlgen::dynamic::Insert const&, std::vector<std::vector<std::optional<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > >, std::allocator<std::optional<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > > > >, std::allocator<std::vector<std::optional<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > >, std::allocator<std::optional<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > > > > > > const&) (Transaction.hpp:61)
==2599359==    by 0x523EE20: rfl::Result<rfl::Ref<sqlgen::Transaction<sqlgen::Session<sqlgen::postgres::Connection> > > > sqlgen::insert_impl<__gnu_cxx::__normal_iterator<ores::accounts::repository::account_entity const*, std::vector<ores::accounts::repository::account_entity, std::allocator<ores::accounts::repository::account_entity> > >, __gnu_cxx::__normal_iterator<ores::accounts::repository::account_entity const*, std::vector<ores::accounts::repository::account_entity, std::allocator<ores::accounts::repository::account_entity> > >, sqlgen::Transaction<sqlgen::Session<sqlgen::postgres::Connection> > >(rfl::Ref<sqlgen::Transaction<sqlgen::Session<sqlgen::postgres::Connection> > > const&, __gnu_cxx::__normal_iterator<ores::accounts::repository::account_entity const*, std::vector<ores::accounts::repository::account_entity, std::allocator<ores::accounts::repository::account_entity> > >, __gnu_cxx::__normal_iterator<ores::accounts::repository::account_entity const*, std::vector<ores::accounts::repository::account_entity, std::allocator<ores::accounts::repository::account_entity> > >, bool) requires is_connection<sqlgen::Transaction<sqlgen::Session<sqlgen::postgres::Connection> > > (insert.hpp:46)
==2599359==    by 0x523EB55: auto sqlgen::insert_impl<std::vector<ores::accounts::repository::account_entity, std::allocator<ores::accounts::repository::account_entity> >, rfl::Ref<sqlgen::Transaction<sqlgen::Session<sqlgen::postgres::Connection> > > >(rfl::Ref<sqlgen::Transaction<sqlgen::Session<sqlgen::postgres::Connection> > > const&, std::vector<ores::accounts::repository::account_entity, std::allocator<ores::accounts::repository::account_entity> > const&, bool) (insert.hpp:69)
==2599359==
==2599359== LEAK SUMMARY:
==2599359==    definitely lost: 5,616 bytes in 26 blocks
==2599359==    indirectly lost: 0 bytes in 0 blocks
==2599359==      possibly lost: 0 bytes in 0 blocks
==2599359==    still reachable: 5,805 bytes in 52 blocks
==2599359==         suppressed: 0 bytes in 0 blocks
==2599359== Reachable blocks (those to which a pointer was found) are not shown.
==2599359== To see them, rerun with: --leak-check=full --show-leak-kinds=all
==2599359==
==2599359== For lists of detected and suppressed errors, rerun with: -s
==2599359== ERROR SUMMARY: 2 errors from 2 contexts (suppressed: 0 from 0)
#+end_src

*** COMPLETED Copy across icons and other assets to package            :code:

*Rationale*: All of the icon errors were resolved last sprint.

At present when you start the gui you get:

: /opt/OreStudio/0.0.3/bin/ores.qt
: qt.svg: Cannot open file '/home/marco/money-pound-box-line.svg', because: No such file or directory
: qt.svg: Cannot open file '/home/marco/money-pound-box-line.svg', because: No such file or directory

We need to put the assets under a suitable directory in opt and try to open them
from there.

*** COMPLETED Implement database configuration                         :code:

*Rationale*: this has now been done.

We have hard coded database configuration. Implement this properly both for
console and UI.

*** COMPLETED Fix site links to main page                               :doc:

*Rationale*: Fixed with the introduction of =index.org=.

At present we renamed readme to index in the HTML export. Do a symlink or a copy
of this file to fix links.

*** COMPLETED Add JSON parsing support for currency                    :code:

*Rationale*: This is now available via reflect-cpp.

We need to have the ability to read and write currencies from JSON.

*** COMPLETED Version of =ores.qt= does not update                     :code:
    :LOGBOOK:
    CLOCK: [2025-11-17 Mon 09:27]--[2025-11-17 Mon 09:35] =>  0:08
    CLOCK: [2025-11-17 Mon 00:39]--[2025-11-17 Mon 00:47] =>  0:08
    CLOCK: [2025-11-17 Mon 00:00]--[2025-11-17 Mon 00:38] =>  0:38
    :END:

For some reason updating =version.hpp= is not sufficient to get =ores.qt= to
update its version info.

We duplicated the version files when we split headers from implementation.

Notes:

- log the commit as well.
- use a standard version string for all products so we can easily grep for it.

*** COMPLETED Minor updates to UML diagrams                            :code:
    :LOGBOOK:
    CLOCK: [2025-11-17 Mon 09:36]--[2025-11-17 Mon 09:49] =>  0:13
    :END:

Review the diagrams and find any remaining inconsistencies. Update the skill as
required.

*** COMPLETED Add support for project planning                        :infra:
    :LOGBOOK:
    CLOCK: [2025-11-17 Mon 16:00]--[2025-11-17 Mon 16:25] =>  0:25
    CLOCK: [2025-11-17 Mon 14:00]--[2025-11-17 Mon 14:53] =>  0:53
    CLOCK: [2025-11-17 Mon 10:17]--[2025-11-17 Mon 11:23] =>  1:06
    :END:

We need some basic way of keeping track of broad milestones. Copy across the
approach we add for Dogen and polish it up.

*** COMPLETED Add a "detached" mode                                    :code:
   :LOGBOOK:
   CLOCK: [2025-11-17 Mon 21:21]--[2025-11-17 Mon 21:38] =>  0:17
   CLOCK: [2025-11-17 Mon 16:55]--[2025-11-17 Mon 17:56] =>  1:01
   :END:

At present we can detach all windows but if we then create a new one, we still
have to detach it. It would be nice to set the default to detach or not, and
then use that setting. Actually we just removed reattach to avoid issues of
ownership. You still need to manually detach.

*** COMPLETED Merge update and create currency messages                :code:
    :LOGBOOK:
    CLOCK: [2025-11-17 Mon 23:11]--[2025-11-17 Mon 23:36] =>  0:25
    CLOCK: [2025-11-17 Mon 22:28]--[2025-11-17 Mon 23:10] =>  0:42
    :END:

Due to how repositories work for bitemporal, we are always writing anyways. So
we don't really need complex logic around updating versus creating a new
currency. We need to simplify the UI and client / server code to have a single
message type for both.

**** Architectural Assessment

***** Impact Summary

This change affects all three main architectural layers:

- *Infrastructure Layer*: Reduce message protocol from 4 to 2 types (breaking
  change).
- *Domain Layer*: Merge handlers and simplify repository interface.
- *Application Layer*: Simplify Qt dialog and client code.

***** Current State

Infrastructure (ores.comms):

- Message types: =create_currency_request/response= (0x1009/0x100A) and
  =update_currency_request/response= (0x1003/0x1004)

Domain (ores.risk):

- =handle_create_currency_request()= calls =currency_repo_.write()=
- =handle_update_currency_request()= calls =currency_repo_.update()=
- Both methods effectively do the same thing: insert new row with temporal
  versioning.

Application (ores.qt):

- =CurrencyDetailDialog= uses =isAddMode_= flag to branch on message type.
- Lines 214-224: Sends different request types.
- Lines 235-251: Deserializes different response types.
- Lines 277-287: Emits different signals (=currencyCreated= vs
  =currencyUpdated=).

***** Affected Files

1. =projects/ores.comms/include/ores.comms/protocol/message_types.hpp=
2. =projects/ores.risk/include/ores.risk/messaging/protocol.hpp=
3. =projects/ores.risk/src/messaging/protocol.cpp=
4. =projects/ores.risk/src/messaging/risk_message_handler.cpp=
5. =projects/ores.risk/include/ores.risk/messaging/risk_message_handler.hpp=
6. =projects/ores.risk/include/ores.risk/repository/currency_repository.hpp=
7. =projects/ores.risk/src/repository/currency_repository.cpp=
8. =projects/ores.qt/src/CurrencyDetailDialog.cpp=
9. =projects/ores.qt/include/ores.qt/CurrencyDetailDialog.hpp=
10. Test files for all affected components

**** Migration Plan

***** Step 1: Domain Layer - Repository Simplification

- [ ] Remove =update()= method from =currency_repository= class.
- [ ] Update repository tests to use =write()= for both create and update
  scenarios.
- [ ] Verify all tests pass.
- Build target: =ores.risk.lib=
- Test target: =ores.risk.tests=

***** Step 2: Domain Layer - Messaging Consolidation

- [ ] Rename =create_currency_request/response= to
  =save_currency_request/response=.
- [ ] Remove =update_currency_request/response= types from =protocol.hpp= and
  =protocol.cpp=.
- [ ] Merge =handle_create_currency_request()= and
  =handle_update_currency_request()= into =handle_save_currency_request()=
- [ ] Update =risk_message_handler= to use single handler
- [ ] Update messaging tests
- [ ] Verify all tests pass
- Build target: =ores.risk.lib=
- Test target: =ores.risk.tests=

***** Step 3: Infrastructure Layer - Protocol Update

- [ ] In =message_types.hpp=, rename =create_currency_request/response= to
  =save_currency_request/response=
- [ ] Remove =update_currency_request/response= enum values
- [ ] Update protocol version to indicate breaking change
- [ ] Update protocol documentation
- Build target: =ores.comms.lib=
- Test target: =ores.comms.tests=

***** Step 4: Application Layer - Qt Dialog Simplification

- [ ] In =CurrencyDetailDialog.cpp=, simplify =onSaveClicked()= to always send
  =save_currency_request=
- [ ] Remove branching on =isAddMode_= for message type selection (lines 214-224)
- [ ] Simplify response handling to use single =save_currency_response= (lines 235-251)
- [ ] Consider keeping =isAddMode_= for UI behavior (e.g., ISO code readonly after save)
- [ ] Keep or merge =currencyCreated= and =currencyUpdated= signals based on caller needs
- [ ] Update Qt tests
- Build target: =ores.qt=
- Manual test: Create and edit currencies in GUI

***** Step 5: Application Layer - Client Updates

- [ ] Review =ores.client= for any usage of update/create currency messages
- [ ] Update if needed (client likely uses repository directly)
- Build target: =ores.client=
- Manual test: REPL currency operations

***** Step 6: Documentation and Diagrams

- [ ] Update =projects/ores.risk/modeling/ores.risk.puml= to reflect merged messages
- [ ] Update =projects/ores.comms/modeling/ores.comms.puml= to reflect protocol changes
- [ ] Regenerate diagrams with: =cmake --build --target generate_ores_risk_diagram
  --preset linux-clang-debug=
- [ ] Regenerate diagrams with: =cmake --build --target
  generate_ores_comms_diagram --preset linux-clang-debug=

***** Step 7: Integration Testing

- [ ] Build entire project: =cmake --build --preset linux-clang-debug=
- [ ] Run all tests: =cmake --build --preset linux-clang-debug --target rat=
- [ ] Manual end-to-end test: Create currency via GUI → Save → Edit → Save → Verify history
- [ ] Verify currency history shows proper temporal versioning
- [ ] Test with service: Start service, connect with Qt client, perform create/update operations

***** Step 8: Backwards Compatibility Consideration

Note: This is a *breaking protocol change*. Clients using old protocol will not
be compatible.

Options to consider:

- Accept breaking change (simpler, justified by better design)
- Implement protocol version negotiation (more complex, may be overkill)
- Recommended: Accept breaking change, document in release notes


*** CANCELLED Split console recipes by entity                          :code:

*Rationale*: This work will be carried out as part of the client and CLI
refactors.

At present we have one very long file, but this is not scalable. We could split
out:

- general args (help, info, etc)
- by entity

Notes:

- Rename console to CLI.
- reduce output, only first few entries are needed.
- add a toc.

*** COMPLETED Uninformative incompatible protocol version error in qt  :code:
    :LOGBOOK:
    CLOCK: [2025-11-18 Tue 09:55]--[2025-11-18 Tue 10:16] =>  0:21
    CLOCK: [2025-11-18 Tue 09:30]--[2025-11-18 Tue 09:54] =>  0:24
    CLOCK: [2025-11-17 Mon 23:40]--[2025-11-18 Tue 00:06] =>  0:26
    :END:

Note: most work done but Qt UI still shows incorrect message.

As part of the merging of currency messages we did a backwards incompatible
change in the protocol. I tested how the client handles this and it was not
great. It shows a message to the user saying "Failed to connect to server:
failed to connect to server". Ideally it should say something like:

#+begin_quote
Incompatible protocol version between server and client. Server version: 2.
Client version 1. Please upgrade the client.
#+end_quote

In addition to this, the client does not seem to log the protocol version. The
server does:

#+begin_src logview
2025-11-17 23:27:02.733675 [INFO] [ores.comms.server] ORES Server starting on port 55555 (identifier: ores-service-v1)
2025-11-17 23:27:02.733701 [INFO] [ores.comms.server] Protocol version: 2.0
2025-11-17 23:27:02.733816 [INFO] [ores.comms.server] Server listening on port 55555
#+end_src

The client should do the exact same thing on connect to make troubleshooting
easier. We should also add the protocol version to the about text so that we can
easily know without having to look at the logs.

Client logs:

#+begin_src logview
2025-11-17 23:27:26.381109 [INFO] [ores.comms.client] Sent handshake request. Client: ores-qt-client Version: 1.0
2025-11-17 23:27:26.381132 [DEBUG] [ores.comms.client] About to read handshake response frame
2025-11-17 23:27:26.381155 [DEBUG] [ores.comms.connection] Waiting to read the next frame.
2025-11-17 23:27:26.392206 [ERROR] [ores.comms.connection] Network error in read_frame: stream truncated [asio.ssl.stream:1]
2025-11-17 23:27:26.392293 [ERROR] [ores.comms.client] Failed to read handshake response.  Error code: 7
2025-11-17 23:27:26.392325 [ERROR] [ores.comms.client] Protocol handshake failed.
2025-11-17 23:27:26.392430 [INFO] [ores.comms.client] Disconnected from server
2025-11-17 23:27:26.392464 [DEBUG] [ores.comms.client] connect_sync: task completed, result=false
2025-11-17 23:27:26.392551 [DEBUG] [ores.comms.client] connect_sync: returning false
2025-11-17 23:27:26.392652 [DEBUG] [ores.comms.login_dialog] On connection result called.
2025-11-17 23:27:26.392683 [WARN] [ores.comms.login_dialog] Connection was not successful.
2025-11-17 23:27:26.392704 [INFO] [ores.comms.login_dialog] Enable form: true
#+end_src

Server logs:

#+begin_src logview
2025-11-17 23:27:02.733816 [INFO] [ores.comms.server] Server listening on port 55555
2025-11-17 23:27:26.377606 [INFO] [ores.comms.server] Accepted connection from 127.0.0.1:48894
2025-11-17 23:27:26.377913 [INFO] [ores.comms.session] Session started for client: 127.0.0.1:48894
2025-11-17 23:27:26.381088 [DEBUG] [ores.comms.session] Starting server handshake process...
2025-11-17 23:27:26.381132 [DEBUG] [ores.comms.session] About to read handshake request frame from client
2025-11-17 23:27:26.381178 [DEBUG] [ores.comms.connection] Waiting to read the next frame.
2025-11-17 23:27:26.381293 [DEBUG] [ores.comms.connection] Read header of size: 32
2025-11-17 23:27:26.381332 [DEBUG] [ores.comms.protocol.frame] Deserializing frame header from data of size: 32
2025-11-17 23:27:26.381358 [ERROR] [ores.comms.protocol.frame] Invalid major version: 1
2025-11-17 23:27:26.381382 [ERROR] [ores.comms.connection] Failed to deserialize header, error: 1
2025-11-17 23:27:26.381422 [ERROR] [ores.comms.session] Failed to read handshake request: error code 1
2025-11-17 23:27:26.381454 [WARN] [ores.comms.session] Handshake failed for client: 127.0.0.1:48894
2025-11-17 23:27:26.381478 [DEBUG] [ores.comms.server] Session completed, active connections: 0
#+end_src

**** Problem Analysis

*Current behavior:*

1. Client (v1) sends handshake request with v1 in frame header
2. Server tries to deserialize frame header
3. Frame deserializer at =frame.cpp:204-207= checks version and returns
   =version_mismatch= error
4. Session cannot read the frame, logs error, and closes connection
5. Client receives "stream truncated" error (connection closed unexpectedly)
6. Client shows uninformative "Failed to connect to server" message

*Root cause:*

The protocol version check happens too early - during frame header
deserialisation in =frame.cpp=. By the time the error is detected, the server
cannot send a proper error response because it failed to even read the frame.

*What should happen:*

1. Server reads handshake request frame (even with mismatched version)
2. Session deserializes handshake request and extracts client version
3. Session checks version compatibility (this code already exists at
   =session.cpp:101-119=)
4. Server sends =handshake_response= with version details and =version_mismatch=
   error code
5. Client receives response, extracts version information, and shows meaningful
   error message
6. Client logs protocol version on connect (like server does)
7. Qt About dialog shows protocol version for easy troubleshooting

**** Implementation Plan

***** COMPLETED Task 1: Allow Reading Frames During Handshake
      CLOSED: [2025-11-17 Sun]

- [X] Modify =frame::deserialize_header()= to accept optional
  =skip_version_check= parameter (default false)
- [X] Skip version validation when parameter is true
- [X] Update =connection::read_frame()= to support lenient reading during
  handshake
- [X] Ensure session uses lenient reading for handshake request

Modified files:
- =projects/ores.comms/include/ores.comms/protocol/frame.hpp= - Added =skip_version_check= parameter
- =projects/ores.comms/src/protocol/frame.cpp= - Implemented conditional version checking
- =projects/ores.comms/include/ores.comms/net/connection.hpp= - Added parameter to =read_frame()=
- =projects/ores.comms/src/net/connection.cpp= - Pass through skip_version_check parameter
- =projects/ores.comms/src/net/session.cpp= - Use lenient reading for handshake request

***** COMPLETED Task 2: Add Client Protocol Version Logging
      CLOSED: [2025-11-17 Sun]

- [X] Add protocol version logging in =client.cpp= on successful connection
- [X] Format: "Protocol version: X.Y" matching server format
- [X] Log after SSL handshake, before protocol handshake

Modified files:
- =projects/ores.comms/src/net/client.cpp= - Added protocol version logging at client.cpp:102-104

***** COMPLETED Task 3: Improve Client Error Handling
      CLOSED: [2025-11-17 Sun]

- [X] When handshake fails, check if response is =handshake_response= with
  =version_mismatch=
- [X] Extract server and client version from response
- [X] Create detailed error message: "Incompatible protocol version. Server:
  X.Y, Client: A.B"
- [X] Return this message through the error path to =LoginDialog=
- [X] Update LoginDialog to use =client_->last_error()= instead of hardcoded message

Modified files:
- =projects/ores.comms/include/ores.comms/net/client.hpp= - Added =last_error()= method and =last_error_= member
- =projects/ores.comms/src/net/client.cpp= - Store detailed error message on version mismatch, implement =last_error()= getter
- =projects/ores.qt/src/LoginDialog.cpp= - Use =client_->last_error()= to get detailed error message (lines 207-212)

***** COMPLETED Task 4: Add Protocol Version to Qt About Dialog
      CLOSED: [2025-11-17 Sun]

- [X] Locate Qt About dialog implementation
- [X] Add protocol version display: "Protocol Version: X.Y"
- [X] Place near application version information

Modified files:
- =projects/ores.qt/src/AboutDialog.cpp= - Added protocol version to version string display

***** COMPLETED Task 5: Testing
      CLOSED: [2025-11-17 Sun]

- [X] Test with matching versions (should work normally)
  - All unit tests pass (699 assertions in 146 test cases)
  - Build successful for all components
- [X] Verify client logs protocol version on connect
  - Added logging at client.cpp:102-106: "Protocol version: X.Y (client: identifier)"
- [X] Verify About dialog shows protocol version
  - Added to AboutDialog.cpp:73-77: "Version X | Build Y | Protocol Z.W"
- [X] Verify server sends proper =handshake_response= on version mismatch
  - Server already sends proper handshake_response with version_compatible flag (session.cpp:104-111)
  - Now accessible due to lenient frame reading during handshake
- [X] Add automated version mismatch tests
  - Added 3 test cases to frame_tests.cpp
  - Tests verify strict mode rejects mismatched versions
  - Tests verify lenient mode accepts mismatched versions
  - Tests simulate handshake scenario with version mismatch
  - All comms tests pass: 62 assertions in 9 test cases (up from 49 in 6)

Modified files:

- =projects/ores.comms/tests/frame_tests.cpp= - Added version mismatch test cases

Testing notes:

- Manual testing with mismatched versions would require temporarily changing
  PROTOCOL_VERSION_MAJOR in message_types.hpp, rebuilding, and running
  server/client with different versions
- The implementation ensures server can read handshake request even with
  version mismatch and sends detailed handshake_response
- Client stores detailed error message in =last_error_= accessible via =last_error()=

*** COMPLETED Implement delete account                                 :code:
    :LOGBOOK:
    CLOCK: [2025-11-18 Tue 08:45]--[2025-11-18 Tue 09:05] =>  0:20
    :END:

At present you cannot delete an account.

***** Tasks

Backend:
- [X] Add delete_account message types to protocol
- [X] Add delete_account_request/response message structs
- [X] Implement serialize/deserialize for delete_account messages
- [X] Add remove() method to account_repository for bitemporal soft delete
- [X] Implement handle_delete_account_request in message handler
- [X] Add protocol serialization tests (5 test cases)
- [X] Add message handler tests (2 test cases for success and failure)
- [X] Build and run all tests (90 test cases, 346 assertions, all passing)

CLI:
- [X] Add "accounts" to entity enum
- [X] Create delete_options configuration struct
- [X] Add delete_options to main options struct
- [X] Implement delete command parser infrastructure
- [X] Implement delete_account() in application (supports UUID or username)
- [X] Implement delete_data() dispatcher method
- [X] Add delete command to help text
- [X] Build and test CLI delete command

***** COMPLETED Implementation Details

****** Backend

Modified files:

- =projects/ores.comms/include/ores.comms/protocol/message_types.hpp= - Added delete_account_request (0x2009) and delete_account_response (0x200A) message types
- =projects/ores.accounts/include/ores.accounts/messaging/protocol.hpp= - Added delete_account_request and delete_account_response structs with serialize/deserialize methods
- =projects/ores.accounts/src/messaging/protocol.cpp= - Implemented serialization using write_uuid/read_uuid for account_id and write_bool/read_bool + write_string/read_string for response
- =projects/ores.accounts/include/ores.accounts/repository/account_repository.hpp= - Added remove() method declaration
- =projects/ores.accounts/src/repository/account_repository.cpp= - Implemented remove() method using bitemporal soft delete (sets valid_to = current_timestamp via database trigger)
- =projects/ores.accounts/src/service/account_service.cpp= - Updated delete_account() from stub to call repository remove() method
- =projects/ores.accounts/include/ores.accounts/messaging/accounts_message_handler.hpp= - Added handle_delete_account_request() declaration and updated class documentation
- =projects/ores.accounts/src/messaging/accounts_message_handler.cpp= - Added delete_account_request case to switch statement and implemented handler with try/catch for error handling
- =projects/ores.accounts/tests/messaging_protocol_tests.cpp= - Added 5 serialization tests: request with valid UUID, request serialize/deserialize, response success, response failure, response serialize/deserialize
- =projects/ores.accounts/tests/messaging_accounts_message_handler_tests.cpp= - Added 2 handler tests: successful deletion and deletion of non-existent account

****** CLI

Modified files:

- =projects/ores.cli/include/ores.cli/config/entity.hpp= - Added "accounts" to entity enum
- =projects/ores.cli/include/ores.cli/config/delete_options.hpp= - Created delete_options struct with target_entity and key fields
- =projects/ores.cli/src/config/delete_options.cpp= - Implemented stream output operator for delete_options
- =projects/ores.cli/include/ores.cli/config/options.hpp= - Added optional deleting field to main options struct
- =projects/ores.cli/src/config/options.cpp= - Updated stream output operator to include deleting field
- =projects/ores.cli/src/config/parser.cpp= - Added delete command constants, make_delete_options_description(), read_delete_options(), and integrated delete command into handle_command() and help text
- =projects/ores.cli/include/ores.cli/app/application.hpp= - Added delete_account() and delete_data() method declarations
- =projects/ores.cli/src/app/application.cpp= - Implemented delete_account() (supports deletion by UUID or username) and delete_data() (dispatcher for entity-specific deletion)

***** Notes

The implementation follows the same bitemporal soft-delete pattern used for currencies. When an account is deleted, the database trigger closes the temporal record by setting valid_to = current_timestamp, preserving the account's history while marking it as no longer active. The delete operation validates that the account exists before attempting deletion and returns appropriate success/failure messages.

The CLI implementation adds a new "delete" command that supports deleting accounts by either UUID or username. The command automatically detects whether the provided key is a UUID and, if not, treats it as a username and performs a lookup to find the corresponding account ID. This provides a flexible user experience while maintaining type safety at the database level.

*** COMPLETED Reorganise CLI structure by entity                       :code:
    :LOGBOOK:
    CLOCK: [2025-11-19 Wed 11:15]--[2025-11-19 Wed 12:13] =>  0:58
    CLOCK: [2025-11-18 Tue 21:54]--[2025-11-18 Tue 23:18] =>  1:24
    CLOCK: [2025-11-18 Tue 17:29]--[2025-11-18 Tue 18:00] =>  0:31
    CLOCK: [2025-11-18 Tue 14:30]--[2025-11-18 Tue 16:20] =>  1:50
    :END:

The structure of CLI commands at present is very confusing. We have import and
export as the top-level concepts, but in reality that is not how the tool should
work. The mission of the CLI tool is to wrap around repository functionality at
the entity level so that we can operate directly against the database without
going over the comms layer. Its units of work are relative to entities, for
example:

- currencies:
  - import currencies from ORE Format. We use the terminology "import" to mean
    bringing data from an external system.
  - export currencies to ORE format. We use the terminology "export" to mean
    taking data out to feed an external system.
  - list existing currencies as a table or as JSON. We need support for latest,
    "at time point" and "all" (meaning every single version). It should be
    possible to supply some filtering by primary key (e.g. =--iso-code=).
  - delete one or more currencies. User supplies a number of primary keys (e.g.
    =--iso-code ABC --iso-code CDE --iso-code FGH= and so on).
  - add a currency supplying arguments (e.g. =--iso-code= and so forth).
  - add currencies from JSON.
- accounts:
  - list existing currencies as a table or as JSON. We need support for latest,
    "at time point" and "all" (meaning every single version). It should be
    possible to supply some filtering by primary key.
  - delete one or more accounts. User supplies a list of primary keys.
  - add an account supplying arguments.
  - add accounts from JSON.
- feature flags:
  - list existing feature flags as a table or as JSON. We need support for
    latest, "at time point" and "all" (meaning every single version). It should
    be possible to supply some filtering by primary key.
  - delete one or more feature flags. User supplies a list of primary keys.
  - add feature flags supplying arguments.
  - add feature flags from JSON.

All of these operations should only involve repositories and possibly helper
classes such as exporter and importer.

What the ask is:

- reorganise existing commands to fit this pattern, being driven by entities
  rather than by import/export as it is at present. That is instead of:

#+begin_src sh
./ores.cli export --format xml --entity currencies
#+end_src

  We want:

#+begin_src sh
./ores.cli currencies export
#+end_src

  To mean "export currencies into ORE XML". And to list currencies:

#+begin_src sh
./ores.cli currencies list --format table
#+end_src

  Which means dump currencies as a table.

- update existing recipes to follow this pattern. Recipes should also be
  organised by entity rather than by import and export.
- add commands for missing entities such as accounts and feature flags.

***** Tasks

- [X] Analyze current CLI structure and command parsing
- [X] Design new entity-based command structure
- [X] Implement new command parser for entity-first syntax
- [X] Migrate currencies commands to new structure
- [X] Migrate accounts commands to new structure
- [X] Add feature flags commands
- [X] Update recipes to use new command structure
- [X] Build and test all CLI commands
- [X] Update help text and documentation
- [X] Remove legacy command-based syntax support

***** COMPLETED Phase 1: Foundation Structures
CLOSED: [2025-11-18 Tue]

Modified files:
- =projects/ores.cli/include/ores.cli/config/operation.hpp= - Created operation enum with import_data, export_data, list, delete_entity, add
- =projects/ores.cli/include/ores.cli/config/list_options.hpp= - Created list_options structure for listing entities
- =projects/ores.cli/src/config/list_options.cpp= - Implemented stream output operator
- =projects/ores.cli/include/ores.cli/config/options.hpp= - Added optional<list_options> listing field
- =doc/agile/v0/sprint_backlog_05.org= - Added design documentation

Notes:
- All new structures compile successfully
- Design documented in sprint backlog
- Pull request: https://github.com/OreStudio/OreStudio/pull/98
- Next phase: Implement currencies entity commands

***** COMPLETED Phase 2: Currencies Entity Commands
CLOSED: [2025-11-18 Tue]

Modified files:
- =projects/ores.cli/src/config/parser.cpp= - Added currencies command handler

Implementation details:
- Added =currencies= as a top-level command alongside import/export/delete
- Parser now accepts: =./ores.cli currencies <operation> [options]=
- Supported operations: import, export, list, delete
- Auto-populates entity field with "currencies"
- Reuses existing option structures (import_options, export_options, delete_options)
- Both old and new syntax work side-by-side

Examples:
- New: =./ores.cli currencies export --format xml=
- Old: =./ores.cli export --entity currencies --format xml=

Testing:
- [X] Compiles successfully
- [X] Help text shows currencies command
- [X] Operation-specific help works (e.g. =currencies export --help=)
- [X] Parser validates operations correctly

Notes:
- List operation reuses export options for now (future: dedicated list_options)
- Ready for additional entities (accounts, feature_flags) to follow same pattern
- Minimal changes maximize compatibility

***** COMPLETED Phase 3: All Entities Implementation
CLOSED: [2025-11-18 Tue]

Modified files:
- =projects/ores.cli/include/ores.cli/config/entity.hpp= - Added feature_flags to enum
- =projects/ores.cli/src/config/parser.cpp= - Added accounts and feature_flags handlers

Implementation details:
- Added =accounts= entity command with operations: list, delete, add
- Added =feature_flags= entity command with operations: list, delete, add
- All entities follow the same pattern as currencies
- Add operation marked as "not yet implemented" for accounts and feature_flags
- Both old and new syntax continue to work side-by-side

Supported commands:
1. Currencies:
   - =./ores.cli currencies import --target file.xml=
   - =./ores.cli currencies export --format xml=
   - =./ores.cli currencies list --format json=
   - =./ores.cli currencies delete --key USD=

2. Accounts:
   - =./ores.cli accounts list --format json=
   - =./ores.cli accounts delete --key username=
   - =./ores.cli accounts add= (placeholder)

3. Feature Flags:
   - =./ores.cli feature_flags list --format json=
   - =./ores.cli feature_flags delete --key flag_name=
   - =./ores.cli feature_flags add= (placeholder)

Testing:
- [X] All code compiles without warnings
- [X] Help text shows all three entity commands
- [X] Operation-specific help works for all entities
- [X] Parser validates operations correctly for each entity
- [X] Error messages guide users to valid operations

Summary:
- Complete entity-based CLI structure implemented for all current entities
- Backward compatible with existing command-based syntax
- Foundation in place for future entity additions
- Clean, consistent pattern across all entities

***** COMPLETED Phase 4: Legacy Syntax Removal
CLOSED: [2025-11-18 Tue]

Modified files:
- =projects/ores.cli/src/config/parser.cpp= - Removed legacy command handlers
- =doc/recipes/cli_entity_recipes.org= - Removed legacy syntax examples

Implementation details:
- Removed support for old command-based syntax (import, export, delete commands)
- CLI now exclusively accepts entity-based syntax
- Updated =validate_command_name()= to only accept entity commands (currencies, accounts, feature_flags)
- Updated help text to show only entity-based commands
- Removed "Legacy Command-Based Syntax" section from recipes

Testing:
- [X] Build successful with legacy handlers removed
- [X] Entity commands work correctly (currencies, accounts, feature_flags)
- [X] Help system displays only entity-based commands
- [X] Legacy commands properly rejected with helpful error message
- [X] All entity operations (import, export, list, delete) functional

Examples of rejected legacy syntax:
- =./ores.cli import --entity currencies= → Error: "Invalid or unsupported command: import"
- =./ores.cli export --entity accounts= → Error: "Invalid or unsupported command: export"
- =./ores.cli delete --entity currencies= → Error: "Invalid or unsupported command: delete"

Summary:
- Clean break from legacy syntax completed
- All functionality migrated to entity-based commands
- Documentation updated to reflect new syntax only
- User-friendly error messages guide users to correct syntax

***** Design

****** Current Structure
- Syntax: =./ores.cli <command> --entity <entity_name> <options>=
- Commands: =import=, =export=, =delete=
- Entities: =currencies=, =accounts=
- Example: =./ores.cli export --entity currencies --format xml=

****** New Structure
- Syntax: =./ores.cli <entity> <operation> [options]=
- Entities: =currencies=, =accounts=, (future: =feature_flags=)
- Operations per entity:
  - currencies: =import=, =export=, =list=, =delete=, =add=
  - accounts: =list=, =delete=, =add=
  - feature_flags: =list=, =delete=, =add=
- Example: =./ores.cli currencies export --format xml=

****** Implementation Approach
1. Modify parser.cpp to parse entity as first positional argument
2. Parse operation as second positional argument
3. Keep existing option structures (import_options, export_options, delete_options) but populate them based on entity+operation combination
4. Add new =list_options= structure for list command
5. Add new =add_options= structure for add command (future work)
6. Update help text to be entity-centric
7. Keep application.cpp mostly unchanged (just dispatch based on options)

*** STARTED Update =ores.client= with REPL commands for all entities   :code:
    :LOGBOOK:
    CLOCK: [2025-11-20 Thu 00:25]--[2025-11-20 Thu 00:42] =>  0:17
    CLOCK: [2025-11-19 Wed 22:53]--[2025-11-20 Thu 00:24] =>  1:31
    CLOCK: [2025-11-19 Wed 22:20]--[2025-11-19 Wed 22:52] =>  0:32
    CLOCK: [2025-11-19 Wed 17:01]--[2025-11-19 Wed 18:00] =>  0:59
    :END:

The job of the client is to exercise the entirety of the comms protocol, and to
provide a way to perform CRUD operations via command line. Note:

- client never access the repositories directly, it should do exactly the same as the qt client
  would do.
- client's only interface is the REPL.
- client will eventually be used by AI agents.

Client needs to have messages at the entity level:

- currencies:
  - import currencies from ORE Format. Given a path in the filesystem, it
    performs the import using the importer and appropriate comms messages.
  - export currencies to ORE format. Uses comms to obtain the currencies, then
    the exporter to convert, then dumps them into the terminal as ORE XML.
  - list existing currencies as a table or as JSON. We need support for latest,
    "at time point" and "all" (meaning every single version). It should be
    possible to supply some filtering by the entity's ID (e.g.
    =--iso-code=).
  - delete one or more currencies. User supplies a number of entity IDs (e.g.
    =--iso-code ABC --iso-code CDE --iso-code FGH= and so on).
  - add a currency supplying arguments (e.g. =--iso-code= and so forth).
  - add currencies from JSON.
- accounts:
  - list existing currencies as a table or as JSON. We need support for latest,
    "at time point" and "all" (meaning every single version). It should be
    possible to supply filtering by the entity's ID.
  - delete one or more accounts. User supplies a list of entity IDs.
  - add an account supplying arguments.
  - add accounts from JSON.
- feature flags:
  - list existing feature flags as a table or as JSON. We need support for
    latest, "at time point" and "all" (meaning every single version). It should
    be possible to supply some filtering by the entity's ID
  - delete one or more feature flags. User supplies a list of entity IDs.
  - add feature flags supplying arguments.
  - add feature flags from JSON.

Notes:

- update recipes with the new client commands.

*** Implement authentication bootstrap workflow                        :code:

Notes:

- when there are no accounts setup, the repl should say to the user that it
  needs to create an admin account.
- first account must be admin.
- once there is an account we need to make sure the user is logged in before we
  process most message types.

Mongo message:

#+begin_src logview
2020-06-09T13:26:51.391+0000 I  CONTROL  [initandlisten] ** WARNING: Access control is not enabled for the database.
2020-06-09T13:26:51.391+0000 I  CONTROL  [initandlisten] **          Read and write access to data and configuration is unrestricted.
#+end_src

Requirements:

#+begin_src markdown
# Authentication Bootstrapping Requirements

## R1: Initial System State (Bootstrap Mode)

The system **MUST** start in a special **"Bootstrap Mode"** where the only
permitted action is the creation of the initial Administrator account.

## R2: Access Control in Bootstrap Mode

While the system is in Bootstrap Mode:

- **R2.1: Allowed Endpoint:** The service **MUST** only expose and accept
  requests for a single endpoint: `POST /api/v1/accounts/create-admin` (or
  equivalent).
- **R2.2: Local-Only Restriction:** All requests to the allowed endpoint
  ,**MUST** originate from a **trusted local interface** (e.g., `127.0.0.1` or
  the server's designated internal IP range). Requests from any external/public
  IP address **MUST** be rejected.
- **R2.3: General Endpoint Rejection:** All other API endpoints (e.g., login,
  user creation, data access) **MUST** immediately return a $\mathbf{403}$
  ,**Forbidden** or $\mathbf{401}$ **Unauthorized** status, along with a clear
  message indicating the system is in setup mode.

## R3: Initial Admin Account Creation

The first account created through the allowed endpoint **MUST** adhere to the
following:

- **R3.1: Mandatory Admin Role:** The account **MUST** be assigned the highest
  level of **Administrator privileges** (`is_admin: true`).
- **R3.2: Strong Password Policy:** The request **MUST** be validated against a
  strong password policy (e.g., minimum 12 characters, requiring a mix of case,
  numbers, and symbols). Failure to meet this standard **MUST** result in a
  $\mathbf{400}$ **Bad Request** error.
- **R3.3: One-Time Execution:** The administrator creation process **MUST** only
  be allowed to succeed **exactly once**.

## R4: System State Transition

Upon successful creation of the first Administrator account (R3):

- **R4.1: State Change:** The system **MUST** immediately and atomically
  transition from **"Bootstrap Mode"** to **"Secure Mode"**. This state change
  ,**MUST** be persisted.
- **R4.2: Bootstrap Endpoint Deactivation:** The `POST
  /api/v1/accounts/create-admin` endpoint **MUST** be permanently disabled. Any
  subsequent request to this endpoint **MUST** return a $\mathbf{403}$
  ,**Forbidden** error.

## R5: Secure Mode Operation

Once the system is in **"Secure Mode"**:

- **R5.1: General Access Control:** All operational API endpoints **MUST** now
  enforce **full authentication and authorization**.
- **R5.2: Mandatory Login:** All users, including the newly created
  Administrator, **MUST** successfully complete a login process to obtain a
  valid session token before accessing any resource.
- **R5.3: Standard Account Creation:** The standard non-admin account creation
  endpoint (`POST /api/v1/accounts/create`) **MUST** become available, subject
  to any configured access controls (e.g., only open to logged-in Admins, or
  fully public).
#+end_src

Links:

- [[https://www.digitalocean.com/community/tutorials/how-to-secure-mongodb-on-ubuntu-20-04][How To Secure MongoDB on Ubuntu 20.04]]

*** Tidy-up database code                                              :code:

- add helpers to utility to ensure success, execute query, etc.
- add helpers for max timestamp, timestamp.

Merged stories:

*Add max timestamp to utilities*

We have it scattered around the code base.

*** Invalid password should not throw                                  :code:

At present in the unlock test we have:

#+begin_src c++
    BOOST_LOG_SEV(lg, info) << "Locking account by failing 5 login attempts";
    auto ip = internet::ipv4();
    for (int i = 0; i < 5; ++i) {
        try {
            sut.login(account.username, "wrong_password", ip);
        } catch (...) {}
    }
#+end_src

This is very suspicious; a failed login should just return false or the modern
c++ equivalent (=std::expected=?).

*** Faker with seeds                                                   :code:

As suggested by phi4:

#+begin_quote
Faker Usage:

Randomness: Ensure that the use of faker data is appropriate for testing.
Consider seeding the random generator for reproducibility in tests.
#+end_quote

Notes:

#include "faker-cxx/generator.h"
void setSeed(std::mt19937_64::result_type seed)
Catch::rngSeed()


*** Improve handling of error responses                                :code:

As per Gemini code review:

#+begin_src markdown
Certainly. Point \#2 from the review of `CurrencyHistoryDialog.cpp` addressed
the potential complexity of error checking by suggesting that relying on the
specific response message type is **fragile**.

The goal is to move from:

1.  Client sends **Request A**.
2.  Server returns **Response A** (Success) OR **Error Response** (Failure) OR
    ,**Response B** (Unexpected success type).
3.  Client checks: *Is the message type exactly **Response A**?*

to a more robust pattern where the client checks for a generic failure response
first.

-----

## 🐞 Fragile Error Check (Current Code)

The current code in `loadHistory` checks for success by expecting *only* the
specific success message type:

```cpp
// Current Fragile Logic
if (result->header().type != comms::protocol::message_type::get_currency_history_response) {
    onHistoryLoadError(QString("Server does not support currency history (received message type %1)")
        .arg(static_cast<int>(result->header().type)));
    return;
}
```

This logic has two main problems:

1.  **Hiding Server Errors:** If the server returns a generic protocol error
    (`message_type::error_response`) because, for example, the client's session
    timed out, the client logs a misleading message: "Server does not support
    currency history." It should be reporting the actual error message sent by
    the server.
2.  **Lack of Standardization:** Every client method needs to implement its own
    logic to handle unexpected types.

-----

## 🛠️ Suggested Improvement: Standardized Error Handling

The improvement is to check for a generic **`error_response`** message type
first, and report its payload/message, before attempting to deserialize the
successful response.

Assuming your system has a standard `error_response` message:

```cpp
void CurrencyHistoryDialog::handleHistoryResponse(const HistoryResult& result) {
    if (!result) {
        onHistoryLoadError(QString::fromStdString(result.error()));
        return;
    }

    // 1. Check for a generic server-side error response
    if (result->header().type == comms::protocol::message_type::error_response) {
        // Assume error_response contains a readable message payload
        auto error_response = risk::messaging::error_response::deserialize(result->payload());
        if (error_response) {
            onHistoryLoadError(QString::fromStdString(error_response->message));
        } else {
            onHistoryLoadError("Server returned a malformed error response.");
        }
        return;
    }

    // 2. Check for the specific SUCCESS response type
    if (result->header().type == comms::protocol::message_type::get_currency_history_response) {
        auto response = risk::messaging::get_currency_history_response::deserialize(result->payload());

        if (!response || !response->success) {
            // Handle success=false within the expected response type
            onHistoryLoadError(QString::fromStdString(response ? response->message : "Invalid or failed history response."));
            return;
        }

        history_ = std::move(response->history);
        onHistoryLoaded();
        return;
    }

    // 3. Handle truly unexpected message type
    onHistoryLoadError(QString("Received unexpected message type %1 from server.")
        .arg(static_cast<int>(result->header().type)));
}
```

By standardizing the **`error_response`** type, the client can always extract
and display the relevant server-side failure reason, leading to much clearer
logging and user feedback.
#+end_src

*** Use prebuilt qt                                                    :code:

At present we are having problems creating an installable gui. This is because
Qt is hard to build and package from vcpkg. We should use prebuilt binaries for
all platforms.

Links:

- [[https://github.com/jurplel/install-qt-action][install-qt-action]]

*** Sprint Demo                                                       :infra:

Time spent doing the demo. This is the first one so it will be very basic.

**** Presentation

***** ORE Studio v0.0.4, "Fazenda Camilunga"

    Marco Craveiro
    Moimba Software Engineering
    Released on 16th November 2025

*** Add =[[nodiscard]]= to repository operations returning data        :code:

At present we can create an account and ignore the result, etc. We should be
forced to look at the result.

*** Delete currency only deletes single currency                       :code:

At present we are deleting one currency at a time, sending a message for each,
in =CurrencyMdiWindow.cpp=.

*** CLI Importing needs to read from database                          :code:

After we do the import into the database, we need to read the currencies again
to get the valid from/to.

*** Add more account commands                                          :code:

See the azeroth account commands for inspiration.

Links:

- [[https://www.azerothcore.org/wiki/gm-commands][GM Commands]]

*** Add lock account request                                           :code:

As per gemini's comments, we should have a request to lock an account.

Notes:

- account unlock should return boolean rather than throw.

Test.

#+begin_src c++
TEST_CASE("handle_login_request_locked_account", tags) {
    auto lg(make_logger(test_suite));
    database_helper h;
    h.truncate_table(database_table);

    accounts_message_handler handler(h.get_context());
    boost::asio::io_context io_context;

    const auto account = generate_synthetic_account();
    create_account_request create_req(to_create_account_request(account));
    BOOST_LOG_SEV(lg, info) << "Create account request: " << create_req;

    const auto create_payload = create_req.serialize();
    run_co_test(io_context, [&]() -> boost::asio::awaitable<void> {
        auto result = co_await handler.handle_message(
            message_type::create_account_request,
            create_payload, "127.0.0.1:12345");
        REQUIRE(result.has_value());
    });

    // 2. Simulate locking the account (A dedicated lock request should exist,
    //    but for this test, we'll assume the handler has a method/logic for it
    //    or that the system supports a lock request message type).
    // Assuming a lock_account_request exists or the account is locked internally.
    unlock_account_request lock_req; // Re-use struct for simplicity, assuming a dedicated lock is handled internally
    lock_req.account_id = create_account_response::deserialize(
        handler.get_account_id_by_username(create_req.username)).value().account_id; // Hypothetical internal method
    // In a real system, you'd send a dedicated lock message here.
    // For now, we rely on a separate mechanism to put the account into a locked state.
    // **NOTE**: For a proper test, a dedicated LOCK_ACCOUNT_REQUEST is needed.

    // 3. Attempt login with valid credentials for the now-locked account
    login_request login_req;
    login_req.username = create_req.username;
    login_req.password = create_req.password;
    BOOST_LOG_SEV(lg, info) << "Attempting login for locked user: " << login_req.username;

    const auto login_payload = login_req.serialize();

    run_co_test(io_context, [&]() -> boost::asio::awaitable<void> {
        auto result = co_await handler.handle_message(
            message_type::login_request,
            login_payload, "192.168.1.100:54321");

        REQUIRE(result.has_value());
        const auto response_result = login_response::deserialize(result.value());
        REQUIRE(response_result.has_value());
        const auto& response = response_result.value();
        BOOST_LOG_SEV(lg, info) << "Response: " << response;

        CHECK(response.success == false);
        // Check for an explicit error message/code related to account lock.
        CHECK(response.error_message.find("locked") != std::string::npos);
    });
}
#+end_src



*** Add pagination support                                             :code:

At present we are returning all elements from accounts, currencies etc. We need
to implement pagination:

- Add offset and limit to list_accounts_request.
- Add total_available_count to list_accounts_response.

#+begin_src c++
std::vector<domain::account>
account_repository::read_latest(std::uint32_t offset, std::uint32_t limit) {
    BOOST_LOG_SEV(lg(), debug) << "Reading latest accounts with offset: "
                               << offset << " and limit: " << limit;

    static auto max(make_timestamp(max_timestamp));
    const auto query = sqlgen::read<std::vector<account_entity>> |
        where("valid_to"_c == max.value()) |
        order_by("valid_from"_c.desc()) |
        sqlgen::limit(limit) |
        sqlgen::offset(offset);

    const auto r = session(ctx_.connection_pool())
        .and_then(query);
    ensure_success(r);
    BOOST_LOG_SEV(lg(), debug) << "Read latest accounts. Total: " << r->size();
    return account_mapper::map(*r);
}


std::uint32_t account_repository::get_total_account_count() {
    BOOST_LOG_SEV(lg(), debug) << "Retrieving total active account count.";

    static auto max(make_timestamp(max_timestamp));

    // Select the count of records that are currently active (valid_to == max_timestamp)
    // We expect the result to be a vector containing a single long long (the count).
    using count_result_type = std::vector<long long>;
    const auto query = sqlgen::select<count_result_type>(sqlgen::count("id"_c)) |
        from<account_entity> |
        where("valid_to"_c == max.value());

    const auto r = session(ctx_.connection_pool())
        .and_then(query);
    ensure_success(r);

    if (r->empty() || r->at(0) < 0) {
        return 0;
    }

    const auto total_count = static_cast<std::uint32_t>(r->at(0));

    BOOST_LOG_SEV(lg(), debug) << "Total active accounts found: " << total_count;
    return total_count;
}
#+end_src


Links:

- [[https://readyset.io/blog/optimizing-sql-pagination-in-postgres][Optimizing SQL Pagination in Postgres]]




#+begin_src c++
"9999-12-31 23:59:59"
#+end_src




*** Improve error message when server is not running                   :code:

At present we get:

#+begin_quote
Failed to connect to server: Failed to connect to server
#+end_quote

If we try again after the error, "authenticating..." shows up in red.

*** Add tests to utilities                                             :code:

We should add some cursory tests to utilities.



*** Implement import XML                                               :code:

Users should be able to import data from ORE directly. Add option in Qt to
import XML.

*** Update currency details to use tabs                                :code:

We need a main tab with the currency related properties, then a "system" tab
with temporal data which is read-only even on edit and a "image" tab with the
image used to represent the currency. It could also contain some description or
notes.

*** Add search to currencies                                           :code:

It should be possible to filter the open currencies by a string. This should be
any field. The user needs to know when the list has been filtered.

*** Server must check database connectivity on startup                 :code:

At present the server only checks connectivity to database when a user requests
an operation. We need some kind of initial polling which puts the server in a
mode replying to all clients: "database not available". While this is happening,
it should keep polling the database and checking the connectivity.

Ideally the server should start, but poll the DB. It should send messages to
clients informing them of the issues with database.

*** Consider adding log command line options to qt                     :code:

At present we have hard-coded logging options. However, maybe users should be
able to change the logging settings from the UI rather than having to restart
the app and supply command line options.

* Footer

| Previous: [[id:154212FF-BB02-8D84-1E33-9338B458380A][Version Zero]] |
