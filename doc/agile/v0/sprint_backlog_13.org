:PROPERTIES:
:ID: 9A4009E7-0E6C-11F1-852D-40B0768014EB
:END:
#+title: Sprint Backlog 13
#+options: <:nil c:nil ^:nil d:nil date:nil author:nil toc:nil html-postamble:nil
#+todo: STARTED | COMPLETED CANCELLED POSTPONED BLOCKED
#+tags: { code(c) infra(i) analysis(n) agile(a) }
#+startup: inlineimages

* Sprint Mission

- Add trade support and FSM.

* Stories

** Active

#+begin: clocktable :maxlevel 3 :scope subtree :tags t :indent nil :emphasize nil :scope file :narrow 75 :formula % :block today
#+TBLNAME: today_summary
#+CAPTION: Clock summary at [2026-02-28 Sat 20:05], for Saturday, February 28, 2026.
|      | <75>                                    |        |      |      |       |
| Tags | Headline                                | Time   |      |      |     % |
|------+-----------------------------------------+--------+------+------+-------|
|      | *Total time*                            | *4:04* |      |      | 100.0 |
|------+-----------------------------------------+--------+------+------+-------|
|      | Stories                                 | 4:04   |      |      | 100.0 |
|      | Active                                  |        | 4:04 |      | 100.0 |
| code | Add batch support for saves and deletes |        |      | 4:04 | 100.0 |
#+end:

#+begin: clocktable :maxlevel 3 :scope subtree :tags t :indent nil :emphasize nil :scope file :narrow 75 :formula %
#+TBLNAME: sprint_summary
#+CAPTION: Clock summary at [2026-02-28 Sat 20:05]
|       | <75>                                                  |         |       |       |       |
| Tags  | Headline                                              | Time    |       |       |     % |
|-------+-------------------------------------------------------+---------+-------+-------+-------|
|       | *Total time*                                          | *72:13* |       |       | 100.0 |
|-------+-------------------------------------------------------+---------+-------+-------+-------|
|       | Stories                                               | 72:13   |       |       | 100.0 |
|       | Active                                                |         | 72:13 |       | 100.0 |
| agile | Sprint and product backlog refinement                 |         |       |  0:26 |   0.6 |
| infra | Generate release notes for previous sprint            |         |       |  1:16 |   1.8 |
| code  | Merge FSM into DQ                                     |         |       |  0:34 |   0.8 |
| code  | Make all details dialogs tabbed                       |         |       |  2:26 |   3.4 |
| code  | Provenance: Fix performed by and modified by stamping |         |       |  3:17 |   4.5 |
| code  | Add plotting of session data                          |         |       |  1:19 |   1.8 |
| code  | Add account-party management and login support        |         |       | 13:43 |  19.0 |
| code  | Add rounding type entity                              |         |       |  1:40 |   2.3 |
| code  | Polish business centre UI and data quality            |         |       |  0:58 |   1.3 |
| code  | Enhance currency taxonomy                             |         |       |  2:06 |   2.9 |
| code  | Books, portfolios and trades are not party specific   |         |       |  2:59 |   4.1 |
| code  | Minor improvements to connection browser              |         |       |  1:17 |   1.8 |
| code  | Rename currency asset classes                         |         |       |  1:05 |   1.5 |
| code  | Remove toolbars from detail dialogs                   |         |       |  5:57 |   8.2 |
| code  | Add portfolio explorer                                |         |       |  5:19 |   7.4 |
| code  | Analyse ORE trade import mapping requirements         |         |       |  1:08 |   1.6 |
| code  | Add scheduler binary protocol                         |         |       |  3:00 |   4.2 |
| code  | Add scheduling support                                |         |       |  6:48 |   9.4 |
| code  | Add a message queue                                   |         |       |  4:30 |   6.2 |
| code  | Add batch support for saves and deletes               |         |       |  5:32 |   7.7 |
| code  | Add party level currency and country restrictions     |         |       |  0:46 |   1.1 |
| code  | Add trade import mapping dialog to Qt UI              |         |       |  6:07 |   8.5 |
#+end:

*** STARTED Sprint and product backlog refinement                     :agile:
    :LOGBOOK:
    CLOCK: [2026-02-23 Mon 23:42]--[2026-02-24 Tue 00:00] =>  0:18
    CLOCK: [2026-02-20 Fri 15:10]--[2026-02-20 Fri 15:18] =>  0:08
    :END:

 Updates to sprint and product backlog.

#+begin_src emacs-lisp :exports none
;; agenda
(org-agenda-file-to-front)
#+end_src

#+name: pie-stories-chart
#+begin_src R :var sprint_summary=sprint_summary :colnames yes :results file graphics :exports results :file sprint_backlog_13_stories_pie_sorted.png :width 1920 :height 1080
library(conflicted)
library(ggplot2)
library(tidyverse)
library(tibble)

# Filter to only rows with actual story data (non-empty Tags column)
clean_sprint_summary <- sprint_summary %>% dplyr::filter(!is.na(Tags) & nzchar(Tags))
stories <- unlist(clean_sprint_summary[2])
percent_values <- as.numeric(unlist(clean_sprint_summary[6]))

# Create a data frame and explicitly sort the stories by defining factor levels
df <- data.frame(
  stories = stories,
  percent = percent_values
) %>%
  # 1. Sort the data frame by percentage in descending order
  arrange(desc(percent)) %>%
  # 2. Convert 'stories' to a factor, setting the levels based on the sorted order.
  # This makes the order of the slices explicit for ggplot.
  mutate(
    stories = factor(stories, levels = stories),
    lab.pos = cumsum(percent) - 0.5 * percent
  )

# Manually selected colors to resemble the screenshot
custom_palette <- c(
  "#21518f", "#f37735", "#ffc425", "#81b214", "#d7385e",
  "#662e91", "#00a9ae", "#5c5c5c", "#a0c6e0", "#f8b195",
  "#ffe385", "#bde0fe", "#c5e0d4", "#e0b8a0", "#a56f8f",
  "#7a448a", "#4a9a9b", "#9b9b9b", "#6fa8dc", "#f7a072",
  "#ffd166", "#99d98c", "#ef5d60", "#9d529f", "#3a86ff",
  "#c1d6e1", "#f9e0ac", "#c2d6a4", "#e69a8d", "#a07d9f"
)

# Ensure the palette has enough colors for all stories.
if (length(custom_palette) < length(df$stories)) {
  warning("Not enough custom colors for all stories. Colors will repeat.")
  custom_palette <- rep(custom_palette, length.out = length(df$stories))
}


p <- ggplot(df, aes(x = "", y = percent, fill = stories)) +
  geom_bar(width = 1, stat = "identity") +
  coord_polar("y", start = 0) +
  scale_fill_manual(values = custom_palette) +
  ggtitle("Sprint 13: Resourcing per Story")  +
  labs(x = NULL, y = NULL, fill = "Stories") +
  theme_minimal() +
  theme(
    axis.text.x = element_blank(),
    panel.grid.major = element_blank(),
    panel.grid.minor = element_blank(),
    plot.title = element_text(hjust = 0.5, size = 18),
    legend.position = "right",
    legend.title = element_text(size = 14),
    legend.text = element_text(size = 12)
  )

print(p)
#+end_src

#+RESULTS: pie-stories-chart
[[file:sprint_backlog_13_stories_pie_sorted.png]]

#+name: stories-chart
#+begin_src R :var sprint_summary=sprint_summary :colnames yes :results file graphics :exports results :file sprint_backlog_13_stories.png :width 1200 :height 650
library(conflicted)
library(grid)
library(tidyverse)
library(tibble)

# Filter to only rows with actual story data (non-empty Tags column)
clean_sprint_summary <- sprint_summary %>% dplyr::filter(Tags != "")
names <- unlist(clean_sprint_summary[2])
values <- as.numeric(unlist(clean_sprint_summary[6]))

# Create a data frame.
df <- data.frame(
  cost = values,
  stories = factor(names, levels = names[order(values, decreasing = FALSE)]),
  y = seq(length(names)) * 0.9
)

# Setup the colors
blue <- "#076fa2"

p <- ggplot(df) +
  aes(x = cost, y = stories) +
  geom_col(fill = blue, width = 0.6) +
  ggtitle("Sprint 13: Resourcing per Story") +
  xlab("Resourcing (%)") + ylab("Stories") +
  theme(text = element_text(size = 15))

print(p)
#+end_src

#+RESULTS: stories-chart
[[file:sprint_backlog_13_stories.png]]

#+name: tags-chart
#+begin_src R :var sprint_summary=sprint_summary :colnames yes :results file graphics :exports results :file sprint_backlog_13_tags.png :width 600 :height 400
library(conflicted)
library(grid)
library(tidyverse)
library(tibble)

clean_sprint_summary <- sprint_summary %>% dplyr::filter(Tags != "")
names <- unlist(clean_sprint_summary[1])
values <- as.numeric(unlist(clean_sprint_summary[6]))

df <- data.frame(
  cost = values,
  tags = names,
  y = seq(length(names)) * 0.9
)

df2 <- setNames(aggregate(df$cost, by = list(df$tags), FUN = sum), c("cost", "tags"))

blue <- "#076fa2"

p <- ggplot(df2) +
  aes(x = cost, y = tags) +
  geom_col(fill = blue, width = 0.6) +
  ggtitle("Sprint 13: Resourcing per Tag") +
  xlab("Resourcing (%)") + ylab("Story types") +
  theme(text = element_text(size = 15))

print(p)
#+end_src

#+RESULTS: tags-chart
[[file:sprint_backlog_13_tags.png]]

*** COMPLETED Generate release notes for previous sprint              :infra:
    :LOGBOOK:
    CLOCK: [2026-02-20 Fri 16:36]--[2026-02-20 Fri 16:37] =>  0:01
    CLOCK: [2026-02-20 Fri 16:22]--[2026-02-20 Fri 16:36] =>  0:14
    CLOCK: [2026-02-20 Fri 16:14]--[2026-02-20 Fri 16:21] =>  0:07
    CLOCK: [2026-02-20 Fri 15:19]--[2026-02-20 Fri 16:13] =>  0:54
    :END:

We now have so much text that we are bursting the prompt window. We need to
first feed the sprint backlog to summarise it and then use the summarised output
to generate the release notes. The process is a bit more time consuming now.

*** COMPLETED Merge FSM into DQ                                        :code:
    :LOGBOOK:
    CLOCK: [2026-02-20 Fri 17:27]--[2026-02-20 Fri 17:42] =>  0:15
    CLOCK: [2026-02-20 Fri 16:38]--[2026-02-20 Fri 16:57] =>  0:19
    :END:

We considered first adding FSM as a stand alone component, but in reality it is
part of the DQ framework. DQ is becoming a meta-data framework for all aspects
related to ensuring the data quality in the system. We will probably also put
four eyes into DQ.

#+begin_quote
This pull request refactors the Finite State Machine (FSM) component by
integrating it directly into the Data Quality (DQ) layer. This consolidation is
driven by the understanding that state machines serve as critical metadata
infrastructure for managing data quality. The changes involve a comprehensive
renaming of SQL objects and file paths to align FSM with its new home within DQ,
ensuring a more logical and maintainable architecture.

Highlights:

- FSM Component Consolidation: The Finite State Machine (FSM) component has been
  fully integrated into the Data Quality (DQ) layer, recognizing state machines
  as core metadata infrastructure for data quality.
- SQL Identifier Renaming: All SQL identifiers previously prefixed with
  ores_fsm_* have been systematically renamed to ores_dq_fsm_* to reflect their
  new organizational structure within the DQ component.
- File Relocation: All FSM-related SQL schema, trigger, RLS policy, and
  population scripts have been moved from their original fsm/ subdirectories
  into the dq/ subdirectories.
- Notification Channel Updates: PostgreSQL pg_notify channels for FSM entities
  (machines, states, transitions) have been updated to use the new ores_dq_fsm_
  prefix.
- Entity String Renaming: Internal entity strings used for FSM components have
  been updated from ores.fsm.* to ores.dq.fsm.*.
#+end_quote

*** COMPLETED Make all details dialogs tabbed                          :code:
    :LOGBOOK:
    CLOCK: [2026-02-20 Fri 22:48]--[2026-02-20 Fri 23:48] =>  1:00
    CLOCK: [2026-02-20 Fri 22:10]--[2026-02-20 Fri 22:24] =>  0:14
    CLOCK: [2026-02-20 Fri 17:43]--[2026-02-20 Fri 18:55] =>  1:12
    :END:

At present we have very long dialogs for details. Make all of them tabbed.


#+begin_quote
This pull request introduces significant UI enhancements and refactoring across
various detail dialogs and user-specific windows. The primary goal is to
standardize the layout of detail dialogs by adopting a tabbed interface,
centralizing provenance information into a dedicated 'Provenance' tab, and
improving the overall user experience through better organization and visual
cues. It also modernizes user account and session management by converting them
to MDI subwindows, aligning with a more integrated application feel.

Highlights:

- Country Detail Dialog: Moved the flag display from a separate tab into the
  General tab as a group box, resulting in a dialog with two tabs: General and
  Provenance.
- Currency Detail Dialog: Relocated the icon button from a floating position
  between the toolbar and tabs into the General tab within an Icon group box.
- Main Window Menus: Added a top-level '&Trading' menu between Data and System,
  moving the 'Trades' action into it and adding 'Trades' to the toolbar.
- Data Governance Submenu: Introduced a '&Dimensions' submenu within 'Data
  Governance', containing 'Origin', 'Nature', and 'Treatment Dimension' actions.
- Change Commentary Field Removal: Removed the editable 'Change Commentary'
  field from the General tab in eight specific detail dialogs (Methodology,
  TreatmentDimension, DataDomain, CodingSchemeAuthorityType, CodingScheme,
  SubjectArea, Catalog, Dataset), while retaining a read-only version in the
  Provenance tab.
- Methodology Detail Dialog: Enlarged the 'Implementation' text area by
  increasing its minimum height from 100 to 300.
- My Sessions Window: Converted 'My Sessions' from a floating QDialog to an MDI
  subwindow, allowing re-triggering to bring it to the front.
- My Account Window: Converted 'My Account' from a modal QDialog to a QWidget
  MDI subwindow, featuring a toolbar with a 'Save Email' action and three tabs:
  General (account info), Security (change password), and Sessions (session
  count + 'View History' button). The 'View History' button now emits a signal
  to open 'My Sessions' in the main window.
- Entity Detail Dialog: Implemented a 32x24 country flag label next to the
  'Business Centre' combo box, which updates dynamically upon selection changes
  via the image cache.
#+end_quote

*** COMPLETED Provenance: Fix performed by and modified by stamping    :code:
    :LOGBOOK:
    CLOCK: [2026-02-21 Sat 21:01]--[2026-02-21 Sat 22:15] =>  1:14
    CLOCK: [2026-02-21 Sat 18:30]--[2026-02-21 Sat 19:00] =>  0:30
    CLOCK: [2026-02-21 Sat 11:28]--[2026-02-21 Sat 13:01] =>  1:33
    :END:

#+begin_quote
This pull request enhances the system's provenance tracking and account
validation mechanisms. It ensures that actions performed within the database,
particularly during tenant provisioning and asset assignments, accurately record
the initiating user rather than generic system accounts. By refining account
validation logic and optimizing the database initialization sequence, the
changes improve data integrity and auditability.

Highlights:

- Account Validation: Removed an escape hatch from
  ores_iam_validate_account_username_fn that previously allowed any DB session
  user to bypass accounts-table validation by matching current_user.
- Database Population Order: Reordered foundation_populate.sql to ensure IAM
  service accounts are populated before Data Quality Framework and Reference
  Data sections, allowing validate_account_username_fn to find service accounts
  when triggers fire.
- Provenance Tracking: Introduced ores_iam_current_actor_fn() to read the
  app.current_actor GUC and used this resolved actor (falling back to
  current_user) in all inserts within ores_iam_provision_tenant_fn to correctly
  record modified_by/performed_by.
- Assigned By Validation: Replaced silent current_user defaults for assigned_by
  in ores_assets_image_tags_insert_fn and ores_iam_account_roles_insert_fn with
  calls to ores_iam_validate_account_username_fn() for proper bootstrap-aware
  validation.
#+end_quote

*** COMPLETED Add plotting of session data                             :code:
    :LOGBOOK:
    CLOCK: [2026-02-22 Sun 02:01]--[2026-02-22 Sun 03:20] =>  1:19
    :END:

#+begin_quote
This pull request significantly enhances the client's ability to monitor and
visualize network session data, while improving the server's data collection and
persistence mechanisms. It introduces real-time RTT sampling, ensures accurate
byte counter reporting, and provides a new API and UI components for displaying
historical session performance metrics. The changes also include robust database
schema and documentation for handling time-series data efficiently.

Highlights:

- Session Byte Counters Fixed: The bytes_sent and bytes_received counters are
  now synchronized from the live connection before logout, resolving an issue
  where 'My Sessions' displayed '0 B'.
- RTT Sampling and Persistence: Client pings now carry the previous heartbeat
  RTT (latency_ms). The server records session_sample data (bytes + latency) at
  each heartbeat tick and persists these batches to the
  ores_iam_session_samples_tbl TimescaleDB hypertable upon logout.
- New Protocol for Session Samples: A new protocol pair,
  get_session_samples_request (0x2072) and get_session_samples_response
  (0x2073), has been introduced to allow clients to fetch ordered time-series
  session samples, with server-side authorization checks.
- Enhanced Connection Tooltip: The status-bar plug icon now provides a dynamic
  tooltip displaying live server address, bytes sent/received, and RTT when
  connected, or a 'Disconnected for N s' message during reconnection attempts.
- Interactive Session Chart: Selecting a session in 'My Sessions' now fetches
  and plots bytes_sent and bytes_received over time using a new
  QChartView/QLineSeries panel, requiring the qt6-charts vcpkg dependency.
- TimescaleDB Documentation: The SQL skill documentation has been updated with a
  dedicated section on TimescaleDB time-series tables, covering hypertables,
  chunk intervals, compression, retention, and a canonical example.
#+end_quote

*** COMPLETED Add account-party management and login support           :code:
    :LOGBOOK:
    CLOCK: [2026-02-23 Mon 21:10]--[2026-02-23 Mon 23:41] =>  2:31
    CLOCK: [2026-02-23 Mon 09:15]--[2026-02-23 Mon 12:17] =>  3:02
    CLOCK: [2026-02-22 Sun 20:00]--[2026-02-23 Mon 00:50] =>  4:50
    CLOCK: [2026-02-22 Sun 11:10]--[2026-02-22 Sun 13:40] =>  2:30
    CLOCK: [2026-02-22 Sun 07:20]--[2026-02-22 Sun 08:10] =>  0:50
    :END:

#+begin_quote
This pull request introduces comprehensive multi-party support across the
system, enabling greater flexibility in how user accounts are associated with
organizational entities. It refines the authentication process to incorporate
party selection, provides administrative tools for managing these associations,
and updates the underlying communication protocols and database schema to
support the new functionality. The changes aim to enhance user management and
data isolation capabilities.

Highlights:

- Multi-Party Login Flow: Implemented a multi-party login mechanism where user
  accounts can be linked to multiple organizational parties. The server now
  returns a list of available parties, allowing the client to present a picker
  for selection, or auto-selecting if only one party is assigned. This includes
  new wire protocol messages (select_party_request, select_party_response) and
  extensions to the login_response to carry party information.
- Account-Party Management UI and API: Added a new 'Parties' tab to the
  AccountDetailDialog in the Qt client, featuring an AccountPartiesWidget. This
  widget allows administrators to add or remove party assignments for an account
  via new server-side API handlers (get_account_parties_by_account,
  save_account_party, delete_account_party).
- Protocol Version Bump: The messaging protocol major version was incremented
  from 37 to 38 due to breaking changes in the login_response wire format,
  accommodating the new party selection fields.
- System Party Auto-Assignment: Modified the bootstrap process to automatically
  assign the system party to the initial admin account, ensuring successful
  login for newly provisioned tenants. A new PostgreSQL function,
  ores_iam_account_parties_system_party_id_fn(), was introduced to look up the
  system party ID.
- Documentation Updates: New documentation (multi_party.org) was added detailing
  the multi-party login flow, account-party rules, and wire protocol changes.
  Existing documentation was updated to reference this new content.
#+end_quote

*** COMPLETED Add rounding type entity                                 :code:
    :LOGBOOK:
    CLOCK: [2026-02-23 Mon 16:20]--[2026-02-23 Mon 18:00] =>  1:40
    :END:

#+begin_quote
This pull request introduces a new rounding_type entity, integrating it fully
across the application's data, service, and user interface layers. The primary
goal is to provide a robust and user-friendly mechanism for defining and
managing various financial rounding methods, which can then be referenced by
other entities like currencies. This enhancement improves data consistency and
user experience by offering a structured way to handle rounding configurations,
along with a more organized main menu for data management.

Highlights:

- New Entity: Rounding Type: Introduced a new rounding_type domain entity,
  complete with its JSON model definition, repository, messaging protocol, and
  service layer declarations for full CRUD (Create, Read, Update, Delete) and
  history operations.
- Full Qt Stack for Rounding Types: Implemented a comprehensive Qt user
  interface for managing rounding types, including a ClientRoundingTypeModel for
  data display, RoundingTypeMdiWindow for listing, RoundingTypeDetailDialog for
  viewing/editing, and RoundingTypeHistoryDialog for version tracking.
- Currency Detail Dialog Enhancement: Replaced the free-text roundingTypeEdit
  field in CurrencyDetailDialog with a roundingTypeCombo QComboBox. This combo
  box is populated asynchronously from the server, sorted by display order, and
  provides tooltips from the description field.
- Navigation Restructure: Restructured the main application's 'Data' menu. Core
  entities like Currencies and Countries are now top-level, while auxiliary
  types, including the new Rounding Types, are consolidated under a new
  'Auxiliary Data' submenu for better organization.
- Integration with Currency Workflow: Added 'Rounding Types' toolbar buttons to
  both the CurrencyDetailDialog and CurrencyMdiWindow, providing quick access to
  the rounding types management interface and wiring the CurrencyController to
  relay requests to the new RoundingTypeController.
- SQL Data Enrichment: Enriched the descriptions of existing rounding types in
  the SQL population script with 2-decimal place numeric examples for 'Up',
  'Down', 'Closest', 'Floor', and 'Ceiling' methods.
#+end_quote

*** COMPLETED Polish business centre UI and data quality               :code:
    :LOGBOOK:
    CLOCK: [2026-02-22 Sun 01:02]--[2026-02-22 Sun 02:00] =>  0:58
    :END:

Several data quality and UI issues with business centres.

- WRLD should have UN flag and source = Internal.
- Hard-code NY* centres (NYFD, NYSE, USNY) during population to US country.
- Add a city name field parsed from descriptions (regex for parenthesised text).
- Do not display description column by default.
- Country should be a combo box.
- Fix missing country flags.
- Do not display coding scheme column by default.
- Move country column next to code.
- Reduce recorded_at column width.

#+begin_quote
This pull request focuses on enhancing the data quality and user interface for
business centres. It introduces a new 'city_name' field, derived from existing
descriptions, and integrates it across the database, C++ domain models, and the
Qt UI. Additionally, it includes specific data fixes for certain business centre
codes and refines the display of business centre information in the UI.

Highlights:

- SQL Data Enhancements: Added a 'city_name' column to the business centres
  reference data table and implemented logic to automatically derive city names
  from existing descriptions during data population.
- Data Quality Fixes: Hard-coded the country for specific business centre codes
  (NYFD, NYSE) to 'US' and ensured the correct US flag is displayed in the FpML
  artefact. The 'WRLD' system business centre was also updated with
  'source=Internal' and assigned a UN flag.
- C++ Model Updates: Incorporated the new 'city_name' field into the
  'business_centre' domain struct, its entity representation, mapper, and the
  binary messaging protocol, leading to a major protocol version bump to v38.0.
- Qt UI Improvements: Reordered columns in the business centre list view to
  prioritize 'Code', 'Country', and 'City', added a dedicated 'City' column, and
  set 'Description' and 'Coding Scheme' to be hidden by default. The 'Recorded
  At' column width was fixed, and the country selection combo box in the detail
  dialog was made non-editable, while also displaying the derived city name.
#+end_quote
*** COMPLETED Enhance currency taxonomy                                :code:
    :LOGBOOK:
    CLOCK: [2026-02-24 Tue 00:35]--[2026-02-24 Tue 02:08] =>  1:33
    CLOCK: [2026-02-24 Tue 00:01]--[2026-02-24 Tue 00:34] =>  0:33
    :END:

This pull request significantly enhances the currency classification system by
moving from a monolithic free-text field to a more structured and governed
approach. The change introduces distinct categories for a currency's asset class
and its market tier, allowing for better data integrity, extensibility, and
auditability. This refactoring impacts all layers of the application, from the
database schema and domain models to the messaging protocols and user
interfaces, providing a robust foundation for future currency management.

Highlights:

- Currency Taxonomy Restructuring: Replaced the single 'currency_type' free-text
  field with two structured lookup fields: 'asset_class' (fiat, crypto,
  commodity, synthetic, supranational) and 'market_tier' (g10, emerging, exotic,
  frontier, historical) to provide a more granular and accurate classification
  of currencies.
- New Reference Data Entities: Introduced two new reference-data entities,
  'currency_asset_class' and 'currency_market_tier', complete with full stack
  coverage including SQL tables, domain types, repositories, services, messaging
  (CRUD + history), Qt UI, Wt UI, and CLI support.
- Protocol Version Update: Updated the binary protocol to version 41.0, which is
  a breaking change due to the replacement of the 'currency_type' wire field
  with the new 'asset_class' and 'market_tier' fields, and the addition of new
  message types for the new lookup entities.
- Comprehensive Codebase Updates: Addressed and fixed all build failures across
  test files, wire-format comments, and application code that previously
  referenced the now-removed 'currency_type' field, ensuring full integration of
  the new taxonomy.

*** COMPLETED Books, portfolios and trades are not party specific      :code:
    :LOGBOOK:
    CLOCK: [2026-02-24 Tue 09:01]--[2026-02-24 Tue 12:00] =>  2:59
    :END:

At present I can see these entities from any party in a tenant.

#+begin_quote
This pull request introduces party isolation for key entities like books,
portfolios, and trades, enhancing data security and access control. It also
improves the user interface by adding party context and parent portfolio
selection features, while centralizing flag icon handling for better code
maintainability and consistency.

Highlights:

- Party Isolation: Enforced party isolation for books, portfolios, and trades
  using strict RLS policies, ensuring data visibility is limited to the
  appropriate party context.
- Session Management: Enhanced session data to include party context, enabling
  party-level RLS enforcement via update_session_party() and
  make_request_context().
- UI Updates: Improved UI by displaying party name in the portfolio detail
  dialog, pre-populating party_id in create mode, and adding parent portfolio
  selectors to both portfolio and book detail dialogs.
- Flag Icon Handling: Centralized flag icon setup in FlagIconHelper, replacing
  scattered per-dialog lambdas with a more maintainable and consistent approach.
#+end_quote

*** COMPLETED Minor improvements to connection browser                 :code:
    :LOGBOOK:
    CLOCK: [2026-02-24 Tue 15:20]--[2026-02-24 Tue 16:37] =>  1:17
    :END:

Quality of life improvements to connection browser so that we don't have to
spend so much time entering data manually.

#+begin_quote
This pull request introduces a significant refactoring of how server
environments and connections are managed, separating host/port configurations
from credential storage. It enhances the user interface with a unified
connection browser, new duplication capabilities, and an improved login
experience. The underlying database schema has been updated to support these
changes, including an automatic migration process for existing data.

Highlights:

- Environment and Connection Separation: Refactored the server_environment type
  into two distinct domain types: environment (host + port, no credentials) and
  connection (credentials, optionally linked to an environment). When a
  connection is linked to an environment, its host/port are resolved live from
  the environment.
- SQLite Database Migration: Introduced new SQLite tables for environments,
  connections, and connection_tags. Existing server_environments data is
  automatically migrated to the new connections table on the first launch,
  ensuring backward compatibility.
- Unified Connection Browser Tree: The connection browser now displays folders,
  environments, and connections in a single, unified tree structure with
  distinct icons. Drag-and-drop functionality between folders has been improved
  to correctly restore expansion states.
- Duplicate Action: Added a new 'Duplicate' action accessible via the toolbar
  and context menus. This allows users to create a copy of any selected node
  (folder, environment, or connection), appending ' (copy)' to its name.
- Inherited Tags and Detail Panel Enhancements: Connections linked to an
  environment now display the environment's tags as outlined badges in the
  detail panel, distinguishing them from the connection's own filled badges. The
  detail panel also shows resolved host/port for environment-linked connections
  in a grayed, italic style with a tooltip indicating the source environment.
- Login Dialog Quick-Connect Combo: The login dialog's separate environment
  combo and saved-connections button have been replaced with a single, unified
  quick-connect combo box. This combo categorizes entries with 'Manual',
  'Environments', and 'Connections' headers. Selecting an environment pre-fills
  and locks host/port fields, while selecting a connection pre-fills all four
  login fields.
- New Icons: New 'Keyboard' (for manual entry) and 'Copy' (for duplication)
  icons have been added to the icon system, with Fluent UI and Solarized
  variants.
#+end_quote

*** COMPLETED Add concept of "named environments" to connection manager :code:

*Rationale*: implemented as part of improvements to connection browser.

It would be nice if we could do "local2! instead of "localhost@51004". For this
we need to have the notion of "named environments". This could be another entry
in the connection manager. Maybe a separate tree widget.

Users could then choose an environment and it would automatically populate host
and port. These would also show up in drop down box. If using an environment,
title bar would show that as well as host and port.

*** COMPLETED Rename currency asset classes                            :code:
    :LOGBOOK:
    CLOCK: [2026-02-24 Tue 20:18]--[2026-02-24 Tue 21:23] =>  1:05
    :END:

We should avoid the term "asset classes" unless it is used in the usual asset
class context. Many of the values are not really what one things of asset
classes.

*** COMPLETED Remove toolbars from detail dialogs                      :code:
    :LOGBOOK:
    CLOCK: [2026-02-25 Wed 14:03]--[2026-02-25 Wed 15:03] =>  1:00
    CLOCK: [2026-02-25 Wed 11:05]--[2026-02-25 Wed 13:05] =>  2:00
    CLOCK: [2026-02-24 Tue 22:24]--[2026-02-25 Wed 01:21] =>  2:57
    :END:

At present we have toolbars in detail dialogs. These should just have buttons.
Actions: delete, cancel, save.

*** COMPLETED Add portfolio explorer                                   :code:
    :LOGBOOK:
    CLOCK: [2026-02-25 Wed 15:04]--[2026-02-25 Wed 15:45] =>  0:41
    CLOCK: [2026-02-24 Tue 22:22]--[2026-02-24 Tue 22:55] =>  0:33
    CLOCK: [2026-02-24 Tue 18:37]--[2026-02-24 Tue 19:55] =>  1:18
    CLOCK: [2026-02-24 Tue 18:10]--[2026-02-24 Tue 18:36] =>  0:26
    CLOCK: [2026-02-24 Tue 16:38]--[2026-02-24 Tue 18:36] =>  1:58
    CLOCK: [2026-02-21 Sat 13:01]--[2026-02-21 Sat 13:24] =>  0:23
    :END:

Add a combined =PortfolioBookTreeMdiWindow= that replaces the separate
flat-list views for portfolios and books with a unified hierarchical tree
scoped to the active session party. Clicking a node in the tree filters the
trade table on the right to show only trades within that branch.

Depends on: "Extend login flow with party selection" (party must be bound to
session before the tree can scope correctly).

#+begin_quote
This pull request delivers a significant new feature: the Portfolio Explorer.
This interactive MDI window provides a hierarchical view of portfolios and
books, allowing users to intuitively navigate their financial structures. By
integrating dynamic trade filtering, persistent UI settings, and real-time data
updates, it greatly enhances the user's ability to monitor and analyze trades
within specific segments of their portfolio. The changes also include necessary
backend modifications to support this advanced filtering and UI state
management.

Highlights:

- New Portfolio Explorer Widget: Introduced a new MDI window that displays a
  full portfolio/book hierarchy for the session party on the left, with a
  filtered trade table on the right. This allows users to navigate their
  portfolio structure and view associated trades.
- Dynamic Trade Filtering and Navigation: Implemented dynamic trade filtering
  where selecting any node in the portfolio/book tree scopes the trade table to
  that specific subtree. A breadcrumb bar provides clickable navigation for the
  current path.
- Trade Count Aggregation: Added functionality to fetch and display trade counts
  per-book, with these counts aggregating up through portfolio and party nodes
  in the tree view.
- UI Persistence and Stale Indicators: Ensured window size, splitter position,
  and trade table column states are persisted across sessions. A stale indicator
  pulses on book, portfolio, or trade change notifications, alerting users to
  updated data.
- Enhanced Trade Protocol and Backend Filtering: Updated the trade protocol
  (PROTOCOL_VERSION_MAJOR bumped to 43) to support optional book_id and
  portfolio_id filters in trade requests, enabling server-side filtering for the
  new widget. Corresponding repository and service methods were added to handle
  this filtering, including recursive CTEs for portfolio subtrees.
- Generic UI Component Improvement: Extended
  EntityListMdiWindow::initializeTableSettings() to accept an optional
  QSplitter* parameter, allowing splitter state to be saved and restored
  alongside window size and column headers for any MDI window using this base
  class.
- New Eventing for Books and Portfolios: Added book_changed_event and
  portfolio_changed_event to the eventing system, allowing the UI to react to
  real-time changes in these entities.
#+end_quote

**** Acceptance Criteria

- A single MDI window contains a horizontal splitter: tree on the left, trade
  table on the right.
- The tree renders the full portfolio hierarchy for the session party, with
  books as leaves under their parent portfolios.
- Node icons are visually distinct:
  - Real portfolio: =briefcase_20_filled=
  - Virtual portfolio (=is_virtual=1=): =briefcase_20_regular=
  - Trading book (=is_trading_book=1=): =book_open_20_filled=
  - Banking/Risk book (=is_trading_book=0=): =book_open_20_regular=
- Selecting any node filters the trade table to trades within that subtree.
- A breadcrumb label above the trade table shows the selected path.
- The reload button acquires a stale/pulsing indicator when a portfolio, book,
  or trade change notification arrives.
- Pagination widget present on the trade table (server-side).

**** Wireframes

***** Main layout

#+begin_example
â”Œâ”€ Portfolio Book Tree â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ [â†» Reload] â”‚ [+ Portfolio] [+ Book] [âœŽ Edit] [ðŸ—‘ Delete] [â± History]         â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ Party: (bound from session â€” read-only)                                        â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                              â”‚  Trades â€º Rates â€º IR â€º Rates_EUR_01            â”‚
â”‚ â–¼ â–£ Rates                    â”‚ â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”â”‚
â”‚   â–¼ â–£ Rates IR               â”‚ â”‚ Ext ID    â”‚ Type     â”‚ Cpty â”‚ Date â”‚ Matures â”‚â”‚
â”‚     â”œâ”€ â—‰ Rates_EUR_01 â—     â”‚ â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤â”‚
â”‚     â””â”€ â—‰ Rates_USD_01        â”‚ â”‚ UTI-0001  â”‚ IRS      â”‚ DBAG â”‚01-25 â”‚ 01-30   â”‚â”‚
â”‚   â–¼ â–£ Rates FX               â”‚ â”‚ UTI-0002  â”‚ FxFwd    â”‚ HSBC â”‚03-25 â”‚ 09-25   â”‚â”‚
â”‚     â””â”€ â—‹ FX_EUR_Vol_01       â”‚ â”‚ UTI-0003  â”‚ CapFloor â”‚ DBAG â”‚11-24 â”‚ 11-27   â”‚â”‚
â”‚                              â”‚ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜â”‚
â”‚ â–¼ â–¡ Regulatory [virtual]     â”‚  [â†] Page 1 of 3 [â†’]  Load All (12)            â”‚
â”‚   â–¼ â–¡ Rates Reg [virtual]    â”‚                                                  â”‚
â”‚     â”œâ”€ â—‰ Rates_EUR_01        â”‚                                                  â”‚
â”‚     â””â”€ â—‰ Rates_USD_01        â”‚                                                  â”‚
â”‚                              â”‚                                                  â”‚
â”‚ â–¼ â–£ Equities                 â”‚                                                  â”‚
â”‚   â””â”€ â—‹ Equities_EU_01        â”‚                                                  â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ 12 trades â€¢ Rates_EUR_01 (Trading Book)                                        â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
#+end_example

***** Icon legend

#+begin_example
  â–£  briefcase_20_filled     Real portfolio (non-virtual)
  â–¡  briefcase_20_regular    Virtual portfolio (is_virtual = 1)
  â—‰  book_open_20_filled     Trading book (is_trading_book = 1)
  â—‹  book_open_20_regular    Banking/Risk book (is_trading_book = 0)
  â—  stale indicator on selected node (pending reload)
#+end_example

***** Breadcrumb scope behaviour

#+begin_example
Click: â–£ Rates              â†’ Trades â€º Rates           (all trades in branch)
Click: â–£ Rates IR           â†’ Trades â€º Rates â€º IR      (subtree trades)
Click: â—‰ Rates_EUR_01       â†’ Trades â€º Rates â€º IR â€º Rates_EUR_01  (book trades)
Click: â–¡ Regulatory         â†’ Trades â€º Regulatory      (same trades, virtual view)
#+end_example

Virtual portfolios surface the same underlying trades as their real counterparts;
they are reporting overlays, not separate trade containers.

***** Proposed Qt component structure

#+begin_example
PortfolioBookTreeMdiWindow
â”œâ”€â”€ QToolBar
â”œâ”€â”€ QSplitter (horizontal)
â”‚   â”œâ”€â”€ QTreeView  â† PortfolioBookTreeModel (QAbstractItemModel)
â”‚   â”‚                 items: PortfolioTreeNode / BookTreeNode
â”‚   â””â”€â”€ QWidget (right panel)
â”‚       â”œâ”€â”€ Breadcrumb QLabel
â”‚       â”œâ”€â”€ QTableView â† ClientFilteredTradeModel
â”‚       â””â”€â”€ PaginationWidget
â””â”€â”€ Status QLabel
#+end_example

*** COMPLETED Analyse ORE trade import mapping requirements            :code:
    :LOGBOOK:
    CLOCK: [2026-02-25 Wed 19:02]--[2026-02-25 Wed 20:10] =>  1:08
    :END:

ORE portfolio XML files contain trades with string-based references for
counterparties (=CounterParty=), netting sets (=NettingSetId=), and portfolio
labels (=PortfolioIds=). ORES uses UUID foreign keys for books, counterparties,
and portfolios. ORE has no concept of books at all.

We need to analyse the mapping requirements and design an approach for resolving
these references during import. Key questions:

- How should users map ORE =CounterParty= strings to ORES counterparty UUIDs?
  Options: auto-create counterparties, present a mapping dialog, or use a
  configuration file.
- How should users assign an ORES book to imported trades? ORE has no book
  concept, so this must be user-provided.
- Should ORE =PortfolioIds= be mapped to ORES portfolios, or ignored?
- Should we support batch import configurations that can be saved and reused?

Acceptance criteria:

- Document the mapping requirements and chosen approach.
- Create a design for the mapping dialog or configuration mechanism.
- Identify all fields that need external resolution vs. direct mapping.

*** COMPLETED Add scheduler binary protocol                            :code:
    :LOGBOOK:
    CLOCK: [2026-02-26 Thu 11:00]--[2026-02-26 Thu 14:00] =>  3:00
    :END:

Add binary protocol support for the =ores.scheduler= subsystem, enabling clients
to manage pg_cron jobs via the existing comms layer.

Key design decisions:

- Scheduler subsystem assigned message type range =0x9000â€“0x9FFF=
  (SCHEDULER_SUBSYSTEM_MIN/MAX constants added to protocol.hpp).
- Protocol version bumped to =45.0= (breaking change).
- Four request/response pairs implemented:
  - =get_job_definitions_request/response= (0x9000/0x9001): list all jobs
  - =schedule_job_request/response= (0x9002/0x9003): create and activate a job
  - =unschedule_job_request/response= (0x9004/0x9005): deactivate a job
  - =get_job_history_request/response= (0x9006/0x9007): execution history
- Handler registered in =ores.comms.service/app/application.cpp= via the
  existing registrar pattern (same as trading subsystem).
- Custom =rfl::Reflector= specialisations for =cron_expression= and =job_status=
  placed in =ores.scheduler/include/ores.scheduler/rfl/reflectors.hpp= to avoid
  circular dependency with =ores.utility=.

***** Tasks

- [X] Step 1: Add message types (0x9000â€“0x9007) to =message_type.hpp=
- [X] Step 2: Add SCHEDULER_SUBSYSTEM_MIN/MAX + version 45.0 to =protocol.hpp=
- [X] Step 3: Create =scheduler_protocol.hpp= + =scheduler_protocol.cpp=
- [X] Step 4: Create =scheduler_message_handler.hpp= + =scheduler_message_handler.cpp=
- [X] Step 5: Create =registrar.hpp= + =registrar.cpp=
- [X] Step 6: Wire into =ores.comms.service= (CMakeLists + application.cpp)
- [X] Step 7: Verify: =ores.scheduler.lib= builds, 51 tests pass

***** Notes

Story is BLOCKED pending PR review and testing.

Pull Request: (pending)
Branch: =feature/scheduler-binary-protocol=

*** COMPLETED Add scheduling support                                   :code:
    :LOGBOOK:
    CLOCK: [2026-02-27 Fri 09:30]--[2026-02-27 Fri 10:12] =>  0:42
    CLOCK: [2026-02-26 Thu 22:10]--[2026-02-27 Fri 01:17] =>  3:07
    CLOCK: [2026-02-26 Thu 14:10]--[2026-02-26 Thu 15:50] =>  1:40
    CLOCK: [2026-02-25 Wed 20:11]--[2026-02-25 Wed 21:30] =>  1:19
    :END:

Build a library called =ores.scheduler= that wraps the PostgreSQL =pg_cron=
extension.

1. Overview

- Use a Quartz.NET-style fluent API. Strictly distinguish between job_definition
  (the record in cron.job) and job_instance (the execution record in
  cron.job_run_details).
- Create a job_definition class with properties: =job_id=, =job_name=, =command=,
  and schedule_expression.
- Create a job_instance struct for telemetry: =instance_id=, =status=, and
  =return_message=.
- Implement a =job_definition_builder= using the fluent pattern.
- Implement a =cron_scheduler= class that uses sqlgen to execute the
  =cron.schedule= and =cron.unschedule= functions.
- Include a method =get_job_history(job_id)= that returns a vector of
  =job_instance=.

2. The Core Concept

The library, ores.scheduler, is a fluent C++ wrapper for PostgreSQL's pg_cron
extension. It follows the Quartz.NET pattern but persists all state in the
database.

- =job_definition=: The persistent "Plan" (stored in cron.job).
- =job_instance=: The historical "Execution" (stored in cron.job_run_details).
- =cron_scheduler=: The coordinator that translates C++ calls into SQL.

3. The Domain Model (Key Classes)

=job_definition=: This class represents the identity and command of a task.

Fields:

- =job_id=: The internal Postgres ID (assigned after scheduling).
- =job_name=: A unique user-provided string.
- =command=: The raw SQL to execute.
- =schedule_expression=: The cron string (e.g., 0 0 * * *).
- =database_name=: Which DB to run the command against.

=job_instance=: This is a read-only record of a specific trigger event.

- =instance_id=: Unique run ID.
- =parent_job_id=: Link to the job_definition.
- =status=: Enum (starting, finished, failed).
- =return_message=: The stdout or error message from Postgres.
- =start_time / end_time=: Timestamps of the execution.

=job_definition_builder=: The fluent interface to create definitions.

- =with_name(string)=
- =with_command(string)=
- =with_cron_schedule(string)=

4. The Lifecycle Story

Phase 1: Registration

The user uses the job_definition_builder to create a job_definition object. They
pass this to the cron_scheduler. The scheduler executes:

: SELECT cron.schedule('job_name', 'schedule_expression', 'command');

Phase 2: The Trigger (Database Side)

At the scheduled time, the pg_cron background worker wakes up. It ignores the
C++ app entirely. It creates a new job_instance in the database, runs the SQL
command, and updates the job_instance with the result (success or failure).

Phase 3: Observation (C++ Side)

The C++ app can "re-sync" by asking the cron_scheduler for updates.

- =get_all_definitions()=: Returns a list of job_definition objects currently in
  the DB.
- =get_recent_instances(job_id)=: Queries the history table to return a list of
  job_instance objects.

Merged stories:

*Add pg_cron extension for scheduling*

We should install pg_cron extension:

#+begin_quote
pg_cron is a simple cron-based job scheduler for PostgreSQL (10 or higher) that
runs inside the database as an extension.
#+end_quote

Links:

- [[https://github.com/citusdata/pg_cron][GH: pg_cron]]

*Add scheduling support*

Build a library called =ores.scheduler= that wraps the PostgreSQL =pg_cron=
extension using a Quartz.NET-style fluent API. Strictly distinguishes between
=job_definition= (the record in =cron.job=) and =job_instance= (the execution
record in =cron.job_run_details=).

Key design decisions from analysis:

- =croncpp= (already in vcpkg ports) used for a strongly-typed =cron_expression=
  wrapper class with C++23 =std::expected= error handling.
- =std::chrono::system_clock::time_point= for all timestamps.
- =utility::uuid::tenant_id= (from =ores.utility=, no IAM dependency) for tenant
  isolation; =boost::uuids::uuid= for party_id.
- Own table =ores_scheduler_job_definitions_tbl= (hand-crafted SQL, not codegen,
  because =cron_job_id bigint= and =is_active integer= don't fit standard domain
  entity templates) linked to pg_cron via =cron_job_id= (bigint FK to =cron.job.jobid=).
- Job instances read directly from =cron.job_run_details= via raw SQL join â€”
  no mirror table needed for Phase 1.
- =description= and =is_active= columns included now for the future UI PR.
- Phase 2 (separate PR): binary protocol messages for schedule/list/history.
- =cron_expression= bridges pg_cron's 5-field Unix format and croncpp's
  6-field format transparently; users always see standard cron strings.

***** Tasks

- [X] Step 1: SQL setup â€” pg_cron extension + table + RLS policies
- [X] Step 2: C++ library scaffold â€” directory, CMakeLists, umbrella header
- [X] Step 3: Domain types â€” =cron_expression=, =job_status=, =job_definition=, =job_instance=
- [X] Step 4: Builder â€” =job_definition_builder= fluent API
- [X] Step 5: Repository â€” =job_definition_repository= (reads/writes our table)
- [X] Step 6: Service â€” =cron_scheduler= (wraps pg_cron calls + uses repository)
- [X] Step 7: Generators â€” =generate_synthetic_job_definition=
- [X] Step 8: Tests â€” domain/builder unit tests (10 test cases, 51 assertions)
- [X] Step 9: Wire into build â€” CMakeLists, vcpkg.json, register in projects/

*** COMPLETED Add a message queue                                      :code:
    :LOGBOOK:
    CLOCK: [2026-02-27 Fri 16:02]--[2026-02-27 Fri 18:00] =>  1:58
    CLOCK: [2026-02-27 Fri 10:28]--[2026-02-27 Fri 13:00] =>  2:32
    :END:

We need basic infrastructure for queuing.

*** COMPLETED Add batch support for saves and deletes                  :code:
    :LOGBOOK:
    CLOCK: [2026-02-28 Sat 16:00]--[2026-02-28 Sat 20:04] =>  4:04
    CLOCK: [2026-02-27 Fri 22:02]--[2026-02-27 Fri 23:30] =>  1:28
    :END:

#+begin_quote
This pull request significantly enhances the efficiency and consistency of data
manipulation operations across various services by implementing atomic batch
processing for both saving and deleting entities. This refactoring simplifies
the API for handling multiple entities, ensuring that operations are treated as
a single unit of work, and provides clearer, consolidated feedback to the
client.

Highlights:

- Atomic Batch Operations: Refactored all messaging protocols to use atomic
  batch save/delete semantics, ensuring that multiple entities are processed
  within a single database transaction.
- Request/Response Structure Update: save_*_request messages now accept a
  std::vector<entity>, and save_*_response messages return a single {bool
  success, std::string message} outcome. Similarly, delete_*_request messages
  accept batch input via std::vector, and delete_*_response messages return a
  single atomic outcome.
- Protocol Version Increment: The communication protocol version has been
  updated to 46.0 to reflect these breaking changes in the wire format for save
  operations.
- Client-Side Adaptations: All relevant Qt client-side callers across ores.qt
  have been updated to align with the new protocol field names and access
  patterns.
- New save_result.hpp: Introduced a new header file defining a generic
  save_result struct and helper functions for handling batch operation outcomes.
#+end_quote

#+begin_quote
This pull request significantly enhances data integrity and performance for
batch delete operations across multiple core services. Previously, batch deletes
were non-atomic, leading to potential partial data removal if an error occurred
mid-process. The changes introduce atomic batch deletion by leveraging SQL's
WHERE IN clause, ensuring that either all items in a batch are deleted or none
are. This refactoring also includes the removal of dead code, streamlining the
codebase.

Highlights:

- Batch Delete Atomicity: Implemented atomic batch delete operations across 23
  entities in four modules (ores.dq, ores.refdata, ores.trading, ores.iam) by
  replacing individual delete calls within loops with a single DELETE FROM table
  WHERE col IN (...) SQL query.
- Code Cleanup: Removed the unused save_result.hpp header file and all its
  includes from various protocol headers and message handler implementation
  files, reducing build dependencies and improving code hygiene.
- Architectural Pattern: Introduced a consistent 3-layer pattern for batch
  deletes: adding remove(const std::vector<std::string>& codes) overloads in
  repositories, plural remove_X methods in services, and updating message
  handlers to utilize these new atomic service calls.
- Temporal Guard Handling: Addressed special cases for IAM module entities
  (tenant_type, tenant_status) by incorporating a temporal guard ("valid_to"_c
  == max.value()) into their batch delete queries to ensure historical data
  integrity.
#+end_quote

*** STARTED Add party level currency and country restrictions          :code:
    :LOGBOOK:
    CLOCK: [2026-02-24 Tue 19:31]--[2026-02-24 Tue 20:17] =>  0:46
    :END:

At present a party can use all currencies and all countries. In reality we
normally want to restrict this at the party level. We won't be able to do a full
implementation of this right now but it is a good idea to put in the framework
so that we start to get a feel for how to work with RLS.

#+begin_quote
This pull request significantly enhances the reference data management system by
introducing party-specific visibility for currencies and countries. It
establishes a robust framework for granular control over which reference data
elements are accessible to different parties, addressing a limitation where all
such data was previously tenant-wide. The changes span the entire application
stack, from database schema and generated C++ code to service-level filtering,
ensuring a comprehensive and well-integrated solution.

Highlights:

- New Party-Visibility Junction Tables: Introduced
  ores_refdata_party_currencies_tbl and ores_refdata_party_countries_tbl to
  control which currencies and countries are visible to specific parties, moving
  from tenant-wide visibility to per-party control.
- Full Stack Codegen: Generated the complete domain, repository, service, and
  test layers for both new entities using codegen models, ensuring consistency
  and reducing manual effort.
- Service Integration: Integrated filtering logic into existing currency_service
  and country_service to leverage the new junction tables, adding
  list_currencies_for_party and list_countries_for_party methods.
- Bitemporal Support: Implemented bitemporal functionality for the new junction
  tables, including valid_from and valid_to columns, versioning, and soft-delete
  rules.
#+end_quote

*** STARTED Add trade import mapping dialog to Qt UI                   :code:
    :LOGBOOK:
    CLOCK: [2026-02-26 Thu 01:18]--[2026-02-26 Thu 01:46] =>  0:28
    CLOCK: [2026-02-26 Thu 17:30]--[2026-02-26 Thu 20:00] =>  2:30
    CLOCK: [2026-02-26 Thu 10:40]--[2026-02-26 Thu 13:10] =>  2:30
    CLOCK: [2026-02-26 Thu 10:00]--[2026-02-26 Thu 10:39] =>  0:39
    :END:

Add a mapping dialog to the Qt UI for importing ORE portfolio XML files. The
dialog should allow users to:

1. Select an ORE portfolio XML file.
2. Preview the trades that will be imported (count, types, counterparties).
3. Select the ORES book to import trades into.
4. Map ORE =CounterParty= names to ORES counterparties (or auto-create).
5. Review and confirm the import.

This dialog should be accessible from the book list window toolbar when a book
is selected (similar to the currency import button on the currency list window).

Files to modify:

- =BookMdiWindow.hpp/cpp= - add import toolbar action
- New =ImportTradeDialog.hpp/cpp= - the mapping and preview dialog
- =BookController.hpp/cpp= - wire up the import action

Acceptance criteria:

- Import button is visible and enabled when a book is selected.
- Dialog shows trade preview with counterparty mapping.
- Successful import creates trades in the selected book.
- Trades appear in the trade list after import.

*** Analyse caching at dialog level                                    :code:

We seem to have a lot of caches lying around at the dialog level. It makes more
sense to have a common core (i.e. non-Qt specific) data-structure that caches
different types of data which is shared by the different dialogs. This would
also be reused by different clients such as Wt, shell, etc.

Instead of locking we should use immutable data structures. We should also take
into account notifications coming in for data changes. It should enable you to
notify all clients, load the data in the background in a way that does not
affect dialogs.

We could create workspace component which has all of the data needed, stored
using immer containers:

- it can have a comms aspect, so that the UI does not need to worry about any of
  that. You just request say currencies page N, workspace then deals with that.
  It can just give you the current version. If none, it will load via comms. It
  also knows about subscriptions so it will tell you about pending subscriptions
  for a collection you are interested in. As you load more pages, we load these
  into immer containers ordered by page.
- once we implement workspaces, we should then make all references to foreign
  keys "clickable". For example, if you are in a business centre and it has a
  country we should be able to click on it and open the country. At present we
  can't do this because the data is kept at the main dialog level.
- ideally we want a way to cache data in Qt format. We don't need to save this
  data to the local database. However, we don't want to make the
  =ores.workspace= library depend on Qt. Maybe we just need some kind of
  "extensions" on each frontend (e.g. Wt etc), sort of a qt.workspace which
  contains the original workspace plus any Qt specific representations. Or maybe
  use composition.
- we should add a UI to visualise the workspace, or at least be able to see size
  usage etc. Baobab style map.

Notes:

- actually this is not "workspace", its ores.caching.
- caching seems more like a component-level phenomena rather than having a
  dedicated component in the entire product. A component like ores.caching would
  have to depend on every component anyways, and it would not provide a lot of
  valuable services. Makes more sense to have a =ores.refdata/caching= and so
  on, with possibly a front-end service which deals with cache misses/hits and
  can persist data locally into say SQLite. It could also handle the look up
  data locally first, then do a remote get etc. All of this is transparent from
  a client perspective. We could also have a feature flag to enable/disable
  caching (in memory, local storage, etc).

Analysis with Gemini:

#+begin_src markdown
## User Story: Implement a High-Performance Reactive Caching Service for Reference Data

- **As a** system architect,
- **I want** a centralized Reference Data Service that manages data via a
  multi-tiered caching strategy (L1 Memory, L2 Disk) and incremental updates,
- **So that** my application can access large volumes of lookup data with
  near-zero latency, maintain thread safety without lock contention, and
  minimize network overhead.

---

### Acceptance Criteria

#### 1. Multi-Tiered "Smart" Loading Logic

- **Cold Start:** On initialization, the service must check the **L2 (SQLite)**
  cache for an existing "Page" snapshot.
- **As-Of Load:** If no L2 cache exists, the service must perform a full "As-Of"
  load from the remote connection for a specific timestamp.
- **Since (Delta) Load:** If an L2 snapshot exists, the service must only
  request "Since" updates (changes/deltas) from the remote connection based on
  the last known timestamp in the L2 store.
- **L2 Persistence:** All data fetched via "As-Of" or "Since" must be mapped
  back to its data representation and persisted to **SQLite** to facilitate
  future warm starts.

#### 2. Immutable L1 Cache (immer)

- **Thread Safety:** The L1 (in-memory) cache must use **immer** persistent data
  structures (`immer::map`) to provide lock-free read access for concurrent
  threads.
- **Structural Sharing:** Updates to the cache via "Since" loads must use
  immerâ€™s **transient/persistent** pattern to update only changed entities while
  sharing memory for unchanged data.
- **Atomic Swaps:** The service must provide an atomic mechanism to swap the
  "current" version of the page, ensuring readers always see a consistent
  snapshot.

#### 3. Reactive Subscription & Staleness

- **Notifications:** The service must subscribe to data change notifications.
- **Stale State Management:** Upon receiving a notification, the service must
  mark the relevant collection as stale and trigger an automated "Since" load to
  synchronize the L1 and L2 tiers.

#### 4. Data Mapping

- **Bi-Directional Mapping:** The service must utilize mappers to translate
  between raw data representations (for SQLite storage) and domain entities (for
  L1 memory storage).

---

### Technical Notes

- **L1:** `immer::map<std::string, std::shared_ptr<const Entity>>`.
- **L2:** SQLite table indexed by `page_id` and `timestamp` storing serialized
  blobs.
- **Performance Goal:** Reading from L1 should require no mutex locking, relying
  on the immutability of the underlying immer structure.
#+end_src

Links:

- [[https://github.com/arximboldi/immer][GH: immer]]: "immer is a library of persistent and immutable data structures
  written in C++. These enable whole new kinds of architectures for interactive
  and concurrent programs of striking simplicity, correctness, and performance."
- [[https://learn.microsoft.com/en-us/aspnet/core/performance/caching/memory?view=aspnetcore-10.0][Cache in-memory in ASP.NET Core]]: get ideas for the caching interfaces and
  requirements.

Merged stories:

*Add workspace as a container*

Core needs to have a container for all of the data stored within a context.

Actually, according to Data Priented Principles, we may not need it. This may be
a UI concept but not a code concept.

*** Notify clients of database connection errors                       :code:

If the server fails to connect to the database, we should show a dialog box or
some other UI to explain this to the user. Elsewhere we have:

#+begin_quote
Erro de LigaÃ§Ã£o Ã  Base de Dados

Problema de ConfiguraÃ§Ã£o: NÃ£o foi possÃ­vel estabelecer ligaÃ§Ã£o Ã  base de dados.
Por favor contacte o administrador do sistema imediatamente para resolver este
problema.
#+end_quote

We need something similar. Big and red so user sees it.

*** Create named profiles                                              :code:

Users should be able to move windows around the screen and get them in the right
positions and shapes (including detached windows etc) and then save them to the
database as a named profile. Then, after login:

- if there is only one named profile against the user, just load it.
- if there is more than one, give the user a selector.

Note that the profile may be created against a specific party. Needs some
thinking.

*** Portfolio types                                                    :code:

At present a portfolio can be virtual or not. We should really generalise this
into a portfolio type.

*** Check change reasons on delete                                     :code:

Seems like we do not have change reasons on entity deletes. We need to update
all entities.

*** Add missing history dialogs                                        :code:

We have an inventory of missing features across entities. Check to see if it
covers history as well.

*** ORE Importer: portfolio and trade support                          :code:

Now that we have the basics for trades, books and portfolios, we can do a very
basic ORE importer:

- point it to the samples directory;
- for each folder, if it has subfolders, create a portfolio. If it contains the
  trades file, make it a book.
- add each trade in the trade file.

Notes:

- users should be able to choose top-level portfolio to import it into.
  counterparty,
  -
- users sho

*** No samples in sessions                                             :code:

For some reason we are no longer sampling for sessions. Investigate why.

*** Add virtual portfolio tree support                                 :code:

A virtual portfolio is a reporting overlay that aggregates trades from real
portfolios and books without owning them directly. Because a book has a single
=parent_portfolio_id=, virtual portfolio membership requires a separate junction
table. This story adds the full stack for virtual portfolios:

**** Acceptance Criteria

- New junction table =ores_refdata_virtual_portfolio_books= mapping virtual
  portfolios to books, with the full SQL machinery (triggers, RLS, notify).
- Domain type, repository, service, and protocol messages for the junction.
- Virtual portfolios (=is_virtual = 1=) are shown in the
  =PortfolioBookTreeMdiWindow= as a separate tree section below the real tree,
  using =briefcase_20_regular= icons.
- Selecting a virtual portfolio node or any of its book leaves filters the trade
  table using the junction membership list.
- Stale indicator responds to changes on the virtual portfolio membership.

*** Rename currency asset classes                                      :code:

We should avoid the term "asset classes" unless it is used in the usual asset
class context. Many of the values are not really what one things of asset
classes.

*** Single tenant setup creates tenant                                 :code:

In single tenant scenario we should just use the system tenant.

*** Error with new tenant                                              :code:

When trying to setup a new tenant, with an already existing tenant we get:

#+begin_quote
Publishing catalogue 'Crypto'...
ERROR: Query execution failed: ERROR:  Atomic bundle publication failed at dataset assets.crypto_icons: duplicate key value violates unique constraint "ores_assets_images_tbl_pkey"
CONTEXT:  PL/pgSQL function ores_dq_bundles_publish_fn(text,uuid,text,text,boolean,jsonb) line 239 at RAISE
#+end_quote

Logs:

#+begin_src logview
2026-02-23 23:55:42.970715 [DEBUG] [ores.dq.service.publication_service] publication_service initialized
2026-02-23 23:55:42.970747 [INFO] [ores.dq.service.publication_service] Publishing bundle: crypto with mode: upsert, atomic: true, published_by: tenant_admin, params_json: (empty)
2026-02-23 23:55:42.970813 [DEBUG] [ores.dq.service.publication_service] Publishing bundle crypto. SQL: SELECT * FROM ores_dq_bundles_publish_fn('crypto', 'c5d8e5f6-7e67-4c18-94ba-55e8829a9d57'::uuid, 'upsert', 'tenant_admin', true, '{}'::jsonb)
2026-02-23 23:55:42.986027 [DEBUG] [ores.dq.service.publication_service] Set tenant context to: c5d8e5f6-7e67-4c18-94ba-55e8829a9d57
2026-02-23 23:55:43.030557 [ERROR] [ores.dq.service.publication_service] Query failed: ERROR:  Atomic bundle publication failed at dataset assets.crypto_icons: duplicate key value violates unique constraint "ores_assets_images_tbl_pkey"
CONTEXT:  PL/pgSQL function ores_dq_bundles_publish_fn(text,uuid,text,text,boolean,jsonb) line 239 at RAISE
2026-02-23 23:55:43.070217 [ERROR] [ores.dq.service.publication_service] Bundle publication failed: Query execution failed: ERROR:  Atomic bundle publication failed at dataset assets.crypto_icons: duplicate key value violates unique constraint "ores_assets_images_tbl_pkey"
#+end_src

*** Add sub-menus for shell                                            :code:

We did the plan for this work.

Notes:

- log full version including timestamp.
- add info command which is the same as CLI.
- move paging commands into a paging menu, e.g. =page next= instead of =next=?

*** Problems with session charts                                       :code:

- session duration is not updating even on refresh.
- no sample data even after 10 mins.
- sessions do not seem to take tenant into account.

*** Add auxiliary types to their entities                              :code:

The toolbars of each entity should have icons for the auxiliary types they use.
Also we may need to make the menu options a bit more obvious (e.g. "Purpose
Types"?).

*** Improvements to detail  dialogs                                    :code:

For most dialogs, pressing escape should be the same as closing it.

We should also add a "cancel" button to dialogs, makes it a bit more "normal".

New dialogs use toolbars instead of buttons at the bottom.

*** Alert for unsaved modified entities                                :code:

If a user changes an entity but does not save it, we should alert the user.
Also, we probably should add a cancel button to all detail dialogs.

*** Add high-watermark support                                         :code:

Whenever we request entities, we should also return the watermark for that
entity. This is the highest timestamp of all entities within a set (across all
pages). This is so we can redo the exact same query with an "as of" and get
exactly the same result set. Do some analysis with Claude on how best to do
this. Maybe we should always query as of so that we know what the watermark is
up front.

Notes:

- once we have watermark, we need to add a staleness indicator to all dialogs.
  This will require thresholds. If the data is older than X the staleness
  indicator goes yellow, older than Y it goes red.

*** Redesign Qt ImageCache invalidation strategy                       :code:

Note: this story should only be looked at after we move towards workspaces.

The current ImageCache invalidation approach is brittle and error-prone. When
datasets are published, the cache reload is triggered by pattern-matching
dataset codes (e.g., checking for "flag", "icon", "currenc", "countr" in the
code string). This is fragile because:

- New dataset types require updating the pattern matching logic
- The relationship between datasets and cached data is implicit
- Cache invalidation relies on string matching rather than proper metadata

Proposed improvements:

- Use artefact_type metadata instead of code string matching to determine if
  cache invalidation is needed
- Consider a more general cache invalidation framework that can be extended to
  other caches (ChangeReasonCache, etc.)
- Investigate using server-side notifications to trigger cache invalidation
  (similar to the notification system already in place)
- Document the caching strategy and invalidation rules

Acceptance criteria:

- Cache invalidation is based on structured metadata, not string patterns
- Adding new image-related datasets doesn't require code changes
- Cache invalidation logic is documented and maintainable

*** Replace parent combo boxes with server-side type-ahead search      :code:

The entity detail dialogs (party, counterparty) load all entities into a combo
box for parent selection using a single request with =offset=0, limit=1000=.
If the system has more than 1,000 entities, the dropdown silently truncates
results, meaning users cannot select the correct parent and the hierarchy tree
is incomplete. The same pattern exists for country image maps and lookup
fetchers.

The fix is to replace the plain =QComboBox= with a searchable type-ahead widget
backed by =QCompleter= that issues server-side search requests as the user
types. This is the scalable solution and avoids loading the full dataset into
memory.

Affected locations:

- =CounterpartyDetailOperations.cpp:117= - =load_all_entities()=
- =PartyDetailOperations.cpp:118= - =load_all_entities()=
- =EntityDetailDialog.cpp:346= - =loadCountryImageMap()=
- =LookupFetcher.cpp:80,145= - lookup reference data loading

Note: the =MdiWindow= list views already have proper server-side pagination
via =ClientCounterpartyModel= / =ClientPartyModel=; this issue only affects
detail dialog combo boxes and related data loading.

- Introduce a reusable =SearchableEntityComboBox= widget with =QCompleter=
- Add server-side search endpoints for parties and counterparties
- Replace =load_all_entities()= calls with on-demand search
- Consider the same approach for country and lookup fetcher if volumes warrant it

*** Filter counterparty dataset size for evaluation tenants            :code:

Evaluation tenants currently import too many counterparties from GLEIF data. Add
options to limit the dataset to a configurable percentage or count, providing
enough data to evaluate the system without overwhelming the tenant.

*** Improve tenant deletion safety and cascading                       :code:

Tenant deletion needs proper safeguards and cascading behaviour.

- Deleting any tenant should show an impact summary before proceeding.
- Deleting a tenant should trigger cascading deletion of associated parties.
- Deleting the root tenant should return an error (prevent accidental deletion).

*** Allow super admin to reset tenant admin accounts                   :code:

The super admin currently cannot reset a tenant admin account's password or
credentials. Add this capability to the account management UI.

*** Add tenant type management dialog                                  :code:

There is currently no UI to view or manage tenant types. Add a dialog accessible
from the administration menu to list, view, and edit tenant type reference data.

*** Add account permissions visibility and tabbed dialog               :code:

Users have no way to see what permissions an account has. The accounts dialog
also needs a tabbed layout to display all available information.

- Add a permissions tab showing effective permissions for the account.
- Use tabbed dialog layout (General, Permissions, Sessions, etc.).
- Clicking on a user should show profile details: admin sees full details, others
  see only key fields (email, etc.).

*** Add shell commands for parties and counterparties                  :code:

The shell currently has no commands for party or counterparty CRUD. Add list,
add, history, and delete commands following the existing shell entity pattern.

Related story: "Add sub-menus to shell".

*** Suppress staging dataset publication warnings                      :code:

Staging datasets (e.g. =gleif.lei_entities.small=, =gleif.lei_relationships.small=)
show confusing "No populate_function for artefact_type" warnings during bundle
publication. These datasets are dependencies that load into staging tables and
don't publish to production directly â€” this is working as designed. Suppress or
reclassify these log messages to avoid confusion.

*** Allow creating new connections from login dialog                   :code:

The login dialog should have a button or link to create a new server connection,
so users don't have to navigate to the connections dialog separately.

*** Add validation and ISO compliance flags for reference data         :code:

Several validation gaps and missing metadata in reference data entities.

- It is possible to create a country without a name; likely a currency too. Add
  required field validation.
- Fictional countries should have X prefixes (following ISO 3166 conventions).
- Add an "is ISO compliant" flag (or similar) for currencies and countries that
  are part of the ISO standard vs. custom/internal entries.

*** Standardise Qt window behaviour and UI consistency                 :code:

Several inconsistencies in window behaviour across the application.

- Remove maximise button from MDI child windows.
- Standardise window type: main entity windows should behave the same as
  history/detail dialogs (consistent minimise/maximise button behaviour).
- Generate button should only appear in "new" mode, not "edit".
- Add save button to currency list (needed for generation workflow).
- Add configuration option to disable quit confirmation dialog.
- Allow password visibility toggle in password input fields.

*** Improve session management and server-side housekeeping            :code:

Session tracking and lifecycle management needs improvement.

- Session should record whether telemetry is enabled or not.
- Send and receive byte counters are empty in sessions display.
- Server should periodically housekeep sessions: mark disconnected sessions as
  orphan, mark sessions as finished when connection drops.

*** Clicking on connection in status bar should provide info           :code:

Or maybe as a tooltip? whatever is idiomatic. Things to show:

- when never connected: nothing.
- when connected: server, bytes sent, received, status of connection.
- when disconnected: retries, disconnected since.

*** Reduce duplicated Qt code and clean up technical debt              :code:

Several areas of duplicated code and legacy artefacts that should be cleaned up.

- Qt network error message processing is duplicated across dialogs; extract into
  shared utility.
- Merge common functionality between entities in =ores.qt=.
- Raw SQL in image repository should be replaced with a database function.
- Remove legacy password salt field from accounts.
- Add =ores.analyser= to system model documentation.
- Bootstrap mode flag change does not generate a new version; fix versioning.

*** Expand repository test coverage and infrastructure                 :code:

Test coverage gaps and infrastructure improvements needed.

- No repository tests for change reason entity. Audit all entities for coverage.
- No generators for roles and permissions; add them.
- Test suites should log version at startup. Info script needs to grep log for
  version across all suites.

*** Add version comparison and revert improvements                     :code:

Improvements to entity version history and comparison features.

- In the history diff dialog, add a "from version" combo box that lets users
  compare against any previous version (not just the immediately preceding one).
- Revert-to-version should be a server-side operation taking current version and
  target version parameters.

*** Raise events for account profile updates                           :code:

Updating email from "My Account" does not raise an event. Account profile
changes should emit events through the event bus for consistency with other
entity modifications.

*** Add batch editing with staging workflow                        :analysis:

Investigate a workflow where users can "locally modify" multiple entities and
then save the batch in a single operation. Similar to git's staging concept. Need
to determine appropriate terminology and iconography for this feature. Consider:
what do we call the staged state? What icon represents "stage for save"?

*** Evaluate change reasons for role permission tables             :analysis:

Should role and permission junction tables have change reason support? Analyse
whether the audit trail benefit justifies the additional complexity for these
administrative tables.

*** Add HBAC support for books and portfolios                          :code:

Gemini:

#+begin_quote
In a professional trading system, you are describing Hierarchical Role-Based
Access Control (HRBAC). To make this idiomatic and scalable, you need to
decouple the "Who" (Users/Groups) from the "What" (Portfolios/Books) using an
Access Control List (ACL) that supports Inheritance.

Here is how to structure this to avoid the nightmare of manual user management.

1. The Domain Model: Groups and Roles

Instead of assigning a user directly to a book, you introduce a User Group
(e.g., "North America FX Traders").

- User Group: A collection of Users.
- Role: A collection of Permissions (e.g., View, Trade, Close_Book).
- Access Grant: The link that says Group A has Role X on Portfolio Y.

2. Permission Inheritance (The "Cascading" Rule)

This is the most critical part of your requirement: "Permissioned to a portfolio
= permissioned to all children."

*The Logic*

When a user attempts to access a Book, the system should check for a permission
record at:

- The Book itself.
- If not found, its parent Portfolio.
- If not found, its parent Business Unit, and so on up to the Party.

*The "Effective Permission" Calculation*

In your Qt UI or API, you calculate the Effective Permission.

If I am in the "Senior Managers" group and that group is assigned View access at
the Global Equities Portfolio level, I automatically see every book under it.

- Override Rule: Usually, an explicit "Deny" at a lower level beats an "Allow"
  from a higher level (though most trading systems stick to additive permissions
  for simplicity).

3. Idiomatic Table Structure

To support this in your Postgres schema (with your Staging/Master setup), you
need a permission table that points to your entity hierarchy.

| Column         | Description                                       |
|----------------+---------------------------------------------------|
| Subject_ID     | The ID of the User Group (e.g., "FX_Desk_Group"). |
| Object_Type    | PARTY, PORTFOLIO, or BOOK.                        |
| Object_ID      | The UUID of the specific entity.                  |
| Role_ID        | The Role (e.g., READ_ONLY, FULL_TRADER).          |
| Is_Inheritable | Boolean (usually defaults to True).               |

4. UI Implementation: The "Access" Tab

In your Organization Manager Qt screen, when you select a Portfolio or Book in
the tree, the detail pane should have an "Access Control" tab.

- Inherited Permissions List: A read-only list showing groups that have access
  because of a parent node (e.g., "Group: Risk_Admin (Inherited from: The
  House)").
- Explicit Permissions List: Where you add/remove groups specifically for this
  node.

5. Security and "The House" Context

Since your system runs in the context of "The House" (the Tenant), you need a
"God Role" (System Admin) that is implicitly permissioned at the Party (Root)
level. This ensures you never get locked out of a branch of the tree.

*The "Four-Eyes" for Permissions*

Because permissions are sensitive, changes to this table should also go through
your staging schema.

- Maker: Proposes adding "Group B" to "Portfolio C".
- Checker: Approves the grant.
- Audit: The temporal table tracks exactly when a user gained access to a
  specific bookâ€”crucial for regulatory "Who saw what" inquiries.
#+end_quote

*** Understanding Settlements and SSI                              :analysis:

This is a very complicated topic. We should try to summarise it and see what is
the smallest subset that we need in order to see full trade lifecycle.

Links:

- [[https://www.cslucas.com/user-guide/how-to-set-up-counterparty-ssi/][How to Set Up Counterparty SSI]]
- [[https://docs.oracle.com/cd/E99951_01/html/Settlements/Settlements_Manual_Intro_002.htm][Settlements Service]]

*** Add ISO 20022 Support                                              :code:

As per Gemini:

#+begin_quote
Summary Mapping for your C++ Logic

| Internal Event  | ISO 20022 Message | Action                                          |
|-----------------+-------------------+-------------------------------------------------|
| TradeExecuted   | fxtr.014          | Confirm terms with counterparty.                |
| Send Funds      | pacs.009          | Instruct the  bank to move cash.                |
| Check Progress  | pacs.002          | Update UI "Settlement Status" to 'In Progress'. |
| Funds Confirmed | camt.054          | Update UI to 'Settled'.                         |
| EOD Reconcile   | camt.053          | Verify internal ledger vs bank balance.         |
|                 |                   |                                                 |

Pro-Tip for your Implementation: Since you're using C++, don't try to build
every message at once:

- Start with pacs.009 (Sending money).
- Follow with pacs.002 (Handling the response).
- Add camt.053 (Reconciling at night).

*ISO 20022 Asset Class Mapping*

If you move beyond FX, you switch "prefixes." Here is how the ISO 20022 world is
carved up:

| Message Prefix | Asset Class / Domain  | Example Use Case                                     |
|----------------+-----------------------+------------------------------------------------------|
| fxtr           | Foreign Exchange      | "Spot, Forwards, NDFs, FX Swaps."                    |
| sese           | Securities Settlement | "Settlement of Equities, Bonds, ETNs."               |
| semt           | Securities Management | "Custody statements, holding reports."               |
| setr           | Securities Trade      | Trade capture/subscription for Mutual Funds.         |
| auth           | Regulatory Reporting  | "OTC Derivatives (IRS, CDS), Transaction reporting." |
| pacs           | Payments              | The cash resulting from any of the above.            |

*FPML vs ISO 20022*

For Swaps and other Derivatives, the messaging is split between Trade Reporting
and Lifecycle/Confirmation.

- auth (Authorities): In the modern MX world, Interest Rate Swaps are largely
  reported using the auth series (specifically under EMIR or MiFIR regulations).
  - auth.030: Derived from the "Trade Reporting" business area, used for
    Reporting of OTC derivatives.
- FpML (The "De Facto" standard): As we discussed earlier, while ISO 20022 has
  auth messages for regulation, FpML remains the industry standard for the
  actual bilateral confirmation of IRS trades. Most modern systems use FpML for
  the "contract" and then use pacs for the resulting cash flows.

| Feature         | FpML (Financial products Markup Language)                                   | ISO 20022 (MX)                                                          |
|-----------------+-----------------------------------------------------------------------------+-------------------------------------------------------------------------|
| Primary Domain  | "Derivatives & OTC Trades (Swaps, Options, Forwards)."                      | Payments & Securities Settlement.                                       |
| Focus           | "The economics of the trade (strike price, tenors, floating rate indexes)." | "The movement of value (sender, receiver, amount, intermediary banks)." |
| Lifecycle Stage | "Front-to-Middle Office: Execution, Affirmation, and Confirmation."         | "Back Office: Payment clearing, settlement, and reporting."             |
| Complexity      | Extremely deep. Can describe a 30-year complex interest rate swap.          | Broad. Designed to move money across any border or system.              |
#+end_quote

*** Extend login flow with party selection                             :code:

After authentication, look up the user's associated parties from
=account_parties=. If one party, auto-select. If multiple, return the party list
to the client for selection. The client displays a party picker widget. After
selection, compute the visible party set and bind to the session.

**** Acceptance Criteria

- Login response includes available parties.
- Party picker displayed when user has multiple parties.
- Selected party stored in session and displayed in application window (title
  bar shows =username @ party_name=).
- Party context immutable for session lifetime.

**** Design Notes

***** Protocol changes

Extend =login_response= (0x2006) with two fields appended to the wire format:

- =available_parties=: =vector<{uuid id, string name}>= â€” empty when 0 or 1
  party (auto-selected); populated when â‰¥2 parties.
- =selected_party_id=: =uuid= â€” non-nil only when the server auto-selected
  exactly one party; nil when the client must choose.

Add two new messages:

- =select_party_request= (0x2015): ={uuid party_id}=
- =select_party_response= (0x2016): ={bool success, string error_message}=

***** Server changes (=handle_login_request=)

The party resolution block (lines 488-520 of
=accounts_message_handler.cpp=) currently always auto-selects
=parties.front()=. Change to:

- 0 parties â†’ leave session unbound; no change.
- 1 party â†’ auto-select as now; set =selected_party_id= in response.
- â‰¥2 parties â†’ do NOT bind =party_id= yet; return =available_parties= list;
  leave session unbound until =select_party_request= arrives.

Add =handle_select_party_request=: validate chosen =party_id= is in
account's =account_parties=, bind =session->party_id=, recompute
=visible_party_ids=, update both in-memory session and DB record.

***** Client changes

- =LoginResult= gains =available_parties= and =selected_party_id=.
- =ClientManager= gains =current_party_id_=, =current_party_name_=, and a
  =selectParty(uuid)= method.
- =LoginDialog::onLoginResult= gains a new branch after the password-reset
  check: if =available_parties.size() > 1=, show =PartyPickerDialog= (modal,
  same pattern as =ChangePasswordDialog=). On reject â†’ disconnect, re-enable
  form. On accept â†’ call =clientManager_->selectParty(id)=.
- Main window title set to =username @ party_name= after login completes.

***** Session state machine

#+begin_example
Not connected
  â†’ Connected
  â†’ Authenticated  (party-unbound, only when â‰¥2 parties)
  â†’ Party selected (fully operational)

0 or 1 party: Authenticated â†’ Party selected in one step (no picker shown).
#+end_example

*** Add party role scheme entity                                       :code:

The following is the analysis for adding support to party schemes.

Contains a code representing a related party role. This can be extended to
provide custom roles.

- Obtained on 2025-11-10.
- Version 4-1.
- URL: http://www.fpml.org/coding-scheme/party-role-4-1.xml

Code
Description

- Code: Accountant
- Description: Organization responsible for preparing the accounting for the
  trade.

- Code: Allocation
- Description: Agent The organization responsible for supplying the allocations
  for a trade to be allocated to multiple accounts/organizations.

- Code: Arranging
- Description: Broker The organization that arranged the trade, i.e. brought
  together the counterparties. Synonyms/Alternatives: Inter-dealer broker,
  agent.

- Code: Beneficiary
- Description: Organization that suffers the economic benefit of the trade. The
  beneficiary may be distinct from the principal/counterparty - an example
  occurs when a hedge fund trades via a prime broker; in this case the principal
  is the prime broker, but the beneficiary is the hedge fund. This can be
  represented as a payer/receiver account in the name of the hedge fund, but it
  is also possible to add the party role of "Beneficiary" at the
  partyTradeInformation level.

- Code: Booking
- Description: Party The entity for which the organization supporting the
  trade's processing has booked/recorded the trade. This is used in
  non-reporting workflows situations in which the trade doesn't need to be
  reported but a firm still wants to specify their own side.

- Code: Buyer
- Description: Acquirer of the legal title to the financial instrument. In the
  case of an option, the buyer is the holder of the option. In the case of a
  swap or forward, the buyer will be determined by industry best practice. This
  does not refer to an investor or investment manager or other organization on
  what is typically called the "Buy side"; for that, see the "Client" role.
  Corresponds to "Buyer" as defined in certain regulations such as ESMA MiFID
  II/MIFIR RTS 22 field 9.

- Code: Buyer
- Description: DecisionMaker The party or person who, having legal authority to
  act on behalf of the trade counterparty acting as Buyer as defined in this
  coding scheme, made the decision to acquire the financial instrument.
  Corresponds to "buyer decision maker" as defined in ESMA's MIFIR RTS 23
  report. This does not refer to the decision maker for what is traditionally
  called the "Buy side"; for that, see the "Client Decision Maker" role.

- Code: Clearing
- Description: Client An organization that clears trades through a clearing
  house, via a clearing broker (member of the clearing house) who acts as an
  agent on its behalf. The term "client" refers to the organization's role in
  the clearing process in relation to its clearing broker, and not whether it is
  a price maker or taker in the execution process.

- Code: Clearing
- Description: ExceptionParty A party to the trade that claims a clearing
  exception, such as an end-user exception under Dodd-Frank Act provisions.

- Code: Clearing
- Description: Firm Organization that submits the trade to a clearing house on
  behalf of the principal. Synonyms/alternates: Futures Commission Merchant
  (FCM), Clearing Broker, Clearing Member Firm. Some implementations use
  "Clearing Broker" as synonym.

- Code: Clearing
- Description: Organization The organization that acts as a central counterparty
  to clear a derivatives contract. This is used to represent the role of Central
  Counterparties (CCPs) or Derivative Clearing Organizations (DCOs). Sometimes
  called "ClearingService". Some implementations also use the term "Clearer".

- Code: Client
- Description: Client as defined under ESMA MIFIR. This is generally the
  investor or other client of an investment firm, and is synonymous with the
  Beneficiary in many circumstances.

- Code: Client
- Description: DecisionMaker The party or person who, having legal authority to
  act on behalf of a trade counterparty, made the decision to acquire or sell
  the financial instrument.

- Code: Confirmation
- Description: Platform Organization serving as a financial intermediary for the
  purposes of electronic confirmation or providing services for post-processing
  of transactional data.

- Code: Contractual
- Description: Party A party to a contractual document. If the intended usage
  relates to the context of the trade lifecycle, more specific annotations have
  been defined which might be more appropriate.

- Code: Counterparty
- Description: An economic counterparty to the trade. Synonym: principal.

- Code: Counter
- Description: PartyAffiliate Organization offiially attached to the
  counterparty. e.g. partner, branch, subsidiary.

- Code: Counter
- Description: PartyUltimateParent The topmost entity or organization, within
  the corporate hierarchy, responsible for the reporting party.

- Code: Credit
- Description: SupportProvider Organization that enhances the credit of another
  organization (similar to guarantor, but may not fully guarantee the
  obligation).

- Code: Custodian
- Description: Organization that maintains custody of the asset represented by
  the trade on behalf of the owner/principal.

- Code: Data
- Description: Submitter Entity submitting the transaction report to the
  competent authority.

- Code: Disputing
- Description: Party Organization that is disputing the trade or transaction.

- Code: Document
- Description: Repository A marketplace organization which purpose is to
  maintain document records. If the intended usage relates to the context of the
  trade lifecycle, more specific annotations have been defined which might be
  more appropriate.

- Code: Executing
- Description: Broker The (generally sell-side) organization that executed the
  trade; the price-making party.

- Code: Executing
- Description: Entity Entity executing the transaction. If the transaction is
  executed directly by the reporting party, it will be the reporting party. If
  it is executed by an execution agent or an affiliated party on behalf of the
  reporting party, it will be that affiliate or agent.

- Code: Execution
- Description: Agent The (generally buy-side) organization that acts to execute
  trades on behalf of an investor. Typically this is an investment manager or
  asset manager, and also makes the investment decisions for the investor. If
  required, a separate InvestmentDecision role can be specified to distinguish
  that the party making the investment decision is different.

- Code: Execution
- Description: Facility The facility, exchange, or market where the trade was
  executed. Synonym: Swap Execution Facility, Designated Contract Market,
  Execution Venue.

- Code: Guarantor
- Description: Organization that backs (guarantees) the credit risk of the
  trade.

- Code: Margin
- Description: Affiliate Margin affiliate as defined by U.S. margin and capital
  rules Â§23.151.

- Code: Order
- Description: Transmitter The entity transmitting the order to the reporting
  firm. Synonym: Transmitting Firm.

- Code: Prime
- Description: Broker The organization that takes on or took on the credit risk
  for this trade by stepping in between the two economic parties (without a
  central counterparty clearing mechanism).

- Code: Prior
- Description: TradeRepository The trade repository at which the trade was
  reported previous to the current trade repository.

- Code: PTRR
- Description: CompressionProvider A party providing a post trade risk reduction
  service in the form of compression.

- Code: PTRR
- Description: RebalancingProvider A party providing a post trade risk reduction
  service in the form of portfolio rebalancing.

- Code: Publication
- Description: Venue The reporting service (whether trade repository, market
  data service, or exchange/facility/venue data distribution service) that
  published the report of this trade.

- Code: Reporting
- Description: Party The party with the regulatory responsibility to report this
  trade.

- Code: Reporting
- Description: PartyAffiliate Organization offiially attached to the reporting
  party e.g. partner, branch, subsidiary.

- Code: Reporting
- Description: PartyUltimateParent The topmost entity or organization, within
  the corporate hierarchy, responsible for the reporting party.

- Code: Seller
- Description: A counterparty in a trade, which performs in one of the following
  capacities: 1) it transfers or agrees to transfer in the future an instrument
  or title to that instrument in exchange for payment, 2) it writes a
  derivatives instrument such as an option or a swap in which it provides risk
  protection to the buyer. This does not refer to the broker/dealer or other
  organization on what is typically called the "Sell side"; for that, see the
  "Executing Broker" role. Corresponds to "Seller" as defined in certain
  regulations such as ESMA MiFID II/MIFIR RTS 22 field 16.

- Code: Seller
- Description: DecisionMaker The party or person who, having legal authority to
  act on behalf of the trade counterparty acting as Seller as defined in this
  coding scheme, made the decision to sell the financial instrument. Corresponds
  to "seller decision maker" as defined in ESMA's MIFIR RTS 23 report. This does
  not refer to the decision maker for what is traditionally called the "Sell
  side"; for that, see the "Trader" person role.

- Code: Settlement
- Description: Agent The organization that makes or receives payments on behalf
  of the given principal party.

- Code: Trade
- Description: Repository An organization that maintains records of the trade
  for regulatory reporting purposes.

- Code: Trade
- Description: Source The organization that originally supplied the record of
  the trade. In the context of regulatory reporting, it is the submitter of the
  trade record to a regulator or TR.

- Code: Trading
- Description: Manager The entity responsible for managing the
  assets/investments of this party. Synonnym: Asset Manager, Investment Manager,
  Trading Advisory.

- Code: Trading
- Description: Partner An entity with which this party trades from time to time,
  ie. with which it acts as a counterparty on some transactions. This role is
  used for static reference data, not individual transactions.


*** Accounts need to have a human or robot field                       :code:

Look for correct terminology (actor type?).


*** Add sub-menus to shell                                             :code:

There are a lot of entries in the shell main menu, we need to group them. These
could be based on the component.

Notes:

- shell has no parties or counterparties commands.
- It should be possible to set the "output type" or format in the shell, from
  json to table. Find the correct terminology for this.

*** System provisioner needs an icon                                   :code:

Dialog is using default ORE icon.

*** Add a organisation type scheme entity                              :code:

Indicates a type of organization.

- Obtained on 2016-06-13
- Version 2-0
- URL: http://www.fpml.org/coding-scheme/organization-type-2-0.xml

- Code: MSP
- Name: Major Swap Participant
- Description: A significant participant in the swaps market, for example as
  defined by the Dodd-Frank Act.

- Code: NaturalPerson
- Name: Natural Person
- Description: A human being.

- Code: non-SD/MSP
- Name: Non Swap Dealer or Major Swap Participant
- Description: A firm that is neither a swap dealer nor a major swaps participant under the Dodd-Frank Act.

- Code: SD
- Name: Swap Dealer
- Description: Registered swap dealer.

*** Add currency and country party-visibility junctions                :code:

Add junction tables (=party_currencies=, =party_countries=) that control which
currencies and countries a given party can see and use. The underlying reference
data definitions remain shared at the tenant level; only visibility is
per-party.

**** Acceptance Criteria

- Junction tables created with proper constraints.
- Party-scoped queries for currencies and countries filter through junctions.
- Default: all currencies/countries visible to all parties (opt-in restriction).

*** Update currency details to use tabs                                :code:

We need a main tab with the currency related properties, then a "system" tab
with temporal data which is read-only even on edit and a "image" tab with the
image used to represent the currency. It could also contain some description or
notes.

*** Currencies: Country relationship                                   :code:

At present currencies are linked to flags directly via an image id. We should
also be linked to a country, where such a linkage exists.

*** Currencies: Currency Taxonomy Enrichment                           :code:

- Goal: Enhance the ores_refdata_currencies_tbl to support logical grouping,
  reporting, and basic behavior defaults.
- Requirements:
  - Field 1: asset_class (Enum/Varchar)
    Purpose: Defines the nature of the instrument.
    Allowed Values: fiat, commodity (for XAU/XAG), synthetic, supranational.
  - Field 2: market_tier (Enum/Varchar)
    Purpose: Drives UI priority, liquidity expectations, and risk limits.
    Allowed Values: majors (g10), emerging, exotic, frontier, historical.
- Example Entries:
  : USD | fiat | g10
  :  BRL | fiat | emerging

*** Currencies: Party-Specific Settlement Rules                        :code:

- Goal: Define the "Where." This models what a specific "House" entity (or
  child) is capable of doing.
- Table: =ores_refdata_settlement_capabilities=.
- Logic: Does "London Desk" have a local Vostro account for "BRL"?

| Field Name              | Type       | Description                                                                        |
|-------------------------+------------+------------------------------------------------------------------------------------|
| capability_id           | UUID       | PK                                                                                 |
| party_id                | INT/FK     | Reference to internal parties. This can be "The House" or a specific child entity. |
| currency_code           | CHAR(3)/FK | Reference to =ores_refdata_currencies_tbl=.                                        |
| can_settle_physically   | Boolean    | If true we can settle in this currency.                                            |
| can_cash_settle         | Boolean    | If true, we can settle in cash on another currency.                                |
| default_settlement_mode | ENUM       | physical (Deliverable) or cash_settled (Non-Deliverable/NDF).                      |
| is_active               | BOOL       | To disable capabilities if an account is frozen or closed.                         |

Then, to determine which account to use to settle we need something like
=ores_refdata_party_nostro_accounts=:

| Field          | Description                                             |
|----------------+---------------------------------------------------------|
| party_id       | Which branch of yours owns this account?                |
| currency_code  | The currency of the account.                            |
| agent_bank_id  | The external bank (e.g., HSBC, Citi).                   |
| account_number | The actual IBAN/Account string.                         |
| is_primary     | Boolean to tell the system which one to use by default. |
| purpose        | "ENUM: General, CLS, Intercompany, Custody."            |

This tells us what account to use when settlement comes. We cannot have a
capability without at least one account.

Then, for each currency which can be cash settled, we need to know into which
currencies they can be cash settled. For that we have
=ores_refdata_settlement_cash_options=. This is a Junction Table that defines
the valid "Settlement Pairs." This table answers: "If we are cash-settling
Currency X, what are the allowed 'Destination' currencies for this House
Entity?"

| Schema              | FieldType | Description                                                       |
|---------------------+-----------+-------------------------------------------------------------------|
| capability_id       | FK        | Links to =ores_refdata_settlement_capabilities=.                  |
| settlement_currency | CHAR(3)   | The "Destination" currency (e.g., USD, EUR).                      |
| is_primary          | BOOLEAN   | The default currency the desk prefers to use for NDFs.            |
| fixing_source_id    | FK        | Which index provides the rate to convert X to the Settlement CCY? |

If cash settled is true, we must have a corresponding entry in this table.

**** The "Relative" Logic Requirement:

The system must perform a Hierarchical Lookup: Check for a rule specific to the
Child Party + Currency. If not found, check for a rule for The House +
Currency. If still not found, default to physical for g10 and cash_settled for
exotic.

*** Currencies: Contractual Settlement (The "Agreements" Table)        :code:

- Goal: Define the "How." This is the bridge you mentioned for specific
  counterparties.
- Table: =ores_refdata_settlement_agreements.=
- Logic: "Even though London can settle NDFs, for this specific Hedge Fund, we
  always settle in USD."

Fields:

| Schema                 | Description             |
|------------------------+-------------------------|
| party_id               | Our side.               |
| counterparty_id        | Their side.             |
| currency_code          | The currency.           |
| agreed_settlement_type | NDF, Physical, Net_USD. |
| agreement_ref          | e.g., "ISDA-2023-GS".   |

* Footer

| Previous: [[id:1B387E8C-8EC1-4C2A-A321-1593C35A9A77][Sprint Backlog 12]] |
