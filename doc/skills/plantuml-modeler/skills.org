:PROPERTIES:
:ID: D6D86317-4961-6754-A6DB-9C12B5FAC997
:END:
#+title: PlantUML Modeler Skill
#+author: Marco Craveiro
#+options: title:nil <:nil c:nil todo:nil ^:nil d:nil date:nil author:nil toc:nil
#+startup: inlineimages
#+export_file_name: SKILL
#+export_exclude_tags: noexport

#+begin_export markdown
---
name: plantuml-modeler
description: Guide for creating plantuml class diagrams for ORE Studio components.
license: Complete terms in LICENSE.txt
---
#+end_export

* When to use this skill

When the user requests an updated PlantUML diagram for a specific component
within ORE Studio.

* How to use this skill

1. *Identify the component type* from the request. The component type must exist
   as a project under the folder projects. If it does not, tell the user of the
   error. An example of a component is =ores.utility=.
2. The objective of the PlantUML diagram is to provide a concise summary of the
   main classes and their relationships for a component. It aims to avoid
   clutter and extraneous detail which complicates the picture but does not
   provide valuable information.
3. Follow the rules under Detailed generation instructions to generate the
   diagram.
4. Once you complete the generation, follow the rules under Detailed evaluation
   instructions to evaluate if the diagram is of sufficient quality.

* Detailed generation instructions

The next sections contain a set of detailed instructions that must be followed
when generating PlantUML diagrams for a component.

** Filesystem instructions

These instructions are related to the filesystem aspects of PlantUML diagram
generation.

*** PlantUML File name

Generated diagrams will have the name of the component as the file name and the
extension =.puml=.

*** PlantUML file location

PlantUML diagrams should be written into a directory called =modeling= under the
component we are modeling. For example =ores.utility/modeling=.

*** Input files to process

In order to determine which files to process, follow these rules:

- Most of the required information for modeling should be sourced from the C++
  header files =.hpp= of a given component. However, inspect the Implementation
  files =.cpp= to check for any relationships at the implementation level which
  are of significance for UML modeling.
- Do not follow includes in the header files. Just read each header file within
  a component and model the entities within, unless this file explicitly tells
  you to exclude them.

** PlantUML file layout

These instructions describe the taxonomy of all PlantUML diagrams.

*** Preamble

The preamble is placed at the start of the PlantUML file. The PlantUML file must
have the following preamble:

#+begin_src plantuml
' -*- mode: plantuml; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*-
'
' Copyright (C) 2024 Marco Craveiro <marco.craveiro@gmail.com>
'
' This program is free software; you can redistribute it and/or modify it under
' the terms of the GNU General Public License as published by the Free Software
' Foundation; either version 3 of the License, or (at your option) any later
' version.
'
' This program is distributed in the hope that it will be useful, but WITHOUT
'  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
' FOR A PARTICULAR PURPOSE. See the GNU General Public License for more details.
'
' You should have received a copy of the GNU General Public License along with
' GNU Emacs; see the file COPYING. If not, write to the Free Software
' Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.
@startuml
set namespaceSeparator ::
#+end_src

Update the year to match the current year.

*** Postamble

The postamble is placed at the end of the PlantUML file. The PlantUML file
should have the following postamble:

#+begin_src plantuml
' Local Variables:
' compile-command: "java -Djava.awt.headless=true -DPLANTUML_SECURITY_PROFILE=UNSECURE -DPLANTUML_LIMIT_SIZE=65535 -jar /usr/share/plantuml/plantuml.jar ORESTUDIO_COMPONENT"
' End:
@enduml
#+end_src

Where =ORESTUDIO_COMPONENT= is the name of the component for which the diagram
is being generated, with the extension =.puml=. For example =ores.utility.puml=.

*** Body

Place all of the PlantUML code describing the entities of the component between
the Preamble and Postamble in the body of the diagram.

Follow these instructions to model the entities within the body:

**** Entity selection

Only document entities that belong to the current component. Ignore all other
entities.

**** C++ namespaces

Follow these rules when modeling C++ namespaces:

- Always use nested namespaces in PlantUML rather than inlined namespaces.
- Colouring rules:
  - if a namespace has a name =database=, colour it with #C6F0D8 and add the
    stereotype =orm=.
  - if a namespace does not fall under any of the previous categories, use the
    default colour of #F2F2F2.
- Document each namespace with a UML note before it's definition, except the
  top-level =ores= namespace which is never documented.
- Documentation is obtained from the namespace header file, which is a file
  that has the name of the namespace. Example: =ores.utility.hpp=. If the
  namespace header file does not exist, do not document it.
- Do not create any relationships between entities and namespaces;
  relationships should only be between UML classes.

Example:

#+begin_src plantuml
namespace ores #F2F2F2 {
    note "Contains assorted basic functionality that does not fit elsewhere." as ores_utility_note
    utility --- ores_utility_note
    namespace utility #F2F2F2 {
        note "Generic exception classes" as ores_utility_exception_note
        exception --- ores_utility_exception_note
        namespace exception #F2F2F2 {
            ' namespace contents
        }
    }
}
#+end_src

**** C++ structs and classes

Follow these common rules to both structs and classes:

- Ignore =operator<<=.
- Ignore default values.
- Add a UML note documenting structs and classes after the struct or class. Add
  the top-level comments, followed by the comments for each field to the note.
- Model relationships for structs and classes as follows:
   - Add the relevant relationships after the class.
   - Ignore relationships to types outside the current component.
   - Use the fully qualified entity name in the  relationship. For example, if
     class =generator= has a field of type =domain::account= but
     =domain::account= refers to the type =ores::risk::domain::account=, use
     =ores::risk::domain::account= in the relationship, not =domain::account=.
   - Use the appropriate UML relationship from the PlantUML vocabulary.

Follow these rules when modeling c++ structs:

- Colouring rules:
  - If a struct has the postfix of =_entity= it is in a =database= folder,
    colour it as #99CB99 and add the stereotype =<<database>>=.
  - If a struct has the postfix of =_option= and it is in a =config= folder,
    colour it as #FFC072 and add the stereotype =<<config>>=.
  - If the struct does not fall under any of the previous categories, use the
    default colour of #F7E5FF.
- Model public, private and protected members of the class using the appropriate
  PlantUML syntax for them.
- If a struct has a field called "schema" and/or tablename, do not model it as a
  field. Instead add it to the comment section as follows (replacing "schema
  name" and "table name" with the default value of these fields):

#+begin_src plantuml
ORM Settings:

- Schema: schema name
- Table: table name
#+end_src

Example of a struct:

#+begin_src plantuml
class options #F7E5FF {
    +{field} name std::string
    +{field} kvps std::unordered_map<std::string, std::list<std::string>>
    +{field} config ores::utility::database_configuration
}

note top of options
Stores the options for the system.

Fields:

- name: Name of the option.
- kvps: Key value pairs used in the options.
- config: database configuration used.
end note

options o-u- ores::utility::database_configuration
#+end_src


Follow these rules when modeling c++ classes:

- Colouring rules:
  - If a class has the postfix of =_exception=, colour it as #D6B19F and add
    the stereotype =<<exception>>=.
  - If the class does not fall under any of the previous categories, use the
    default colour of #CECECE.
- Do not add members related to logging.
- Model public, private and protected members of the class using the appropriate
  PlantUML syntax for them.

**** Implementation file analysis for dependencies

For C++ classes (not structs), after modeling based on the header file, read the
corresponding implementation file (.cpp) and check for dependencies that should
be modeled:

1. *What to look for:*
   - Include statements for other classes within the same component
   - Static method calls on utility or service classes
   - Instantiation of helper classes not stored as members

2. *When to model as a dependency:*
   - The dependency is architecturally significant (e.g., a service using a
     security utility)
   - The dependency is not already captured as a composition/aggregation
     relationship
   - The dependency helps understand the class's responsibilities

3. *How to model:*
   - Use a dashed dependency arrow: =class_a ..> class_b : uses=
   - Use fully qualified names for the target class

Example: If =account_service.cpp= uses
=password_manager::create_password_hash()=:

#+begin_src plantuml
account_service ..> ores::accounts::security::password_manager : uses
#+end_src

4. *What to ignore:*
   - Standard library dependencies
   - Dependencies on types outside the current component
   - Logging infrastructure
   - Trivial utility functions

**** C++ enumerations

Follow these rules when modeling C++ enumerations:

- Colour PlantUML enumerations as #F2DAFD

**** C++ stand alone functions

In general we ignore stand alone functions. The exceptions are as follows:

- Generators:
  - If a function is in a folder called =generators= and its name has the prefix
    =_generate= then model it as a UML class with the stereotype of
    =<<generator>>= and the colour of #D89EF1.
  - The class name should be the function name.
  - Add a note below the UML class with the comments of the function.
  - Add a relationship to the class it is generating.

Example: This C++ source code:

#+begin_src c++
/**
 * @brief Generates a synthetic account.
 */
domain::account generate_synthetic_account();
#+end_src

Maps to the following PlantUML:

#+begin_src plantuml
class generate_synthetic_account <<generator>> #D89EF1 {
}

note top of generate_synthetic_account
Generates a synthetic account.
end note

generate_synthetic_account --> ores::accounts::domain::account: generates
#+end_src

* Detailed evaluation instructions

The next sections contain a set of detailed instructions that must be followed
after generating a PlantUML diagram for a component. They determine if the
diagram is of sufficient quality.

** Diagram review

Check the diagram for common mistakes:

- relationships of classes against namespaces. These indicate a mistake on how
  the relationship was captured. Example:

#+begin_src plantuml

#+end_src


** Diagram compilation

In order to validate that the diagram you generated is syntactically correct,
run the appropriate CMake target. At the project level directory, run:

#+begin_src sh
cmake --build --target generate_ores.accounts_diagram --preset linux-clang-debug
#+end_src

Replace =generate_ores.accounts_diagram= with the appropriate component name.

If there are build errors, fix them until the build is green.



* Artefacts                                                        :noexport:

** Licence

#+BEGIN_SRC fundamental :tangle LICENCE.txt
This program is free software; you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation; either version 3 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program; if not, write to the Free Software
Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston,
MA 02110-1301, USA.
#+END_SRC
