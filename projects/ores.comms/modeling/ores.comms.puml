' -*- mode: plantuml; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*-
'
' Copyright (C) 2025 Marco Craveiro <marco.craveiro@gmail.com>
'
' This program is free software; you can redistribute it and/or modify it under
' the terms of the GNU General Public License as published by the Free Software
' Foundation; either version 3 of the License, or (at your option) any later
' version.
'
' This program is distributed in the hope that it will be useful, but WITHOUT
'  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
' FOR A PARTICULAR PURPOSE. See the GNU General Public License for more details.
'
' You should have received a copy of the GNU General Public License along with
' GNU Emacs; see the file COPYING. If not, write to the Free Software
' Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.
@startuml

title ores.comms Component

set namespaceSeparator ::

namespace ores #F2F2F2 {

    note "Communications library providing client-server connectivity for ORE Studio.\n\n Implements a custom binary protocol over SSL/TLS for secure client-server communication." as ores_comms_note
    comms --- ores_comms_note
    namespace comms #F2F2F2 {
        namespace net #F2F2F2 {
            '
            ' Layout groupings for better diagram structure
            '

            ' Group: Server classes
            together {
                class server_options
                class server
                class server_session
            }

            ' Group: Client classes
            together {
                class client_options
                class retry_options
                class connection_state
                class client
            }

            ' Group: Connection infrastructure
            together {
                class connection
                class pending_request_map
                class response_channel
            }

            ' Hidden relationships to stack related classes vertically
            server_options -[hidden]down- server
            server -[hidden]down- server_session
            client_options -[hidden]down- client
            retry_options -[hidden]down- connection_state
            pending_request_map -[hidden]down- response_channel

            '
            ' Class definitions
            '

            class server_options #F7E5FF {
                +{field} port std::uint16_t
                +{field} max_connections std::uint32_t
                +{field} certificate_file std::string
                +{field} private_key_file std::string
                +{field} server_identifier std::string
                +{field} certificate_chain_content std::optional<std::string>
                +{field} private_key_content std::optional<std::string>
                +{field} enable_signal_watching bool
            }

            note top of server_options
            Configuration for the server.

            Fields:

            - port: Server port number.
            - max_connections: Maximum number of concurrent connections.
            - certificate_file: Path to the SSL certificate file.
            - private_key_file: Path to the SSL private key file.
            - server_identifier: Server identifier string sent in handshake.
            - certificate_chain_content: Optional certificate chain content (takes precedence over file).
            - private_key_content: Optional private key content (takes precedence over file).
            - enable_signal_watching: Whether to enable signal watching.
            end note

            class server #ECECEC {
                +server(server_options options, std::shared_ptr<service::subscription_manager> subscription_mgr)
                +register_handler(messaging::message_type_range range, std::shared_ptr<messaging::message_handler> handler) void
                +sessions() std::shared_ptr<service::auth_session_service>
                +run(boost::asio::io_context& io_context, std::function<void(std::uint16_t)> on_listening) boost::asio::awaitable<void>
                +stop() void
                -accept_loop(boost::asio::io_context& io_context, std::function<void(std::uint16_t)> on_listening) boost::asio::awaitable<void>
                -setup_ssl_context() void
                -watch_for_stop_signals(boost::asio::io_context& io_context) boost::asio::awaitable<void>
                -{field} options_ server_options
                -{field} ssl_ctx_ ssl::context
                -{field} sessions_ std::shared_ptr<service::auth_session_service>
                -{field} dispatcher_ std::shared_ptr<messaging::message_dispatcher>
                -{field} subscription_mgr_ std::shared_ptr<service::subscription_manager>
                -{field} active_connections_ std::atomic<std::size_t>
                -{field} stop_signal_ boost::asio::cancellation_signal
                -{field} active_sessions_ std::list<std::shared_ptr<server_session>>
                -{field} sessions_mutex_ std::mutex
            }

            note top of server
            ORES protocol server.

            Accepts SSL connections, performs handshake, and manages client sessions.
            Supports server-push notifications via optional subscription_manager.
            Owns the auth_session_service for centralized authorization.
            end note

            server o-u- ores::comms::net::server_options
            server o-u- ores::comms::messaging::message_dispatcher
            server o-u- ores::comms::net::server_session
            server o-u- ores::comms::service::subscription_manager
            server o-u- ores::comms::service::auth_session_service

        class retry_options #F7E5FF {
            +{field} max_attempts std::uint32_t
            +{field} base_delay std::chrono::milliseconds
            +{field} max_delay std::chrono::milliseconds
            +{field} jitter_factor double
            +{field} auto_reconnect bool
        }

        note top of retry_options
        Configuration for client retry and reconnection behavior.

        Fields:

        - max_attempts: Maximum connection attempts before giving up (0 = no retries).
        - base_delay: Base delay for exponential backoff.
        - max_delay: Maximum delay between retry attempts.
        - jitter_factor: Randomization factor (0.2 = Â±20%) to prevent thundering herd.
        - auto_reconnect: Whether to automatically reconnect after disconnect.
        end note

        enum connection_state #F2DAFD {
            disconnected
            connecting
            connected
            reconnecting
        }

        note top of connection_state
        Connection state for the client.

        - disconnected: Not connected to server.
        - connecting: Initial connection in progress.
        - connected: Connected and ready for requests.
        - reconnecting: Lost connection, attempting to reconnect.
        end note

        class client_options #F7E5FF {
            +{field} host std::string
            +{field} port std::uint16_t
            +{field} client_identifier std::string
            +{field} verify_certificate bool
            +{field} heartbeat_enabled bool
            +{field} heartbeat_interval_seconds std::uint32_t
            +{field} retry retry_options
        }

        note top of client_options
        Configuration for the client.

        Fields:

        - host: Host to connect to.
        - port: Port to connect to.
        - client_identifier: Client identifier to send in handshake.
        - verify_certificate: Whether to verify server certificate.
        - heartbeat_enabled: Enable heartbeat for disconnect detection (default: true).
        - heartbeat_interval_seconds: Heartbeat interval in seconds (default: 30).
        - retry: Retry and reconnection options.
        end note

        client_options o-- ores::comms::net::retry_options

        class client #ECECEC {
            +client(client_options config, std::shared_ptr<eventing::service::event_bus> event_bus)
            +client(client_options config, boost::asio::any_io_executor executor, std::shared_ptr<eventing::service::event_bus> event_bus)
            +~client()
            +connect() boost::asio::awaitable<void>
            +connect_sync() void
            +connect_with_retry() boost::asio::awaitable<void>
            +connect_with_retry_sync() void
            +disconnect() void
            +is_connected() bool
            +get_state() connection_state
            +set_disconnect_callback(disconnect_callback_t callback) void
            +send_request(messaging::frame request_frame) boost::asio::awaitable<std::expected<messaging::frame, messaging::error_code>>
            +send_request_sync(messaging::frame request_frame) std::expected<messaging::frame, messaging::error_code>
            -perform_handshake() boost::asio::awaitable<void>
            -perform_connection() boost::asio::awaitable<void>
            -run_heartbeat() boost::asio::awaitable<void>
            -run_message_loop() boost::asio::awaitable<void>
            -run_reconnect_loop() boost::asio::awaitable<void>
            -calculate_backoff(std::uint32_t attempt) std::chrono::milliseconds
            -write_frame(const messaging::frame& f) boost::asio::awaitable<void>
            -next_correlation_id() std::uint32_t
            -setup_ssl_context() void
            -{field} config_ client_options
            -{field} io_ctx_ std::unique_ptr<boost::asio::io_context>
            -{field} executor_ boost::asio::any_io_executor
            -{field} ssl_ctx_ boost::asio::ssl::context
            -{field} conn_ std::unique_ptr<connection>
            -{field} sequence_number_ std::uint32_t
            -{field} state_ connection_state
            -{field} state_mutex_ std::mutex
            -{field} disconnect_callback_ disconnect_callback_t
            -{field} reconnecting_callback_ reconnecting_callback_t
            -{field} reconnected_callback_ reconnected_callback_t
            -{field} notification_callback_ notification_callback_t
            -{field} event_bus_ std::shared_ptr<eventing::service::event_bus>
            -{field} write_strand_ std::unique_ptr<boost::asio::strand<boost::asio::any_io_executor>>
            -{field} pending_requests_ std::unique_ptr<pending_request_map>
            -{field} correlation_id_counter_ std::atomic<std::uint32_t>
            -{field} message_loop_running_ std::atomic<bool>
            -{field} reconnect_loop_running_ std::atomic<bool>
            -{field} heartbeat_loop_running_ std::atomic<bool>
        }

        note top of client
        ORES protocol client.

        Connects to server via SSL, performs handshake, and manages communication.
        Uses a unified message loop for reading all incoming frames and matching
        responses to pending requests via correlation IDs. Supports optional
        heartbeat for proactive disconnect detection.

        Features exponential backoff with jitter for connection retries and
        automatic reconnection when connection is lost.

        Supports server-push notifications via notification_callback.
        Publishes connection lifecycle events (connected, disconnected, reconnecting,
        reconnected) to an optional event_bus for decoupled state notification.
        end note

            client o-u- ores::comms::net::client_options
            client o-u- ores::comms::net::connection
            client o-u- ores::comms::net::pending_request_map
            client o-u- ores::comms::net::connection_state
            client ..> ores::comms::messaging::frame
            client ..> ores::comms::messaging::error_code
            client ..> ores::comms::service::handshake_service : uses
            client ..> ores::comms::messaging::ping : uses
            client ..> ores::comms::messaging::pong : uses
            client ..> ores::comms::messaging::notification_message : uses
            client ..> ores::comms::eventing::connected_event : publishes
            client ..> ores::comms::eventing::disconnected_event : publishes
            client ..> ores::comms::eventing::reconnecting_event : publishes
            client ..> ores::comms::eventing::reconnected_event : publishes

        class pending_request_map #ECECEC {
            +pending_request_map(boost::asio::any_io_executor executor)
            +register_request(std::uint32_t correlation_id) std::shared_ptr<response_channel>
            +complete(std::uint32_t correlation_id, messaging::frame response) bool
            +fail(std::uint32_t correlation_id, messaging::error_code ec) bool
            +fail_all(messaging::error_code ec) void
            +remove(std::uint32_t correlation_id) void
            +size() std::size_t
            +empty() bool
            -{field} executor_ boost::asio::any_io_executor
            -{field} mutex_ std::mutex
            -{field} pending_ std::unordered_map<std::uint32_t, std::shared_ptr<response_channel>>
        }

        note top of pending_request_map
        Thread-safe map for tracking pending requests by correlation ID.

        Used by the client to match incoming responses to their originating
        requests. When a request is sent, a response_channel is registered
        with its correlation ID. When a response arrives, the message loop
        looks up the channel by correlation ID and delivers the response.
        end note

            pending_request_map o-u- ores::comms::net::response_channel
            pending_request_map ..> ores::comms::messaging::frame
            pending_request_map ..> ores::comms::messaging::error_code

        class response_channel #ECECEC {
            +response_channel(boost::asio::any_io_executor executor)
            +set_value(messaging::frame response) void
            +set_error(messaging::error_code ec) void
            +get() boost::asio::awaitable<std::expected<messaging::frame, messaging::error_code>>
            +is_ready() bool
            -{field} signal_ boost::asio::steady_timer
            -{field} mutex_ std::mutex
            -{field} response_ std::optional<messaging::frame>
            -{field} error_ std::optional<messaging::error_code>
            -{field} ready_ bool
        }

        note top of response_channel
        Single-value async channel for delivering a response frame.

        Used by the message loop to deliver responses to waiting coroutines.
        Each channel can hold exactly one response (or error). The consumer
        calls get() which blocks until set_value() or set_error() is called
        by the producer (message loop).
        end note

            response_channel ..> ores::comms::messaging::frame
            response_channel ..> ores::comms::messaging::error_code

            class connection #ECECEC {
            +connection(ssl_socket socket)
            +ssl_handshake_server() boost::asio::awaitable<void>
            +ssl_handshake_client() boost::asio::awaitable<void>
            +read_frame() boost::asio::awaitable<std::expected<messaging::frame, messaging::error_code>>
            +write_frame(const messaging::frame& frame) boost::asio::awaitable<void>
            +is_open() bool
            +close() void
            +remote_address() std::string
            -{field} socket_ ssl_socket
        }

        note top of connection
        SSL connection wrapper for frame-based communication.

        Provides async read/write operations for protocol frames over SSL/TLS.
        end note

            connection ..> ores::comms::messaging::frame
            connection ..> ores::comms::messaging::error_code

            class server_session #ECECEC {
            +server_session(std::unique_ptr<connection> conn, std::string server_id, std::shared_ptr<messaging::message_dispatcher> dispatcher, std::shared_ptr<service::subscription_manager> subscription_mgr)
            +run() boost::asio::awaitable<void>
            +stop() void
            +queue_notification(const std::string& event_type, std::chrono::system_clock::time_point timestamp) void
            -perform_handshake() boost::asio::awaitable<bool>
            -process_messages() boost::asio::awaitable<void>
            -send_pending_notifications() boost::asio::awaitable<void>
            -register_with_subscription_manager() void
            -unregister_from_subscription_manager() void
            -{field} conn_ std::unique_ptr<connection>
            -{field} server_id_ std::string
            -{field} dispatcher_ std::shared_ptr<messaging::message_dispatcher>
            -{field} subscription_mgr_ std::shared_ptr<service::subscription_manager>
            -{field} sequence_number_ std::uint32_t
            -{field} handshake_complete_ bool
            -{field} active_ std::atomic<bool>
            -{field} notification_mutex_ std::mutex
            -{field} pending_notifications_ std::queue<pending_notification>
        }

        note top of server_session
        Represents a client session on the server side.

        Manages the lifecycle of a single client connection, including
        handshake, message processing, and cleanup.
        Supports server-push notifications for subscribed events.
        end note

            server_session o-u- ores::comms::net::connection
            server_session o-u- ores::comms::messaging::message_dispatcher
            server_session o-u- ores::comms::service::subscription_manager
            server_session ..> ores::comms::service::handshake_service : uses
            server_session ..> ores::comms::service::heartbeat_service : uses
            server_session ..> ores::comms::messaging::error_response : uses
            server_session ..> ores::comms::messaging::notification_message : uses

            class client_session_info #F7E5FF {
                +{field} account_id boost::uuids::uuid
                +{field} username std::string
            }

            note top of client_session_info
            Information about the current client session.

            Fields:

            - account_id: Unique identifier of the authenticated account.
            - username: Username of the authenticated user.
            end note

            enum client_session_error #F2DAFD {
                not_connected
                not_logged_in
                not_admin
                request_failed
                server_error
            }

            note top of client_session_error
            Error codes for client session operations.

            - not_connected: Client is not connected to server.
            - not_logged_in: User is not logged in.
            - not_admin: User lacks admin privileges.
            - request_failed: Request failed to send or receive.
            - server_error: Server returned an error response.
            end note

            class client_session #ECECEC {
                +client_session()
                +~client_session()
                +connect(options: client_options) std::expected<void, client_session_error>
                +disconnect() void
                +is_connected() bool
                +is_logged_in() bool
                +set_session_info(info: client_session_info) void
                +clear_session_info() void
                +process_request<RequestType, ResponseType, RequestMsgType>(request: RequestType) std::expected<ResponseType, client_session_error>
                +process_authenticated_request<RequestType, ResponseType, RequestMsgType>(request: RequestType) std::expected<ResponseType, client_session_error>
                +process_admin_request<RequestType, ResponseType, RequestMsgType>(request: RequestType) std::expected<ResponseType, client_session_error>
                -{static} lg() auto&
                -{field} client_ std::shared_ptr<client>
                -{field} session_info_ std::optional<client_session_info>
            }

            note top of client_session
            Auth-aware client wrapper for ORE Studio.

            Provides a high-level interface for client-server communication with
            built-in authentication state management. Shared between shell and qt
            applications.

            Template methods:
            - process_request: Send any request without auth checks.
            - process_authenticated_request: Requires login before sending.
            - process_admin_request: Requires admin privileges before sending.

            Session state is managed externally via set_session_info/clear_session_info
            to avoid circular dependencies with domain-specific login types.
            end note

            client_session o-- ores::comms::net::client
            client_session o-- ores::comms::net::client_session_info
            client_session ..> ores::comms::net::client_session_error
            client_session ..> ores::comms::messaging::frame
            client_session ..> ores::comms::messaging::error_response
        }

        namespace messaging #F2F2F2 {
            '
            ' Layout groupings for better diagram structure
            '

            ' Group: Infrastructure classes (Row 1)
            together {
                class result
                class message_type_range
                class message_handler
                class message_dispatcher
            }

            ' Group: Frame classes (Row 2)
            together {
                class frame_header
                class frame
            }

            ' Group: Traits template (Row 2.5)
            together {
                class message_traits
            }

            ' Group: Heartbeat messages (Row 3)
            together {
                class ping
                class pong
            }

            ' Group: Handshake messages (Row 3)
            together {
                class handshake_request
                class handshake_response
                class handshake_ack
            }

            ' Group: Subscribe messages (Row 4)
            together {
                class subscribe_request
                class subscribe_response
            }

            ' Group: Unsubscribe messages (Row 4)
            together {
                class unsubscribe_request
                class unsubscribe_response
            }

            ' Group: Error and notification (Row 5)
            together {
                class error_response
                class notification_message
            }

            ' Group: Enums and type aliases (Row 6)
            together {
                enum message_type
                class error_code
                class reader
                class writer
            }

            ' Hidden relationships to stack request/response pairs vertically
            ping -[hidden]down- pong
            handshake_request -[hidden]down- handshake_response
            handshake_response -[hidden]down- handshake_ack
            subscribe_request -[hidden]down- subscribe_response
            unsubscribe_request -[hidden]down- unsubscribe_response
            frame_header -[hidden]down- frame
            message_type -[hidden]down- error_code
            error_code -[hidden]down- reader
            reader -[hidden]down- writer

            ' Hidden relationships to create row structure
            result -[hidden]down- frame_header
            frame -[hidden]down- ping
            frame -[hidden]down- handshake_request
            pong -[hidden]down- subscribe_request
            handshake_ack -[hidden]down- unsubscribe_request
            subscribe_response -[hidden]down- error_response
            unsubscribe_response -[hidden]down- notification_message
            error_response -[hidden]down- message_type

            '
            ' Class definitions
            '

            class result #ECECEC {
                +result(const T& value)
                +result(T&& value)
                +result(const E& error)
                +result(E&& error)
                +has_value() bool
                +has_error() bool
                +value() T&
                +error() E&
                -{field} data_ std::variant<T, E>
            }

            note top of result
            Simple result type for C++20 (std::expected replacement).

            Holds either a value of type T or an error of type E.
            end note

            class message_type_range #F7E5FF {
                +{field} min std::uint16_t
                +{field} max std::uint16_t
                +contains(message_type type) bool
            }

            note top of message_type_range
            Range of message types handled by a subsystem.

            Defines an inclusive range [min, max] of message types.

            Fields:

            - min: Minimum message type value.
            - max: Maximum message type value.
            end note

            interface message_handler #ECECEC {
                +{abstract} handle_message(message_type type, std::span<const std::uint8_t> payload, const std::string& remote_address) boost::asio::awaitable<std::expected<std::vector<std::uint8_t>, error_code>>
            }

            note top of message_handler
            Abstract interface for handling messages from a subsystem.

            Subsystems implement this interface to process their domain-specific messages.
            The handler is responsible for:
            - Deserializing the payload into subsystem-specific types
            - Executing the requested operation
            - Serializing the response back into bytes
            end note

            class frame_header <<message>> #E1F5FF {
                +{field} magic std::uint32_t
                +{field} version_major std::uint16_t
                +{field} version_minor std::uint16_t
                +{field} type message_type
                +{field} reserved1 std::uint16_t
                +{field} payload_size std::uint32_t
                +{field} sequence std::uint32_t
                +{field} crc std::uint32_t
                +{field} reserved2 std::array<std::uint8_t, 8>
            }

            note top of frame_header
            Frame header structure for the ORES protocol.

            Frame layout (32 bytes header):
            +0:  magic (4 bytes)       - Protocol identifier (0x4F524553 = "ORES")
            +4:  version_major (2 bytes) - Protocol major version
            +6:  version_minor (2 bytes) - Protocol minor version
            +8:  type (2 bytes)        - Message type
            +10: reserved1 (2 bytes)   - Reserved for future use
            +12: payload_size (4 bytes) - Size of payload in bytes
            +16: sequence (4 bytes)    - Sequence number for ordering
            +20: crc (4 bytes)         - CRC32 checksum of header + payload
            +24: reserved2 (8 bytes)   - Reserved for future use
            +32: payload (N bytes)     - Message payload

            Fields:

            - magic: Protocol identifier.
            - version_major: Protocol major version.
            - version_minor: Protocol minor version.
            - type: Message type.
            - reserved1: Reserved for future use.
            - payload_size: Size of payload in bytes.
            - sequence: Sequence number for ordering.
            - crc: CRC32 checksum of header and payload.
            - reserved2: Reserved for future use.
            end note

            frame_header ..> ores::comms::messaging::message_type

            class frame <<message>> #E1F5FF {
                +frame()
                +frame(message_type type, std::uint32_t sequence, std::vector<std::uint8_t> payload)
                +header() frame_header
                +payload() std::vector<std::uint8_t>
                +serialize() std::vector<std::uint8_t>
                +{static} deserialize_header(std::span<const std::uint8_t> data) std::expected<frame_header, error_code>
                +{static} deserialize(const frame_header& header, std::span<const std::uint8_t> data) std::expected<frame, error_code>
                +validate() std::expected<void, error_code>
                -calculate_crc() std::uint32_t
                -serialize_header(frame_header header, std::span<std::uint8_t> buffer) void
                -{field} header_ frame_header
                -{field} payload_ std::vector<std::uint8_t>
            }

            note top of frame
            Complete frame with header and payload.
            end note

            frame o-u- ores::comms::messaging::frame_header
            frame ..> ores::comms::messaging::error_code

            class message_traits<Request> <<template>> #ECECEC {
                +{field} request_type Request
                +{field} response_type Response
                +{field} request_message_type message_type
            }

            note top of message_traits
            Traits template for mapping request types to response types.

            Provides compile-time type information for request/response pairs:
            - request_type: The request struct type
            - response_type: The corresponding response struct type
            - request_message_type: The message_type enum value

            Enables simplified process_request API:

            // Old API:
            client->process_request<
                subscribe_request,
                subscribe_response,
                message_type::subscribe_request>(req);

            // New API using traits:
            client->process_request(req);

            See also: has_message_traits concept
            end note

            message_traits ..> ores::comms::messaging::message_type

            class message_dispatcher #ECECEC {
                +message_dispatcher(std::shared_ptr<service::auth_session_service> sessions)
                +register_handler(message_type_range range, std::shared_ptr<message_handler> handler) void
                +dispatch(const frame& request_frame, std::uint32_t sequence, const std::string& remote_address) boost::asio::awaitable<std::expected<frame, error_code>>
                -find_handler(message_type type) message_handler*
                -get_response_type(message_type request_type) message_type
                -{field} handlers_ std::map<message_type_range, std::shared_ptr<message_handler>>
                -{field} sessions_ std::shared_ptr<service::auth_session_service>
            }

            note top of message_dispatcher
            Dispatches incoming messages to registered subsystem handlers.

            The dispatcher maintains a registry of message handlers for different
            message type ranges. When a message arrives, it:
            1. Checks authorization via auth_session_service before routing
            2. Routes to the appropriate handler based on message type
            3. Converts the handler's response back into a frame

            Authorization is centralized here so handlers don't duplicate auth logic.

            Thread-safety: This class is not thread-safe. Registration should happen
            during initialization before concurrent access begins.
            end note

            message_dispatcher o-u- ores::comms::messaging::message_type_range
            message_dispatcher o-u- ores::comms::messaging::message_handler
            message_dispatcher o-u- ores::comms::service::auth_session_service
            message_dispatcher ..> ores::comms::messaging::frame
            message_dispatcher ..> ores::comms::messaging::error_code
            message_dispatcher ..> ores::comms::messaging::message_type

            class ping <<message>> #E1F5FF {
                +{static} serialize(ping v) std::vector<std::byte>
                +{static} deserialize(std::span<const std::byte> data) std::expected<ping, error_code>
            }

            note top of ping
            Ping message sent by client to check connection liveness.

            Lightweight keepalive message with no payload.
            end note

            ping ..> ores::comms::messaging::error_code

            class pong <<message>> #E1F5FF {
                +{static} serialize(pong v) std::vector<std::byte>
                +{static} deserialize(std::span<const std::byte> data) std::expected<pong, error_code>
            }

            note top of pong
            Pong message sent by server in response to ping.

            Lightweight response message confirming connection is alive.
            end note

            pong ..> ores::comms::messaging::error_code

            class handshake_request <<message>> #E1F5FF {
                +{field} client_version_major std::uint16_t
                +{field} client_version_minor std::uint16_t
                +{field} client_identifier std::string
                +{static} serialize(handshake_request v) std::vector<std::uint8_t>
                +{static} deserialize(std::span<const std::uint8_t> data) std::expected<handshake_request, error_code>
            }

            note top of handshake_request
            Handshake request message sent by client to initiate connection.

            Fields:

            - client_version_major: Client protocol major version.
            - client_version_minor: Client protocol minor version.
            - client_identifier: Client identifier string.
            end note

            handshake_request ..> ores::comms::messaging::error_code

            class handshake_response <<message>> #E1F5FF {
                +{field} server_version_major std::uint16_t
                +{field} server_version_minor std::uint16_t
                +{field} version_compatible bool
                +{field} server_identifier std::string
                +{field} status error_code
                +{static} serialize(handshake_response v) std::vector<std::uint8_t>
                +{static} deserialize(std::span<const std::uint8_t> data) std::expected<handshake_response, error_code>
            }

            note top of handshake_response
            Handshake response message sent by server to client.

            Fields:

            - server_version_major: Server protocol major version.
            - server_version_minor: Server protocol minor version.
            - version_compatible: Whether the versions are compatible.
            - server_identifier: Server identifier string.
            - status: Error code indicating handshake status.
            end note

            handshake_response ..> ores::comms::messaging::error_code

            class handshake_ack <<message>> #E1F5FF {
                +{field} status error_code
                +{static} serialize(handshake_ack v) std::vector<std::uint8_t>
                +{static} deserialize(std::span<const std::uint8_t> data) std::expected<handshake_ack, error_code>
            }

            note top of handshake_ack
            Handshake acknowledgment message sent by client to complete handshake.

            Fields:

            - status: Error code indicating acknowledgment status.
            end note

            handshake_ack ..> ores::comms::messaging::error_code

            class error_response <<message>> #E1F5FF {
                +{field} code error_code
                +{field} message std::string
                +{static} serialize(error_response v) std::vector<std::uint8_t>
                +{static} deserialize(std::span<const std::uint8_t> data) std::expected<error_response, error_code>
            }

            note top of error_response
            Error response message sent when request processing fails.

            Fields:

            - code: Error code indicating the error type.
            - message: Human-readable error message.
            end note

            error_response ..> ores::comms::messaging::error_code

            class subscribe_request <<message>> #E1F5FF {
                +{field} event_type std::string
                +{static} serialize(subscribe_request v) std::vector<std::byte>
                +{static} deserialize(std::span<const std::byte> data) std::expected<subscribe_request, error_code>
            }

            note top of subscribe_request
            Request to subscribe to notifications for a specific event type.

            Fields:

            - event_type: The fully qualified event type name to subscribe to
              (e.g., "ores.risk.currency_changed_event").
            end note

            subscribe_request ..> ores::comms::messaging::error_code

            class subscribe_response <<message>> #E1F5FF {
                +{field} success bool
                +{field} message std::string
                +{static} serialize(subscribe_response v) std::vector<std::byte>
                +{static} deserialize(std::span<const std::byte> data) std::expected<subscribe_response, error_code>
            }

            note top of subscribe_response
            Response to a subscribe request.

            Fields:

            - success: Whether the subscription was successful.
            - message: Human-readable status message.
            end note

            subscribe_response ..> ores::comms::messaging::error_code

            class unsubscribe_request <<message>> #E1F5FF {
                +{field} event_type std::string
                +{static} serialize(unsubscribe_request v) std::vector<std::byte>
                +{static} deserialize(std::span<const std::byte> data) std::expected<unsubscribe_request, error_code>
            }

            note top of unsubscribe_request
            Request to unsubscribe from notifications for a specific event type.

            Fields:

            - event_type: The fully qualified event type name to unsubscribe from.
            end note

            unsubscribe_request ..> ores::comms::messaging::error_code

            class unsubscribe_response <<message>> #E1F5FF {
                +{field} success bool
                +{field} message std::string
                +{static} serialize(unsubscribe_response v) std::vector<std::byte>
                +{static} deserialize(std::span<const std::byte> data) std::expected<unsubscribe_response, error_code>
            }

            note top of unsubscribe_response
            Response to an unsubscribe request.

            Fields:

            - success: Whether the unsubscription was successful.
            - message: Human-readable status message.
            end note

            unsubscribe_response ..> ores::comms::messaging::error_code

            class notification_message <<message>> #E1F5FF {
                +{field} event_type std::string
                +{field} timestamp std::chrono::system_clock::time_point
                +{static} serialize(notification_message v) std::vector<std::byte>
                +{static} deserialize(std::span<const std::byte> data) std::expected<notification_message, error_code>
            }

            note top of notification_message
            Server-push notification sent when a subscribed event occurs.

            Fields:

            - event_type: The fully qualified event type name.
            - timestamp: When the event occurred (UTC).
            end note

            notification_message ..> ores::comms::messaging::error_code

            enum message_type {
                handshake_request
                handshake_response
                handshake_ack
                error_response
                ping
                pong
                subscribe_request
                subscribe_response
                unsubscribe_request
                unsubscribe_response
                notification_message
                get_currencies_request
                get_currencies_response
                save_currency_request
                save_currency_response
                delete_currency_request
                delete_currency_response
                get_currency_history_request
                get_currency_history_response
                create_account_request
                create_account_response
                list_accounts_request
                list_accounts_response
                login_request
                login_response
                unlock_account_request
                unlock_account_response
                last_value
            }

            class error_code <<alias>> #E1F5FF {
            }

            note top of error_code
            Type alias for ores::utility::serialization::error_code.

            The canonical error_code enum is now defined in ores.utility.
            This alias maintains backward compatibility with existing code
            that references ores::comms::messaging::error_code.
            end note

            class reader <<alias>> #E1F5FF {
            }

            note top of reader
            Type alias for ores::utility::serialization::reader.

            Binary deserialization helper. The canonical implementation
            is now in ores.utility to avoid circular dependencies.
            end note

            class writer <<alias>> #E1F5FF {
            }

            note top of writer
            Type alias for ores::utility::serialization::writer.

            Binary serialization helper. The canonical implementation
            is now in ores.utility to avoid circular dependencies.
            end note
        }

        namespace domain #F2F2F2 {
            namespace events #F2F2F2 {
                class connected_event <<event>> #FFE4B5 {
                    +{field} timestamp std::chrono::system_clock::time_point
                    +{field} host std::string
                    +{field} port std::uint16_t
                }

                note top of connected_event
                Event published when successfully connected to a server.

                Published by the client after successful connection and handshake.
                end note

                class disconnected_event <<event>> #FFE4B5 {
                    +{field} timestamp std::chrono::system_clock::time_point
                }

                note top of disconnected_event
                Event published when disconnected from the server.

                Published by the client when connection is lost or explicitly closed.
                end note

                class reconnecting_event <<event>> #FFE4B5 {
                    +{field} timestamp std::chrono::system_clock::time_point
                }

                note top of reconnecting_event
                Event published when attempting to reconnect to the server.

                Published by the client when auto-reconnect is triggered.
                end note

                class reconnected_event <<event>> #FFE4B5 {
                    +{field} timestamp std::chrono::system_clock::time_point
                }

                note top of reconnected_event
                Event published when successfully reconnected to the server.

                Published by the client after auto-reconnect succeeds.
                end note
            }
        }

        namespace service #F2F2F2 {
            '
            ' Layout groupings for better diagram structure
            '

            ' Group: Session data classes
            together {
                enum session_protocol
                class session_data
                class client_info
            }

            ' Group: Authentication classes
            together {
                class session_info
                class auth_session_service
            }

            ' Group: Protocol services
            together {
                class handshake_service
                class heartbeat_service
            }

            ' Group: Subscription classes
            together {
                class subscription_manager
                class subscription_handler
                class remote_event_adapter
            }

            ' Hidden relationships to stack related classes vertically
            session_protocol -[hidden]down- session_data
            session_data -[hidden]down- client_info
            session_info -[hidden]down- auth_session_service
            handshake_service -[hidden]down- heartbeat_service
            subscription_manager -[hidden]down- subscription_handler
            subscription_handler -[hidden]down- remote_event_adapter

            '
            ' Class definitions
            '

            enum session_protocol #F2DAFD {
                binary
                http
            }

            note top of session_protocol
            Protocol used for the session connection.

            - binary: ORE Studio binary protocol over TCP.
            - http: HTTP/REST API with JWT authentication.
            end note

            class session_data #F7E5FF {
                +{field} id boost::uuids::uuid
                +{field} account_id boost::uuids::uuid
                +{field} start_time std::chrono::system_clock::time_point
                +{field} end_time std::optional<std::chrono::system_clock::time_point>
                +{field} client_ip boost::asio::ip::address
                +{field} client_identifier std::string
                +{field} client_version_major std::uint16_t
                +{field} client_version_minor std::uint16_t
                +{field} bytes_sent std::uint64_t
                +{field} bytes_received std::uint64_t
                +{field} country_code std::string
                +{field} protocol session_protocol
                +is_active() bool
                +duration() std::optional<std::chrono::seconds>
            }

            note top of session_data
            Session data owned by ores.comms for protocol-level session tracking.

            This struct exists to break the circular dependency between ores.comms
            and ores.iam. Previously, ores.comms depended on ores.iam for the session
            type, creating a cycle:

              ores.comms -> ores.iam -> ores.variability -> ores.comms

            By defining session data here, the dependency is inverted: ores.iam now
            depends on ores.comms and provides conversion functions between this
            struct and its domain::session.

            This is a plain data struct with no behavior beyond trivial helpers.
            The persistence layer (repository, mappers) remains in ores.iam.
            end note

            session_data o-- ores::comms::service::session_protocol

            class client_info #F7E5FF {
                +{field} client_identifier std::string
                +{field} client_version_major std::uint16_t
                +{field} client_version_minor std::uint16_t
            }

            note top of client_info
            Client information captured during handshake.

            Stored by remote address after successful handshake, retrieved during
            login to populate session tracking fields.

            Fields:

            - client_identifier: Client identifier string from handshake.
            - client_version_major: Client protocol version major number.
            - client_version_minor: Client protocol version minor number.
            end note

            class session_info #F7E5FF {
                +{field} account_id boost::uuids::uuid
            }

            note top of session_info
            Lightweight session info for backward compatibility.

            Authorization is now handled via RBAC permissions checked
            at the handler level using authorization_service.

            Fields:

            - account_id: Unique identifier of the authenticated account.
            end note

            class auth_session_service #ECECEC {
                +get_session(std::string) std::optional<session_info>
                +get_session_data(std::string) std::shared_ptr<session_data>
                +is_authenticated(std::string) bool
                +store_session(std::string, session_info) void
                +store_session_data(std::string, std::shared_ptr<session_data>) void
                +update_session_bytes(std::string, std::uint64_t, std::uint64_t) void
                +remove_session(std::string) std::shared_ptr<session_data>
                +clear_all_sessions() std::vector<std::shared_ptr<session_data>>
                +get_all_sessions() std::vector<std::shared_ptr<session_data>>
                +store_client_info(std::string, client_info) void
                +get_client_info(std::string) std::optional<client_info>
                +remove_client_info(std::string) void
                +authorize_request(messaging::message_type, std::string) std::expected<void, messaging::error_code>
                -{static} requires_authentication(messaging::message_type) bool
                -{field} session_mutex_ std::mutex
                -{field} sessions_ std::map<std::string, std::shared_ptr<session_data>>
                -{field} client_info_mutex_ std::mutex
                -{field} client_infos_ std::map<std::string, client_info>
            }

            note top of auth_session_service
            Centralized session management service.

            Tracks authenticated sessions by remote address. This service is shared
            across all message handlers to provide consistent authorization checks.

            Stores full session_data for session tracking and client_info captured
            during handshake. The session_data struct is owned by ores.comms to break
            the circular dependency with ores.iam.

            Thread-safety: All public methods are thread-safe.

            Authorization logic:
            - Some messages don't require authentication (login, bootstrap, ping/pong)
            - All other messages require authentication
            - Permission-based authorization is handled at the handler level
            end note

            auth_session_service o-- ores::comms::service::session_info
            auth_session_service o-- ores::comms::service::session_data
            auth_session_service o-- ores::comms::service::client_info
            auth_session_service ..> ores::comms::messaging::message_type
            auth_session_service ..> ores::comms::messaging::error_code

            class handshake_service #ECECEC {
                +{static} perform_client_handshake(net::connection& conn, const std::function<std::uint32_t()>& sequence_generator, const std::string& client_identifier) boost::asio::awaitable<void>
                +{static} perform_server_handshake(net::connection& conn, std::uint32_t sequence, const std::string& server_identifier) boost::asio::awaitable<bool>
            }

            note top of handshake_service
            Service for managing protocol handshake between client and server.

            Encapsulates the handshake protocol logic for both client and server sides,
            handling the three-way handshake:
            1. Client sends handshake_request
            2. Server responds with handshake_response (including version compatibility)
            3. Client sends handshake_ack to complete
            end note

            handshake_service ..> ores::comms::messaging::handshake_request : uses
            handshake_service ..> ores::comms::messaging::handshake_response : uses
            handshake_service ..> ores::comms::messaging::handshake_ack : uses

            class heartbeat_service #ECECEC {
                +{static} handle_ping(net::connection& conn, std::uint32_t sequence, std::uint32_t correlation_id) boost::asio::awaitable<void>
            }

            note top of heartbeat_service
            Service for handling heartbeat (ping/pong) protocol on the server.

            Provides server-side handling of ping messages by sending pong responses.
            Client-side heartbeat is handled by the client's message loop using
            correlation IDs for response matching.
            end note

            heartbeat_service ..> ores::comms::messaging::ping : uses
            heartbeat_service ..> ores::comms::messaging::pong : uses

            class subscription_manager #ECECEC {
                +register_session(const std::string& session_id, notification_callback callback) void
                +unregister_session(const std::string& session_id) void
                +subscribe(const std::string& session_id, const std::string& event_type) bool
                +unsubscribe(const std::string& session_id, const std::string& event_type) bool
                +notify(const std::string& event_type, std::chrono::system_clock::time_point timestamp) std::size_t
                +subscriber_count(const std::string& event_type) std::size_t
                +session_count() std::size_t
                +get_subscriptions(const std::string& session_id) std::vector<std::string>
                -{field} mutex_ std::mutex
                -{field} sessions_ std::unordered_map<session_id, session_info>
                -{field} subscriptions_ std::unordered_map<event_type, session_set>
            }

            note top of subscription_manager
            Manages client subscriptions for server-push notifications.

            Tracks which sessions are subscribed to which event types.
            When an event occurs, notifies all subscribed sessions via
            their registered callbacks.

            Thread-safe: all operations are protected by mutex.
            end note

            class subscription_handler #ECECEC {
                +subscription_handler(std::shared_ptr<subscription_manager> manager)
                +handle_message(messaging::message_type type, std::span<const std::byte> payload, const std::string& remote_address) boost::asio::awaitable<std::expected<std::vector<std::byte>, messaging::error_code>>
                -{field} manager_ std::shared_ptr<subscription_manager>
            }

            note top of subscription_handler
            Message handler for subscription protocol messages.

            Handles subscribe_request and unsubscribe_request messages
            from clients, delegating to subscription_manager for state
            management.
            end note

            subscription_handler --|> ores::comms::messaging::message_handler
            subscription_handler o-- ores::comms::service::subscription_manager
            subscription_handler ..> ores::comms::messaging::subscribe_request : uses
            subscription_handler ..> ores::comms::messaging::subscribe_response : uses
            subscription_handler ..> ores::comms::messaging::unsubscribe_request : uses
            subscription_handler ..> ores::comms::messaging::unsubscribe_response : uses

            class remote_event_adapter #ECECEC {
                +remote_event_adapter(std::shared_ptr<net::client> client)
                +~remote_event_adapter()
                +subscribe(const std::string& event_type) boost::asio::awaitable<bool>
                +unsubscribe(const std::string& event_type) boost::asio::awaitable<bool>
                +is_subscribed(const std::string& event_type) bool
                +get_subscriptions() std::set<std::string>
                +resubscribe_all() boost::asio::awaitable<std::size_t>
                +set_notification_callback(notification_callback_t callback) void
                -on_notification(const std::string& event_type, std::chrono::system_clock::time_point timestamp) void
                -{field} client_ std::shared_ptr<net::client>
                -{field} mutex_ std::mutex
                -{field} subscriptions_ std::set<std::string>
                -{field} user_callback_ notification_callback_t
            }

            note top of remote_event_adapter
            Adapts remote server subscriptions to local notification callbacks.

            Bridges client-side event handling and server-side subscription
            management by:
            - Sending SUBSCRIBE/UNSUBSCRIBE protocol messages
            - Tracking active subscriptions locally
            - Supporting re-subscription after reconnect
            - Forwarding notifications to registered callbacks
            end note

            remote_event_adapter o-- ores::comms::net::client
            remote_event_adapter ..> ores::comms::messaging::subscribe_request : uses
            remote_event_adapter ..> ores::comms::messaging::subscribe_response : uses
            remote_event_adapter ..> ores::comms::messaging::unsubscribe_request : uses
            remote_event_adapter ..> ores::comms::messaging::unsubscribe_response : uses
        }

        namespace tests #F2F2F2 {
            '
            ' Layout groupings for better diagram structure
            '

            ' Group: Protocol tests
            together {
                class frame_tests
                class message_handler_tests
            }

            ' Group: Networking tests
            together {
                class net_client_tests
            }

            ' Group: Subscription tests
            together {
                class subscription_manager_tests
                class subscription_protocol_tests
            }

            ' Group: Traits tests
            together {
                class message_traits_tests
            }

            ' Hidden relationships to stack related classes vertically
            frame_tests -[hidden]down- message_handler_tests
            subscription_manager_tests -[hidden]down- subscription_protocol_tests

            '
            ' Class definitions
            '

            class frame_tests <<test suite>> #C5E1A5 {
                +test_frame_serialization() void
                +test_frame_serialization_empty_payload() void
                +test_frame_serialization_large_payload() void
                +test_frame_deserialization_invalid_data() void
                +test_frame_deserialization_corrupted_data() void
                +test_frame_roundtrip_multiple_message_types() void
                +test_frame_version_mismatch_strict_mode() void
                +test_frame_version_mismatch_lenient_mode() void
                +test_frame_version_mismatch_handshake_scenario() void
            }

            note top of frame_tests
            Test suite for protocol frame functionality.

            Tests cover frame serialization/deserialization,
            payload handling (empty/large), data corruption,
            roundtrip validation, and version mismatch scenarios.
            end note

            frame_tests ..> ores::comms::messaging::frame : tests
            frame_tests ..> ores::comms::messaging::frame_header : tests

            class net_client_tests <<test suite>> #C5E1A5 {
                +test_client_server_connection() void
                +test_session_cancellation_on_server_stop() void
                +test_heartbeat_configuration() void
                +test_heartbeat_disconnect_detection() void
                +test_heartbeat_disabled() void
            }

            note top of net_client_tests
            Test suite for client-server communication.

            Tests cover client-server connection establishment,
            handshake protocol, session lifecycle management
            including graceful cancellation on server shutdown,
            and heartbeat functionality for disconnect detection.
            end note

            net_client_tests ..> ores::comms::net::client : tests
            net_client_tests ..> ores::comms::net::server : tests
            net_client_tests ..> ores::comms::net::server_session : tests

            class message_handler_tests <<test suite>> #C5E1A5 {
                +test_request_serialization_roundtrip() void
                +test_response_serialization_roundtrip() void
                +test_handler_processes_test_request() void
                +test_handler_processes_echo_request() void
                +test_handler_rejects_invalid_message_type() void
                +test_dispatcher_with_registered_handler() void
                +test_dispatcher_without_handler_returns_error() void
                +test_dispatcher_preserves_correlation_id() void
                +test_handler_table_driven_values() void
                +test_echo_request_various_payloads() void
            }

            note top of message_handler_tests
            Test suite for message handler infrastructure.

            Tests cover test request/response serialization,
            message handler processing, dispatcher registration
            and dispatch, correlation ID preservation, and
            table-driven value testing.
            end note

            message_handler_tests ..> ores::comms::messaging::message_handler : tests
            message_handler_tests ..> ores::comms::messaging::message_dispatcher : tests

            class subscription_manager_tests <<test suite>> #C5E1A5 {
                +test_subscription_manager_starts_empty() void
                +test_subscription_manager_register_unregister_sessions() void
                +test_subscription_manager_subscribe_unsubscribe() void
                +test_subscription_manager_notify_subscribers() void
                +test_subscription_manager_multiple_sessions() void
                +test_subscription_manager_exception_handling() void
            }

            note top of subscription_manager_tests
            Test suite for subscription_manager.

            Tests cover session registration, subscription
            management, notification dispatch, multiple sessions,
            and exception handling.
            end note

            subscription_manager_tests ..> ores::comms::service::subscription_manager : tests

            class subscription_protocol_tests <<test suite>> #C5E1A5 {
                +test_subscribe_request_roundtrip() void
                +test_subscribe_response_roundtrip() void
                +test_unsubscribe_request_roundtrip() void
                +test_unsubscribe_response_roundtrip() void
                +test_notification_message_roundtrip() void
                +test_subscription_handler_subscribe() void
                +test_subscription_handler_unsubscribe() void
            }

            note top of subscription_protocol_tests
            Test suite for subscription protocol messages
            and handler.

            Tests cover message serialization roundtrips
            and subscription_handler processing.
            end note

            subscription_protocol_tests ..> ores::comms::messaging::subscribe_request : tests
            subscription_protocol_tests ..> ores::comms::messaging::subscribe_response : tests
            subscription_protocol_tests ..> ores::comms::messaging::unsubscribe_request : tests
            subscription_protocol_tests ..> ores::comms::messaging::unsubscribe_response : tests
            subscription_protocol_tests ..> ores::comms::messaging::notification_message : tests
            subscription_protocol_tests ..> ores::comms::service::subscription_handler : tests

            class message_traits_tests <<test suite>> #C5E1A5 {
                +test_has_message_traits_concept_satisfaction() void
                +test_message_traits_correct_types() void
                +test_response_type_convention() void
            }

            note top of message_traits_tests
            Test suite for message_traits template.

            Tests cover:
            - has_message_traits concept satisfaction
            - Correct request/response type mappings
            - Response message_type follows request + 1 convention
            end note

            message_traits_tests ..> ores::comms::messaging::message_traits : tests
        }
    }
}

' Local Variables:
' compile-command: "java -Djava.awt.headless=true -DPLANTUML_SECURITY_PROFILE=UNSECURE -DPLANTUML_LIMIT_SIZE=65535 -jar /usr/share/plantuml/plantuml.jar ores.comms.puml"
' End:
@enduml
