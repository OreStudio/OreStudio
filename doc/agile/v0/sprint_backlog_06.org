:PROPERTIES:
:ID: DBBD0C4F-EA14-4684-7583-D78AAF7AABFF
:END:
#+title: Sprint Backlog 06
#+options: <:nil c:nil ^:nil d:nil date:nil author:nil toc:nil html-postamble:nil
#+todo: STARTED | COMPLETED CANCELLED POSTPONED BLOCKED
#+tags: { code(c) infra(i) analysis(n) agile(a) }
#+startup: inlineimages

* Sprint Mission

- finish up all remaining tasks around domain entities.
- templatise domain entity generation.

* Stories

** Active

#+begin: clocktable :maxlevel 3 :scope subtree :tags t :indent nil :emphasize nil :scope file :narrow 75 :formula % :block today
#+TBLNAME: today_summary
#+CAPTION: Clock summary at [2025-12-02 Tue 10:58], for Tuesday, December 02, 2025.
|       | <75>                                  |        |      |      |       |
| Tags  | Headline                              | Time   |      |      |     % |
|-------+---------------------------------------+--------+------+------+-------|
|       | *Total time*                          | *1:47* |      |      | 100.0 |
|-------+---------------------------------------+--------+------+------+-------|
|       | Stories                               | 1:47   |      |      | 100.0 |
|       | Active                                |        | 1:47 |      | 100.0 |
| agile | Sprint and product backlog refinement |        |      | 0:18 |  16.8 |
| infra | OCR scan notebooks for this sprint    |        |      | 1:29 |  83.2 |
#+end:

#+begin: clocktable :maxlevel 3 :scope subtree :tags t :indent nil :emphasize nil :scope file :narrow 75 :formula %
#+TBLNAME: sprint_summary
#+CAPTION: Clock summary at [2025-12-02 Tue 10:58]
|       | <75>                                  |        |      |      |       |
| Tags  | Headline                              | Time   |      |      |     % |
|-------+---------------------------------------+--------+------+------+-------|
|       | *Total time*                          | *1:47* |      |      | 100.0 |
|-------+---------------------------------------+--------+------+------+-------|
|       | Stories                               | 1:47   |      |      | 100.0 |
|       | Active                                |        | 1:47 |      | 100.0 |
| agile | Sprint and product backlog refinement |        |      | 0:18 |  16.8 |
| infra | OCR scan notebooks for this sprint    |        |      | 1:29 |  83.2 |
#+end:

*** STARTED Sprint and product backlog refinement                     :agile:
    :LOGBOOK:
    CLOCK: [2025-12-02 Tue 10:54]--[2025-12-02 Tue 10:58] =>  0:04
    CLOCK: [2025-12-02 Tue 10:40]--[2025-12-02 Tue 10:54] =>  0:14
    :END:

Updates to sprint and product backlog.

#+begin_src emacs-lisp :exports none
;; agenda
(org-agenda-file-to-front)
#+end_src

#+name: pie-stories-chart
#+begin_src R :var sprint_summary=sprint_summary :results file graphics :exports results :file sprint_backlog_06_stories_pie_sorted.png :width 1920 :height 1080
library(conflicted)
library(ggplot2)
library(tidyverse)
library(tibble)

# Remove unnecessary rows (Total time, Stories, Active)
clean_sprint_summary <- tail(sprint_summary, -4)
stories <- unlist(clean_sprint_summary[2])
percent_values <- as.numeric(unlist(clean_sprint_summary[6]))

# Create a data frame and explicitly sort the stories by defining factor levels
df <- data.frame(
  stories = stories,
  percent = percent_values
) %>%
  # 1. Sort the data frame by percentage in descending order
  arrange(desc(percent)) %>%
  # 2. Convert 'stories' to a factor, setting the levels based on the sorted order.
  # This makes the order of the slices explicit for ggplot.
  mutate(
    stories = factor(stories, levels = stories),
    lab.pos = cumsum(percent) - 0.5 * percent
  )

# Manually selected colors to resemble the screenshot
custom_palette <- c(
  "#21518f", "#f37735", "#ffc425", "#81b214", "#d7385e",
  "#662e91", "#00a9ae", "#5c5c5c", "#a0c6e0", "#f8b195",
  "#ffe385", "#bde0fe", "#c5e0d4", "#e0b8a0", "#a56f8f",
  "#7a448a", "#4a9a9b", "#9b9b9b", "#6fa8dc", "#f7a072",
  "#ffd166", "#99d98c", "#ef5d60", "#9d529f", "#3a86ff",
  "#c1d6e1", "#f9e0ac", "#c2d6a4", "#e69a8d", "#a07d9f"
)

# Ensure the palette has enough colors for all stories.
if (length(custom_palette) < length(df$stories)) {
  warning("Not enough custom colors for all stories. Colors will repeat.")
  custom_palette <- rep(custom_palette, length.out = length(df$stories))
}


p <- ggplot(df, aes(x = "", y = percent, fill = stories)) +
  geom_bar(width = 1, stat = "identity") +
  coord_polar("y", start = 0) +
  scale_fill_manual(values = custom_palette) +
  ggtitle("Sprint 5: Resourcing per Story")  +
  labs(x = NULL, y = NULL, fill = "Stories") +
  theme_minimal() +
  theme(
    axis.text.x = element_blank(),
    panel.grid.major = element_blank(),
    panel.grid.minor = element_blank(),
    plot.title = element_text(hjust = 0.5, size = 18),
    legend.position = "right",
    legend.title = element_text(size = 14),
    legend.text = element_text(size = 12)
  )

print(p)
#+end_src

#+RESULTS: pie-stories-chart
[[file:sprint_backlog_06_stories_pie_sorted.png]]

#+name: stories-chart
#+begin_src R :var sprint_summary=sprint_summary :results file graphics :exports results :file sprint_backlog_06_stories.png :width 1200 :height 650
library(conflicted)
library(grid)
library(tidyverse)
library(tibble)

# Remove unnecessary rows.
clean_sprint_summary <- tail(sprint_summary, -4)
names <- unlist(clean_sprint_summary[2])
values <- as.numeric(unlist(clean_sprint_summary[6]))

# Create a data frame.
df <- data.frame(
  cost = values,
  stories = factor(names, levels = names[order(values, decreasing = FALSE)]),
  y = seq(length(names)) * 0.9
)

# Setup the colors
blue <- "#076fa2"

p <- ggplot(df) +
  aes(x = cost, y = stories) +
  geom_col(fill = blue, width = 0.6) +
  ggtitle("Sprint 5: Resourcing per Story") +
  xlab("Resourcing (%)") + ylab("Stories") +
  theme(text = element_text(size = 15))

print(p)
#+end_src

#+RESULTS: stories-chart
[[file:sprint_backlog_06_stories.png]]

#+name: tags-chart
#+begin_src R :var sprint_summary=sprint_summary :results file graphics :exports results :file sprint_backlog_06_tags.png :width 600 :height 400
library(conflicted)
library(grid)
library(tidyverse)
library(tibble)

# Remove unnecessary rows.
clean_sprint_summary <- tail(sprint_summary, -4)
names <- unlist(clean_sprint_summary[1])
values <- as.numeric(unlist(clean_sprint_summary[6]))

# Create a data frame.
df <- data.frame(
  cost = values,
  tags = names,
  y = seq(length(names)) * 0.9
)
# factor(names, levels = names[order(values, decreasing = FALSE)])

df2 <- setNames(aggregate(df$cost, by = list(df$tags), FUN = sum),  c("cost", "tags"))
# Setup the colors
blue <- "#076fa2"

p <- ggplot(df2) +
  aes(x = cost, y = tags) +
  geom_col(fill = blue, width = 0.6) +
  ggtitle("Sprint 5: Resourcing per Tag") +
  xlab("Resourcing (%)") + ylab("Story types") +
  theme(text = element_text(size = 15))

print(p)
#+end_src

#+RESULTS: tags-chart
[[file:sprint_backlog_06_tags.png]]

[[file:sprint_backlog_05_plan.png]]

[[file:sprint_backlog_05_resources.png]]

*** Add AI generated sprint summary                                   :infra:

It is a bit difficult to make sense of a sprint with all the story details. We
should use AI to make a human readable summary. Also, add a skill for this.
*** STARTED OCR scan notebooks for this sprint                        :infra:
    :LOGBOOK:
    CLOCK: [2025-12-02 Tue 09:10]--[2025-12-02 Tue 10:39] =>  1:29
    :END :

We need to scan all of our finance notebooks so we can use them with AI. Each
sprint will have a story similar to this until we scan and process them all.

*** Implement session cancellation                                     :code:

As per qwen:

#+begin_src markdown
Here's a **step-by-step implementation plan** to **cancel all active sessions
when the server stops**‚Äîbuilding cleanly on your current Asio coroutine-based
server design.

---

### üéØ Goal
When `server::stop()` is called (e.g., via SIGINT or programmatic shutdown):
1. **Immediately cancel** all ongoing session I/O operations (reads/writes, etc.).
2. **Gracefully terminate** all sessions without waiting indefinitely.
3. Preserve your existing cancellation architecture (based on `cancellation_signal`).

---

### ‚úÖ High-Level Strategy

Use a **hierarchical cancellation model**:
- The **server owns a root cancellation signal**.
- Each **session inherits a slot** from this root signal.
- When the server stops, it **emits cancellation**, which **propagates to all sessions**.

This avoids manual session tracking and leverages Asio‚Äôs built-in cancellation propagation.

---

## üìù Implementation Plan

### Step 1: Add a Root Cancellation Signal for Sessions
In `server.hpp`, add:

```cpp
private:
    boost::asio::cancellation_signal session_stop_signal_;
```

> This signal will be used to cancel **all sessions** simultaneously.

---

### Step 2: Expose a Cancellation Slot to Sessions
Add a **public (or private, if sessions are friends)** method:

```cpp
public:
    boost::asio::cancellation_slot get_session_cancellation_slot() const noexcept {
        return session_stop_signal_.slot();
    }
```

> Alternatively, make `session` a `friend class` and pass the slot directly in `accept_loop`.

---

### Step 3: Pass the Slot to Each Session
In `accept_loop`, when creating a session:

```cpp
auto sess = std::make_shared<session>(
    std::move(conn),
    options_.server_identifier,
    dispatcher_,
    get_session_cancellation_slot()  // ‚Üê pass the slot
);
```

> You‚Äôll need to **update `session`‚Äôs constructor** to accept and store this slot (or a copy of it).

---

### Step 4: Update `session` to Use the Cancellation Slot
In `session.hpp`:

```cpp
class session {
public:
    session(
        std::unique_ptr<connection> conn,
        std::string server_id,
        std::shared_ptr<protocol::message_dispatcher> dispatcher,
        boost::asio::cancellation_slot stop_slot);  // ‚Üê new parameter

private:
    boost::asio::cancellation_slot stop_slot_;
    // ... other members
};
```

In `session.cpp` constructor:

```cpp
session::session(
    std::unique_ptr<connection> conn,
    std::string server_id,
    std::shared_ptr<protocol::message_dispatcher> dispatcher,
    boost::asio::cancellation_slot stop_slot)
    : conn_(std::move(conn))
    , server_id_(std::move(server_id))
    , dispatcher_(std::move(dispatchor))
    , stop_slot_(std::move(stop_slot)) {
}
```

---

### Step 5: Bind Session I/O to the Cancellation Slot
In `session::run()` or wherever you do `co_await socket.async_read(...)`:

```cpp
// Example: reading from SSL stream
co_await conn_->ssl_stream().async_read_some(
    buffer,
    boost::asio::bind_cancellation_slot(
        stop_slot_,
        boost::asio::use_awaitable));
```

> Repeat for **all** async operations in the session (read, write, timers, etc.).

This ensures that when the server emits cancellation, **all session I/O is aborted**.

> üí° Tip: If you have a session-level read/write loop, you only need to bind the **outermost** `co_await`‚Äîcancellation will propagate.

---

### Step 6: Update `server::stop()` to Cancel Sessions Too
Modify your existing `stop()`:

```cpp
void server::stop() {
    BOOST_LOG_SEV(lg(), info) << "Stopping server...";

    // Cancel all sessions first
    session_stop_signal_.emit(boost::asio::cancellation_type::all);

    // Then cancel accept loop
    stop_signal_.emit(boost::asio::cancellation_type::all);
}
```

> Order doesn‚Äôt strictly matter, but canceling sessions first is more logical.

---

### Step 7: (Optional) Add Session Cleanup Logging
In `session::run()`, catch `operation_aborted` to log graceful exit:

```cpp
try {
    co_await /* session work */;
} catch (const boost::system::system_error& e) {
    if (e.code() == boost::asio::error::operation_aborted) {
        BOOST_LOG_SEV(lg(), debug) << "Session cancelled.";
    } else {
        BOOST_LOG_SEV(lg(), error) << "Session error: " << e.what();
    }
}
```

---

### ‚úÖ Benefits of This Approach
- **No manual session tracking** (no list of sessions to iterate over).
- **Automatic propagation**: One `emit()` cancels everything.
- **Safe and efficient**: Uses Asio‚Äôs native cancellation.
- **Composable**: Works with nested coroutines inside sessions.

---

### üîí Safety Notes
- The `session_stop_signal_` lives as long as the `server` object.
- Sessions capture a **slot**, not a reference to the signal‚Äîsafe even if the session outlives the emit (which it won‚Äôt, because you‚Äôre stopping the server).
- No race conditions: `emit()` is thread-safe and idempotent.

---

### üß™ Testing
1. Start server, open 2 connections.
2. Send Ctrl+C.
3. Verify:
   - "Stopping server..." log appears.
   - Both sessions log "Session cancelled." (or similar).
   - Program exits promptly.

---

Let me know if you'd like the full code patches for `session.hpp/cpp` or help adapting this to your exact `connection`/`ssl_stream` usage!
#+end_src


* Footer

| Previous: [[id:154212FF-BB02-8D84-1E33-9338B458380A][Version Zero]] |
