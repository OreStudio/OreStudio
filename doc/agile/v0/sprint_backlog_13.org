:PROPERTIES:
:ID: 9A4009E7-0E6C-11F1-852D-40B0768014EB
:END:
#+title: Sprint Backlog 13
#+options: <:nil c:nil ^:nil d:nil date:nil author:nil toc:nil html-postamble:nil
#+todo: STARTED | COMPLETED CANCELLED POSTPONED BLOCKED
#+tags: { code(c) infra(i) analysis(n) agile(a) }
#+startup: inlineimages

* Sprint Mission

- Add trade support and FSM.

* Stories

** Active

#+begin: clocktable :maxlevel 3 :scope subtree :tags t :indent nil :emphasize nil :scope file :narrow 75 :formula % :block today
#+TBLNAME: today_summary
#+CAPTION: Clock summary at [2026-02-20 Fri 23:48], for Friday, February 20, 2026.
|       | <75>                                       |        |      |      |       |
| Tags  | Headline                                   | Time   |      |      |     % |
|-------+--------------------------------------------+--------+------+------+-------|
|       | *Total time*                               | *4:24* |      |      | 100.0 |
|-------+--------------------------------------------+--------+------+------+-------|
|       | Stories                                    | 4:24   |      |      | 100.0 |
|       | Active                                     |        | 4:24 |      | 100.0 |
| agile | Sprint and product backlog refinement      |        |      | 0:08 |   3.0 |
| infra | Generate release notes for previous sprint |        |      | 1:16 |  28.8 |
| code  | Merge FSM into DQ                          |        |      | 0:34 |  12.9 |
| code  | Make all details dialogs tabbed            |        |      | 2:26 |  55.3 |
#+end:

#+begin: clocktable :maxlevel 3 :scope subtree :tags t :indent nil :emphasize nil :scope file :narrow 75 :formula %
#+TBLNAME: sprint_summary
#+CAPTION: Clock summary at [2026-02-20 Fri 23:48]
|       | <75>                                       |        |      |      |       |
| Tags  | Headline                                   | Time   |      |      |     % |
|-------+--------------------------------------------+--------+------+------+-------|
|       | *Total time*                               | *4:24* |      |      | 100.0 |
|-------+--------------------------------------------+--------+------+------+-------|
|       | Stories                                    | 4:24   |      |      | 100.0 |
|       | Active                                     |        | 4:24 |      | 100.0 |
| agile | Sprint and product backlog refinement      |        |      | 0:08 |   3.0 |
| infra | Generate release notes for previous sprint |        |      | 1:16 |  28.8 |
| code  | Merge FSM into DQ                          |        |      | 0:34 |  12.9 |
| code  | Make all details dialogs tabbed            |        |      | 2:26 |  55.3 |
#+end:

*** STARTED Sprint and product backlog refinement                     :agile:
    :LOGBOOK:
    CLOCK: [2026-02-20 Fri 15:10]--[2026-02-20 Fri 15:18] =>  0:08
    :END:

 Updates to sprint and product backlog.

#+begin_src emacs-lisp :exports none
;; agenda
(org-agenda-file-to-front)
#+end_src

#+name: pie-stories-chart
#+begin_src R :var sprint_summary=sprint_summary :colnames yes :results file graphics :exports results :file sprint_backlog_13_stories_pie_sorted.png :width 1920 :height 1080
library(conflicted)
library(ggplot2)
library(tidyverse)
library(tibble)

# Filter to only rows with actual story data (non-empty Tags column)
clean_sprint_summary <- sprint_summary %>% dplyr::filter(!is.na(Tags) & nzchar(Tags))
stories <- unlist(clean_sprint_summary[2])
percent_values <- as.numeric(unlist(clean_sprint_summary[6]))

# Create a data frame and explicitly sort the stories by defining factor levels
df <- data.frame(
  stories = stories,
  percent = percent_values
) %>%
  # 1. Sort the data frame by percentage in descending order
  arrange(desc(percent)) %>%
  # 2. Convert 'stories' to a factor, setting the levels based on the sorted order.
  # This makes the order of the slices explicit for ggplot.
  mutate(
    stories = factor(stories, levels = stories),
    lab.pos = cumsum(percent) - 0.5 * percent
  )

# Manually selected colors to resemble the screenshot
custom_palette <- c(
  "#21518f", "#f37735", "#ffc425", "#81b214", "#d7385e",
  "#662e91", "#00a9ae", "#5c5c5c", "#a0c6e0", "#f8b195",
  "#ffe385", "#bde0fe", "#c5e0d4", "#e0b8a0", "#a56f8f",
  "#7a448a", "#4a9a9b", "#9b9b9b", "#6fa8dc", "#f7a072",
  "#ffd166", "#99d98c", "#ef5d60", "#9d529f", "#3a86ff",
  "#c1d6e1", "#f9e0ac", "#c2d6a4", "#e69a8d", "#a07d9f"
)

# Ensure the palette has enough colors for all stories.
if (length(custom_palette) < length(df$stories)) {
  warning("Not enough custom colors for all stories. Colors will repeat.")
  custom_palette <- rep(custom_palette, length.out = length(df$stories))
}


p <- ggplot(df, aes(x = "", y = percent, fill = stories)) +
  geom_bar(width = 1, stat = "identity") +
  coord_polar("y", start = 0) +
  scale_fill_manual(values = custom_palette) +
  ggtitle("Sprint 13: Resourcing per Story")  +
  labs(x = NULL, y = NULL, fill = "Stories") +
  theme_minimal() +
  theme(
    axis.text.x = element_blank(),
    panel.grid.major = element_blank(),
    panel.grid.minor = element_blank(),
    plot.title = element_text(hjust = 0.5, size = 18),
    legend.position = "right",
    legend.title = element_text(size = 14),
    legend.text = element_text(size = 12)
  )

print(p)
#+end_src

#+RESULTS: pie-stories-chart
[[file:sprint_backlog_13_stories_pie_sorted.png]]

#+name: stories-chart
#+begin_src R :var sprint_summary=sprint_summary :colnames yes :results file graphics :exports results :file sprint_backlog_13_stories.png :width 1200 :height 650
library(conflicted)
library(grid)
library(tidyverse)
library(tibble)

# Filter to only rows with actual story data (non-empty Tags column)
clean_sprint_summary <- sprint_summary %>% dplyr::filter(Tags != "")
names <- unlist(clean_sprint_summary[2])
values <- as.numeric(unlist(clean_sprint_summary[6]))

# Create a data frame.
df <- data.frame(
  cost = values,
  stories = factor(names, levels = names[order(values, decreasing = FALSE)]),
  y = seq(length(names)) * 0.9
)

# Setup the colors
blue <- "#076fa2"

p <- ggplot(df) +
  aes(x = cost, y = stories) +
  geom_col(fill = blue, width = 0.6) +
  ggtitle("Sprint 13: Resourcing per Story") +
  xlab("Resourcing (%)") + ylab("Stories") +
  theme(text = element_text(size = 15))

print(p)
#+end_src

#+RESULTS: stories-chart
[[file:sprint_backlog_13_stories.png]]

#+name: tags-chart
#+begin_src R :var sprint_summary=sprint_summary :colnames yes :results file graphics :exports results :file sprint_backlog_13_tags.png :width 600 :height 400
library(conflicted)
library(grid)
library(tidyverse)
library(tibble)

clean_sprint_summary <- sprint_summary %>% dplyr::filter(Tags != "")
names <- unlist(clean_sprint_summary[1])
values <- as.numeric(unlist(clean_sprint_summary[6]))

df <- data.frame(
  cost = values,
  tags = names,
  y = seq(length(names)) * 0.9
)

df2 <- setNames(aggregate(df$cost, by = list(df$tags), FUN = sum), c("cost", "tags"))

blue <- "#076fa2"

p <- ggplot(df2) +
  aes(x = cost, y = tags) +
  geom_col(fill = blue, width = 0.6) +
  ggtitle("Sprint 13: Resourcing per Tag") +
  xlab("Resourcing (%)") + ylab("Story types") +
  theme(text = element_text(size = 15))

print(p)
#+end_src

#+RESULTS: tags-chart
[[file:sprint_backlog_13_tags.png]]

*** COMPLETED Generate release notes for previous sprint              :infra:
    :LOGBOOK:
    CLOCK: [2026-02-20 Fri 16:36]--[2026-02-20 Fri 16:37] =>  0:01
    CLOCK: [2026-02-20 Fri 16:22]--[2026-02-20 Fri 16:36] =>  0:14
    CLOCK: [2026-02-20 Fri 16:14]--[2026-02-20 Fri 16:21] =>  0:07
    CLOCK: [2026-02-20 Fri 15:19]--[2026-02-20 Fri 16:13] =>  0:54
    :END:

We now have so much text that we are bursting the prompt window. We need to
first feed the sprint backlog to summarise it and then use the summarised output
to generate the release notes. The process is a bit more time consuming now.

*** COMPLETED Merge FSM into DQ                                        :code:
    :LOGBOOK:
    CLOCK: [2026-02-20 Fri 17:27]--[2026-02-20 Fri 17:42] =>  0:15
    CLOCK: [2026-02-20 Fri 16:38]--[2026-02-20 Fri 16:57] =>  0:19
    :END:

We considered first adding FSM as a stand alone component, but in reality it is
part of the DQ framework. DQ is becoming a meta-data framework for all aspects
related to ensuring the data quality in the system. We will probably also put
four eyes into DQ.

#+begin_quote
This pull request refactors the Finite State Machine (FSM) component by
integrating it directly into the Data Quality (DQ) layer. This consolidation is
driven by the understanding that state machines serve as critical metadata
infrastructure for managing data quality. The changes involve a comprehensive
renaming of SQL objects and file paths to align FSM with its new home within DQ,
ensuring a more logical and maintainable architecture.

Highlights:

- FSM Component Consolidation: The Finite State Machine (FSM) component has been
  fully integrated into the Data Quality (DQ) layer, recognizing state machines
  as core metadata infrastructure for data quality.
- SQL Identifier Renaming: All SQL identifiers previously prefixed with
  ores_fsm_* have been systematically renamed to ores_dq_fsm_* to reflect their
  new organizational structure within the DQ component.
- File Relocation: All FSM-related SQL schema, trigger, RLS policy, and
  population scripts have been moved from their original fsm/ subdirectories
  into the dq/ subdirectories.
- Notification Channel Updates: PostgreSQL pg_notify channels for FSM entities
  (machines, states, transitions) have been updated to use the new ores_dq_fsm_
  prefix.
- Entity String Renaming: Internal entity strings used for FSM components have
  been updated from ores.fsm.* to ores.dq.fsm.*.
#+end_quote

*** STARTED Make all details dialogs tabbed                            :code:
    :LOGBOOK:
    CLOCK: [2026-02-20 Fri 22:48]--[2026-02-20 Fri 23:48] =>  1:00
    CLOCK: [2026-02-20 Fri 22:10]--[2026-02-20 Fri 22:24] =>  0:14
    CLOCK: [2026-02-20 Fri 17:43]--[2026-02-20 Fri 18:55] =>  1:12
    :END:

At present we have very long dialogs for details. Make all of them tabbed.


#+begin_quote
This pull request introduces significant UI enhancements and refactoring across
various detail dialogs and user-specific windows. The primary goal is to
standardize the layout of detail dialogs by adopting a tabbed interface,
centralizing provenance information into a dedicated 'Provenance' tab, and
improving the overall user experience through better organization and visual
cues. It also modernizes user account and session management by converting them
to MDI subwindows, aligning with a more integrated application feel.

Highlights:

Country Detail Dialog: Moved the flag display from a separate tab into the General tab as a group box, resulting in a dialog with two tabs: General and Provenance.
Currency Detail Dialog: Relocated the icon button from a floating position between the toolbar and tabs into the General tab within an Icon group box.
Main Window Menus: Added a top-level '&Trading' menu between Data and System, moving the 'Trades' action into it and adding 'Trades' to the toolbar.
Data Governance Submenu: Introduced a '&Dimensions' submenu within 'Data Governance', containing 'Origin', 'Nature', and 'Treatment Dimension' actions.
Change Commentary Field Removal: Removed the editable 'Change Commentary' field from the General tab in eight specific detail dialogs (Methodology, TreatmentDimension, DataDomain, CodingSchemeAuthorityType, CodingScheme, SubjectArea, Catalog, Dataset), while retaining a read-only version in the Provenance tab.
Methodology Detail Dialog: Enlarged the 'Implementation' text area by increasing its minimum height from 100 to 300.
My Sessions Window: Converted 'My Sessions' from a floating QDialog to an MDI subwindow, allowing re-triggering to bring it to the front.
My Account Window: Converted 'My Account' from a modal QDialog to a QWidget MDI subwindow, featuring a toolbar with a 'Save Email' action and three tabs: General (account info), Security (change password), and Sessions (session count + 'View History' button). The 'View History' button now emits a signal to open 'My Sessions' in the main window.
Entity Detail Dialog: Implemented a 32x24 country flag label next to the 'Business Centre' combo box, which updates dynamically upon selection changes via the image cache.
#+end_quote

*** STARTED Analyse caching at dialog level                            :code:

We seem to have a lot of caches lying around at the dialog level. It makes more
sense to have a common core (i.e. non-Qt specific) data-structure that caches
different types of data which is shared by the different dialogs. This would
also be reused by different clients such as Wt, shell, etc.

Instead of locking we should use immutable data structures. We should also take
into account notifications coming in for data changes. It should enable you to
notify all clients, load the data in the background in a way that does not
affect dialogs.

We could create workspace component which has all of the data needed, stored
using immer containers:

- it can have a comms aspect, so that the UI does not need to worry about any of
  that. You just request say currencies page N, workspace then deals with that.
  It can just give you the current version. If none, it will load via comms. It
  also knows about subscriptions so it will tell you about pending subscriptions
  for a collection you are interested in. As you load more pages, we load these
  into immer containers ordered by page.
- once we implement workspaces, we should then make all references to foreign
  keys "clickable". For example, if you are in a business centre and it has a
  country we should be able to click on it and open the country. At present we
  can't do this because the data is kept at the main dialog level.
- ideally we want a way to cache data in Qt format. We don't need to save this
  data to the local database. However, we don't want to make the
  =ores.workspace= library depend on Qt. Maybe we just need some kind of
  "extensions" on each frontend (e.g. Wt etc), sort of a qt.workspace which
  contains the original workspace plus any Qt specific representations. Or maybe
  use composition.
- we should add a UI to visualise the workspace, or at least be able to see size
  usage etc. Baobab style map.

Notes:

- actually this is not "workspace", its ores.caching.
- caching seems more like a component-level phenomena rather than having a
  dedicated component in the entire product. A component like ores.caching would
  have to depend on every component anyways, and it would not provide a lot of
  valuable services. Makes more sense to have a =ores.refdata/caching= and so
  on, with possibly a front-end service which deals with cache misses/hits and
  can persist data locally into say SQLite. It could also handle the look up
  data locally first, then do a remote get etc. All of this is transparent from
  a client perspective. We could also have a feature flag to enable/disable
  caching (in memory, local storage, etc).

Analysis with Gemini:

#+begin_src markdown
## User Story: Implement a High-Performance Reactive Caching Service for Reference Data

- **As a** system architect,
- **I want** a centralized Reference Data Service that manages data via a
  multi-tiered caching strategy (L1 Memory, L2 Disk) and incremental updates,
- **So that** my application can access large volumes of lookup data with
  near-zero latency, maintain thread safety without lock contention, and
  minimize network overhead.

---

### Acceptance Criteria

#### 1. Multi-Tiered "Smart" Loading Logic

- **Cold Start:** On initialization, the service must check the **L2 (SQLite)**
  cache for an existing "Page" snapshot.
- **As-Of Load:** If no L2 cache exists, the service must perform a full "As-Of"
  load from the remote connection for a specific timestamp.
- **Since (Delta) Load:** If an L2 snapshot exists, the service must only
  request "Since" updates (changes/deltas) from the remote connection based on
  the last known timestamp in the L2 store.
- **L2 Persistence:** All data fetched via "As-Of" or "Since" must be mapped
  back to its data representation and persisted to **SQLite** to facilitate
  future warm starts.

#### 2. Immutable L1 Cache (immer)

- **Thread Safety:** The L1 (in-memory) cache must use **immer** persistent data
  structures (`immer::map`) to provide lock-free read access for concurrent
  threads.
- **Structural Sharing:** Updates to the cache via "Since" loads must use
  immerâ€™s **transient/persistent** pattern to update only changed entities while
  sharing memory for unchanged data.
- **Atomic Swaps:** The service must provide an atomic mechanism to swap the
  "current" version of the page, ensuring readers always see a consistent
  snapshot.

#### 3. Reactive Subscription & Staleness

- **Notifications:** The service must subscribe to data change notifications.
- **Stale State Management:** Upon receiving a notification, the service must
  mark the relevant collection as stale and trigger an automated "Since" load to
  synchronize the L1 and L2 tiers.

#### 4. Data Mapping

- **Bi-Directional Mapping:** The service must utilize mappers to translate
  between raw data representations (for SQLite storage) and domain entities (for
  L1 memory storage).

---

### Technical Notes

- **L1:** `immer::map<std::string, std::shared_ptr<const Entity>>`.
- **L2:** SQLite table indexed by `page_id` and `timestamp` storing serialized
  blobs.
- **Performance Goal:** Reading from L1 should require no mutex locking, relying
  on the immutability of the underlying immer structure.
#+end_src

Links:

- [[https://github.com/arximboldi/immer][GH: immer]]: "immer is a library of persistent and immutable data structures
  written in C++. These enable whole new kinds of architectures for interactive
  and concurrent programs of striking simplicity, correctness, and performance."
- [[https://learn.microsoft.com/en-us/aspnet/core/performance/caching/memory?view=aspnetcore-10.0][Cache in-memory in ASP.NET Core]]: get ideas for the caching interfaces and
  requirements.

Merged stories:

*Add workspace as a container*

Core needs to have a container for all of the data stored within a context.

Actually, according to Data Priented Principles, we may not need it. This may be
a UI concept but not a code concept.

*** STARTED Add portfolio book tree widget                             :code:
    :LOGBOOK:
    CLOCK: [2026-02-21 Sat 13:01]--[2026-02-21 Sat 13:24] =>  0:23
    :END:

Add a combined =PortfolioBookTreeMdiWindow= that replaces the separate
flat-list views for portfolios and books with a unified hierarchical tree
scoped to the active session party. Clicking a node in the tree filters the
trade table on the right to show only trades within that branch.

Depends on: "Extend login flow with party selection" (party must be bound to
session before the tree can scope correctly).

**** Acceptance Criteria

- A single MDI window contains a horizontal splitter: tree on the left, trade
  table on the right.
- The tree renders the full portfolio hierarchy for the session party, with
  books as leaves under their parent portfolios.
- Node icons are visually distinct:
  - Real portfolio: =briefcase_20_filled=
  - Virtual portfolio (=is_virtual=1=): =briefcase_20_regular=
  - Trading book (=is_trading_book=1=): =book_open_20_filled=
  - Banking/Risk book (=is_trading_book=0=): =book_open_20_regular=
- Selecting any node filters the trade table to trades within that subtree.
- A breadcrumb label above the trade table shows the selected path.
- The reload button acquires a stale/pulsing indicator when a portfolio, book,
  or trade change notification arrives.
- Pagination widget present on the trade table (server-side).

**** Wireframes

***** Main layout

#+begin_example
â”Œâ”€ Portfolio Book Tree â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ [â†» Reload] â”‚ [+ Portfolio] [+ Book] [âœ Edit] [ğŸ—‘ Delete] [â± History]         â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ Party: (bound from session â€” read-only)                                        â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                              â”‚  Trades â€º Rates â€º IR â€º Rates_EUR_01            â”‚
â”‚ â–¼ â–£ Rates                    â”‚ â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”â”‚
â”‚   â–¼ â–£ Rates IR               â”‚ â”‚ Ext ID    â”‚ Type     â”‚ Cpty â”‚ Date â”‚ Matures â”‚â”‚
â”‚     â”œâ”€ â—‰ Rates_EUR_01 â—     â”‚ â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤â”‚
â”‚     â””â”€ â—‰ Rates_USD_01        â”‚ â”‚ UTI-0001  â”‚ IRS      â”‚ DBAG â”‚01-25 â”‚ 01-30   â”‚â”‚
â”‚   â–¼ â–£ Rates FX               â”‚ â”‚ UTI-0002  â”‚ FxFwd    â”‚ HSBC â”‚03-25 â”‚ 09-25   â”‚â”‚
â”‚     â””â”€ â—‹ FX_EUR_Vol_01       â”‚ â”‚ UTI-0003  â”‚ CapFloor â”‚ DBAG â”‚11-24 â”‚ 11-27   â”‚â”‚
â”‚                              â”‚ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜â”‚
â”‚ â–¼ â–¡ Regulatory [virtual]     â”‚  [â†] Page 1 of 3 [â†’]  Load All (12)            â”‚
â”‚   â–¼ â–¡ Rates Reg [virtual]    â”‚                                                  â”‚
â”‚     â”œâ”€ â—‰ Rates_EUR_01        â”‚                                                  â”‚
â”‚     â””â”€ â—‰ Rates_USD_01        â”‚                                                  â”‚
â”‚                              â”‚                                                  â”‚
â”‚ â–¼ â–£ Equities                 â”‚                                                  â”‚
â”‚   â””â”€ â—‹ Equities_EU_01        â”‚                                                  â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ 12 trades â€¢ Rates_EUR_01 (Trading Book)                                        â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
#+end_example

***** Icon legend

#+begin_example
  â–£  briefcase_20_filled     Real portfolio (non-virtual)
  â–¡  briefcase_20_regular    Virtual portfolio (is_virtual = 1)
  â—‰  book_open_20_filled     Trading book (is_trading_book = 1)
  â—‹  book_open_20_regular    Banking/Risk book (is_trading_book = 0)
  â—  stale indicator on selected node (pending reload)
#+end_example

***** Breadcrumb scope behaviour

#+begin_example
Click: â–£ Rates              â†’ Trades â€º Rates           (all trades in branch)
Click: â–£ Rates IR           â†’ Trades â€º Rates â€º IR      (subtree trades)
Click: â—‰ Rates_EUR_01       â†’ Trades â€º Rates â€º IR â€º Rates_EUR_01  (book trades)
Click: â–¡ Regulatory         â†’ Trades â€º Regulatory      (same trades, virtual view)
#+end_example

Virtual portfolios surface the same underlying trades as their real counterparts;
they are reporting overlays, not separate trade containers.

***** Proposed Qt component structure

#+begin_example
PortfolioBookTreeMdiWindow
â”œâ”€â”€ QToolBar
â”œâ”€â”€ QSplitter (horizontal)
â”‚   â”œâ”€â”€ QTreeView  â† PortfolioBookTreeModel (QAbstractItemModel)
â”‚   â”‚                 items: PortfolioTreeNode / BookTreeNode
â”‚   â””â”€â”€ QWidget (right panel)
â”‚       â”œâ”€â”€ Breadcrumb QLabel
â”‚       â”œâ”€â”€ QTableView â† ClientFilteredTradeModel
â”‚       â””â”€â”€ PaginationWidget
â””â”€â”€ Status QLabel
#+end_example

*** Polish business centre UI and data quality                         :code:

Several data quality and UI issues with business centres.

- WRLD should have UN flag and source = Internal.
- Hard-code NY* centres (NYFD, NYSE, USNY) during population to US country.
- Add a city name field parsed from descriptions (regex for parenthesised text).
- Do not display description column by default.
- Country should be a combo box.
- Fix missing country flags.
- Do not display coding scheme column by default.
- Move country column next to code.
- Reduce recorded_at column width.

#+begin_quote
This pull request focuses on enhancing the data quality and user interface for
business centres. It introduces a new 'city_name' field, derived from existing
descriptions, and integrates it across the database, C++ domain models, and the
Qt UI. Additionally, it includes specific data fixes for certain business centre
codes and refines the display of business centre information in the UI.

Highlights:

- SQL Data Enhancements: Added a 'city_name' column to the business centres
  reference data table and implemented logic to automatically derive city names
  from existing descriptions during data population.
- Data Quality Fixes: Hard-coded the country for specific business centre codes
  (NYFD, NYSE) to 'US' and ensured the correct US flag is displayed in the FpML
  artefact. The 'WRLD' system business centre was also updated with
  'source=Internal' and assigned a UN flag.
- C++ Model Updates: Incorporated the new 'city_name' field into the
  'business_centre' domain struct, its entity representation, mapper, and the
  binary messaging protocol, leading to a major protocol version bump to v38.0.
- Qt UI Improvements: Reordered columns in the business centre list view to
  prioritize 'Code', 'Country', and 'City', added a dedicated 'City' column, and
  set 'Description' and 'Coding Scheme' to be hidden by default. The 'Recorded
  At' column width was fixed, and the country selection combo box in the detail
  dialog was made non-editable, while also displaying the derived city name.
#+end_quote
*** Add high-watermark support                                         :code:

Whenever we request entities, we should also return the watermark for that
entity. This is the highest timestamp of all entities within a set (across all
pages). This is so we can redo the exact same query with an "as of" and get
exactly the same result set. Do some analysis with Claude on how best to do
this. Maybe we should always query as of so that we know what the watermark is
up front.

Notes:

- once we have watermark, we need to add a staleness indicator to all dialogs.
  This will require thresholds. If the data is older than X the staleness
  indicator goes yellow, older than Y it goes red.

*** Redesign Qt ImageCache invalidation strategy                       :code:

Note: this story should only be looked at after we move towards workspaces.

The current ImageCache invalidation approach is brittle and error-prone. When
datasets are published, the cache reload is triggered by pattern-matching
dataset codes (e.g., checking for "flag", "icon", "currenc", "countr" in the
code string). This is fragile because:

- New dataset types require updating the pattern matching logic
- The relationship between datasets and cached data is implicit
- Cache invalidation relies on string matching rather than proper metadata

Proposed improvements:

- Use artefact_type metadata instead of code string matching to determine if
  cache invalidation is needed
- Consider a more general cache invalidation framework that can be extended to
  other caches (ChangeReasonCache, etc.)
- Investigate using server-side notifications to trigger cache invalidation
  (similar to the notification system already in place)
- Document the caching strategy and invalidation rules

Acceptance criteria:

- Cache invalidation is based on structured metadata, not string patterns
- Adding new image-related datasets doesn't require code changes
- Cache invalidation logic is documented and maintainable

*** Replace parent combo boxes with server-side type-ahead search      :code:

The entity detail dialogs (party, counterparty) load all entities into a combo
box for parent selection using a single request with =offset=0, limit=1000=.
If the system has more than 1,000 entities, the dropdown silently truncates
results, meaning users cannot select the correct parent and the hierarchy tree
is incomplete. The same pattern exists for country image maps and lookup
fetchers.

The fix is to replace the plain =QComboBox= with a searchable type-ahead widget
backed by =QCompleter= that issues server-side search requests as the user
types. This is the scalable solution and avoids loading the full dataset into
memory.

Affected locations:

- =CounterpartyDetailOperations.cpp:117= - =load_all_entities()=
- =PartyDetailOperations.cpp:118= - =load_all_entities()=
- =EntityDetailDialog.cpp:346= - =loadCountryImageMap()=
- =LookupFetcher.cpp:80,145= - lookup reference data loading

Note: the =MdiWindow= list views already have proper server-side pagination
via =ClientCounterpartyModel= / =ClientPartyModel=; this issue only affects
detail dialog combo boxes and related data loading.

- Introduce a reusable =SearchableEntityComboBox= widget with =QCompleter=
- Add server-side search endpoints for parties and counterparties
- Replace =load_all_entities()= calls with on-demand search
- Consider the same approach for country and lookup fetcher if volumes warrant it

*** Filter counterparty dataset size for evaluation tenants            :code:

Evaluation tenants currently import too many counterparties from GLEIF data. Add
options to limit the dataset to a configurable percentage or count, providing
enough data to evaluate the system without overwhelming the tenant.

*** Improve tenant deletion safety and cascading                       :code:

Tenant deletion needs proper safeguards and cascading behaviour.

- Deleting any tenant should show an impact summary before proceeding.
- Deleting a tenant should trigger cascading deletion of associated parties.
- Deleting the root tenant should return an error (prevent accidental deletion).

*** Allow super admin to reset tenant admin accounts                   :code:

The super admin currently cannot reset a tenant admin account's password or
credentials. Add this capability to the account management UI.

*** Add tenant type management dialog                                  :code:

There is currently no UI to view or manage tenant types. Add a dialog accessible
from the administration menu to list, view, and edit tenant type reference data.

*** Add account permissions visibility and tabbed dialog               :code:

Users have no way to see what permissions an account has. The accounts dialog
also needs a tabbed layout to display all available information.

- Add a permissions tab showing effective permissions for the account.
- Use tabbed dialog layout (General, Permissions, Sessions, etc.).
- Clicking on a user should show profile details: admin sees full details, others
  see only key fields (email, etc.).

*** Add shell commands for parties and counterparties                  :code:

The shell currently has no commands for party or counterparty CRUD. Add list,
add, history, and delete commands following the existing shell entity pattern.

Related story: "Add sub-menus to shell".

*** Suppress staging dataset publication warnings                      :code:

Staging datasets (e.g. =gleif.lei_entities.small=, =gleif.lei_relationships.small=)
show confusing "No populate_function for artefact_type" warnings during bundle
publication. These datasets are dependencies that load into staging tables and
don't publish to production directly â€” this is working as designed. Suppress or
reclassify these log messages to avoid confusion.

*** Allow creating new connections from login dialog                   :code:

The login dialog should have a button or link to create a new server connection,
so users don't have to navigate to the connections dialog separately.

*** Add validation and ISO compliance flags for reference data         :code:

Several validation gaps and missing metadata in reference data entities.

- It is possible to create a country without a name; likely a currency too. Add
  required field validation.
- Fictional countries should have X prefixes (following ISO 3166 conventions).
- Add an "is ISO compliant" flag (or similar) for currencies and countries that
  are part of the ISO standard vs. custom/internal entries.

*** Standardise Qt window behaviour and UI consistency                 :code:

Several inconsistencies in window behaviour across the application.

- Remove maximise button from MDI child windows.
- Standardise window type: main entity windows should behave the same as
  history/detail dialogs (consistent minimise/maximise button behaviour).
- Generate button should only appear in "new" mode, not "edit".
- Add save button to currency list (needed for generation workflow).
- Add configuration option to disable quit confirmation dialog.
- Allow password visibility toggle in password input fields.

*** Improve session management and server-side housekeeping            :code:

Session tracking and lifecycle management needs improvement.

- Session should record whether telemetry is enabled or not.
- Send and receive byte counters are empty in sessions display.
- Server should periodically housekeep sessions: mark disconnected sessions as
  orphan, mark sessions as finished when connection drops.

*** Clicking on connection in status bar should provide info           :code:

Or maybe as a tooltip? whatever is idiomatic. Things to show:

- when never connected: nothing.
- when connected: server, bytes sent, received, status of connection.
- when disconnected: retries, disconnected since.

*** Reduce duplicated Qt code and clean up technical debt              :code:

Several areas of duplicated code and legacy artefacts that should be cleaned up.

- Qt network error message processing is duplicated across dialogs; extract into
  shared utility.
- Merge common functionality between entities in =ores.qt=.
- Raw SQL in image repository should be replaced with a database function.
- Remove legacy password salt field from accounts.
- Add =ores.analyser= to system model documentation.
- Bootstrap mode flag change does not generate a new version; fix versioning.

*** Expand repository test coverage and infrastructure                 :code:

Test coverage gaps and infrastructure improvements needed.

- No repository tests for change reason entity. Audit all entities for coverage.
- No generators for roles and permissions; add them.
- Test suites should log version at startup. Info script needs to grep log for
  version across all suites.

*** Add version comparison and revert improvements                     :code:

Improvements to entity version history and comparison features.

- In the history diff dialog, add a "from version" combo box that lets users
  compare against any previous version (not just the immediately preceding one).
- Revert-to-version should be a server-side operation taking current version and
  target version parameters.

*** Raise events for account profile updates                           :code:

Updating email from "My Account" does not raise an event. Account profile
changes should emit events through the event bus for consistency with other
entity modifications.

*** Add batch editing with staging workflow                        :analysis:

Investigate a workflow where users can "locally modify" multiple entities and
then save the batch in a single operation. Similar to git's staging concept. Need
to determine appropriate terminology and iconography for this feature. Consider:
what do we call the staged state? What icon represents "stage for save"?

*** Evaluate change reasons for role permission tables             :analysis:

Should role and permission junction tables have change reason support? Analyse
whether the audit trail benefit justifies the additional complexity for these
administrative tables.

*** Add HBAC support for books and portfolios                          :code:

Gemini:

#+begin_quote
In a professional trading system, you are describing Hierarchical Role-Based
Access Control (HRBAC). To make this idiomatic and scalable, you need to
decouple the "Who" (Users/Groups) from the "What" (Portfolios/Books) using an
Access Control List (ACL) that supports Inheritance.

Here is how to structure this to avoid the nightmare of manual user management.

1. The Domain Model: Groups and Roles

Instead of assigning a user directly to a book, you introduce a User Group
(e.g., "North America FX Traders").

- User Group: A collection of Users.
- Role: A collection of Permissions (e.g., View, Trade, Close_Book).
- Access Grant: The link that says Group A has Role X on Portfolio Y.

2. Permission Inheritance (The "Cascading" Rule)

This is the most critical part of your requirement: "Permissioned to a portfolio
= permissioned to all children."

*The Logic*

When a user attempts to access a Book, the system should check for a permission
record at:

- The Book itself.
- If not found, its parent Portfolio.
- If not found, its parent Business Unit, and so on up to the Party.

*The "Effective Permission" Calculation*

In your Qt UI or API, you calculate the Effective Permission.

If I am in the "Senior Managers" group and that group is assigned View access at
the Global Equities Portfolio level, I automatically see every book under it.

- Override Rule: Usually, an explicit "Deny" at a lower level beats an "Allow"
  from a higher level (though most trading systems stick to additive permissions
  for simplicity).

3. Idiomatic Table Structure

To support this in your Postgres schema (with your Staging/Master setup), you
need a permission table that points to your entity hierarchy.

| Column         | Description                                       |
|----------------+---------------------------------------------------|
| Subject_ID     | The ID of the User Group (e.g., "FX_Desk_Group"). |
| Object_Type    | PARTY, PORTFOLIO, or BOOK.                        |
| Object_ID      | The UUID of the specific entity.                  |
| Role_ID        | The Role (e.g., READ_ONLY, FULL_TRADER).          |
| Is_Inheritable | Boolean (usually defaults to True).               |

4. UI Implementation: The "Access" Tab

In your Organization Manager Qt screen, when you select a Portfolio or Book in
the tree, the detail pane should have an "Access Control" tab.

- Inherited Permissions List: A read-only list showing groups that have access
  because of a parent node (e.g., "Group: Risk_Admin (Inherited from: The
  House)").
- Explicit Permissions List: Where you add/remove groups specifically for this
  node.

5. Security and "The House" Context

Since your system runs in the context of "The House" (the Tenant), you need a
"God Role" (System Admin) that is implicitly permissioned at the Party (Root)
level. This ensures you never get locked out of a branch of the tree.

*The "Four-Eyes" for Permissions*

Because permissions are sensitive, changes to this table should also go through
your staging schema.

- Maker: Proposes adding "Group B" to "Portfolio C".
- Checker: Approves the grant.
- Audit: The temporal table tracks exactly when a user gained access to a
  specific bookâ€”crucial for regulatory "Who saw what" inquiries.
#+end_quote

*** Understanding Settlements and SSI                              :analysis:

This is a very complicated topic. We should try to summarise it and see what is
the smallest subset that we need in order to see full trade lifecycle.

Links:

- [[https://www.cslucas.com/user-guide/how-to-set-up-counterparty-ssi/][How to Set Up Counterparty SSI]]
- [[https://docs.oracle.com/cd/E99951_01/html/Settlements/Settlements_Manual_Intro_002.htm][Settlements Service]]

*** Add ISO 20022 Support                                              :code:

As per Gemini:

#+begin_quote
Summary Mapping for your C++ Logic

| Internal Event  | ISO 20022 Message | Action                                          |
|-----------------+-------------------+-------------------------------------------------|
| TradeExecuted   | fxtr.014          | Confirm terms with counterparty.                |
| Send Funds      | pacs.009          | Instruct the  bank to move cash.                |
| Check Progress  | pacs.002          | Update UI "Settlement Status" to 'In Progress'. |
| Funds Confirmed | camt.054          | Update UI to 'Settled'.                         |
| EOD Reconcile   | camt.053          | Verify internal ledger vs bank balance.         |
|                 |                   |                                                 |

Pro-Tip for your Implementation: Since you're using C++, don't try to build
every message at once:

- Start with pacs.009 (Sending money).
- Follow with pacs.002 (Handling the response).
- Add camt.053 (Reconciling at night).

*ISO 20022 Asset Class Mapping*

If you move beyond FX, you switch "prefixes." Here is how the ISO 20022 world is
carved up:

| Message Prefix | Asset Class / Domain  | Example Use Case                                     |
|----------------+-----------------------+------------------------------------------------------|
| fxtr           | Foreign Exchange      | "Spot, Forwards, NDFs, FX Swaps."                    |
| sese           | Securities Settlement | "Settlement of Equities, Bonds, ETNs."               |
| semt           | Securities Management | "Custody statements, holding reports."               |
| setr           | Securities Trade      | Trade capture/subscription for Mutual Funds.         |
| auth           | Regulatory Reporting  | "OTC Derivatives (IRS, CDS), Transaction reporting." |
| pacs           | Payments              | The cash resulting from any of the above.            |

*FPML vs ISO 20022*

For Swaps and other Derivatives, the messaging is split between Trade Reporting
and Lifecycle/Confirmation.

- auth (Authorities): In the modern MX world, Interest Rate Swaps are largely
  reported using the auth series (specifically under EMIR or MiFIR regulations).
  - auth.030: Derived from the "Trade Reporting" business area, used for
    Reporting of OTC derivatives.
- FpML (The "De Facto" standard): As we discussed earlier, while ISO 20022 has
  auth messages for regulation, FpML remains the industry standard for the
  actual bilateral confirmation of IRS trades. Most modern systems use FpML for
  the "contract" and then use pacs for the resulting cash flows.

| Feature         | FpML (Financial products Markup Language)                                   | ISO 20022 (MX)                                                          |
|-----------------+-----------------------------------------------------------------------------+-------------------------------------------------------------------------|
| Primary Domain  | "Derivatives & OTC Trades (Swaps, Options, Forwards)."                      | Payments & Securities Settlement.                                       |
| Focus           | "The economics of the trade (strike price, tenors, floating rate indexes)." | "The movement of value (sender, receiver, amount, intermediary banks)." |
| Lifecycle Stage | "Front-to-Middle Office: Execution, Affirmation, and Confirmation."         | "Back Office: Payment clearing, settlement, and reporting."             |
| Complexity      | Extremely deep. Can describe a 30-year complex interest rate swap.          | Broad. Designed to move money across any border or system.              |
#+end_quote

*** Extend login flow with party selection                             :code:

After authentication, look up the user's associated parties from
=account_parties=. If one party, auto-select. If multiple, return the party list
to the client for selection. The client displays a party picker widget. After
selection, compute the visible party set and bind to the session.

**** Acceptance Criteria

- Login response includes available parties.
- Party picker displayed when user has multiple parties.
- Selected party stored in session and displayed in application window (title
  bar shows =username @ party_name=).
- Party context immutable for session lifetime.

**** Design Notes

***** Protocol changes

Extend =login_response= (0x2006) with two fields appended to the wire format:

- =available_parties=: =vector<{uuid id, string name}>= â€” empty when 0 or 1
  party (auto-selected); populated when â‰¥2 parties.
- =selected_party_id=: =uuid= â€” non-nil only when the server auto-selected
  exactly one party; nil when the client must choose.

Add two new messages:

- =select_party_request= (0x2015): ={uuid party_id}=
- =select_party_response= (0x2016): ={bool success, string error_message}=

***** Server changes (=handle_login_request=)

The party resolution block (lines 488-520 of
=accounts_message_handler.cpp=) currently always auto-selects
=parties.front()=. Change to:

- 0 parties â†’ leave session unbound; no change.
- 1 party â†’ auto-select as now; set =selected_party_id= in response.
- â‰¥2 parties â†’ do NOT bind =party_id= yet; return =available_parties= list;
  leave session unbound until =select_party_request= arrives.

Add =handle_select_party_request=: validate chosen =party_id= is in
account's =account_parties=, bind =session->party_id=, recompute
=visible_party_ids=, update both in-memory session and DB record.

***** Client changes

- =LoginResult= gains =available_parties= and =selected_party_id=.
- =ClientManager= gains =current_party_id_=, =current_party_name_=, and a
  =selectParty(uuid)= method.
- =LoginDialog::onLoginResult= gains a new branch after the password-reset
  check: if =available_parties.size() > 1=, show =PartyPickerDialog= (modal,
  same pattern as =ChangePasswordDialog=). On reject â†’ disconnect, re-enable
  form. On accept â†’ call =clientManager_->selectParty(id)=.
- Main window title set to =username @ party_name= after login completes.

***** Session state machine

#+begin_example
Not connected
  â†’ Connected
  â†’ Authenticated  (party-unbound, only when â‰¥2 parties)
  â†’ Party selected (fully operational)

0 or 1 party: Authenticated â†’ Party selected in one step (no picker shown).
#+end_example

*** Add party role scheme entity                                       :code:

The following is the analysis for adding support to party schemes.

Contains a code representing a related party role. This can be extended to
provide custom roles.

- Obtained on 2025-11-10.
- Version 4-1.
- URL: http://www.fpml.org/coding-scheme/party-role-4-1.xml

Code
Description

- Code: Accountant
- Description: Organization responsible for preparing the accounting for the
  trade.

- Code: Allocation
- Description: Agent The organization responsible for supplying the allocations
  for a trade to be allocated to multiple accounts/organizations.

- Code: Arranging
- Description: Broker The organization that arranged the trade, i.e. brought
  together the counterparties. Synonyms/Alternatives: Inter-dealer broker,
  agent.

- Code: Beneficiary
- Description: Organization that suffers the economic benefit of the trade. The
  beneficiary may be distinct from the principal/counterparty - an example
  occurs when a hedge fund trades via a prime broker; in this case the principal
  is the prime broker, but the beneficiary is the hedge fund. This can be
  represented as a payer/receiver account in the name of the hedge fund, but it
  is also possible to add the party role of "Beneficiary" at the
  partyTradeInformation level.

- Code: Booking
- Description: Party The entity for which the organization supporting the
  trade's processing has booked/recorded the trade. This is used in
  non-reporting workflows situations in which the trade doesn't need to be
  reported but a firm still wants to specify their own side.

- Code: Buyer
- Description: Acquirer of the legal title to the financial instrument. In the
  case of an option, the buyer is the holder of the option. In the case of a
  swap or forward, the buyer will be determined by industry best practice. This
  does not refer to an investor or investment manager or other organization on
  what is typically called the "Buy side"; for that, see the "Client" role.
  Corresponds to "Buyer" as defined in certain regulations such as ESMA MiFID
  II/MIFIR RTS 22 field 9.

- Code: Buyer
- Description: DecisionMaker The party or person who, having legal authority to
  act on behalf of the trade counterparty acting as Buyer as defined in this
  coding scheme, made the decision to acquire the financial instrument.
  Corresponds to "buyer decision maker" as defined in ESMA's MIFIR RTS 23
  report. This does not refer to the decision maker for what is traditionally
  called the "Buy side"; for that, see the "Client Decision Maker" role.

- Code: Clearing
- Description: Client An organization that clears trades through a clearing
  house, via a clearing broker (member of the clearing house) who acts as an
  agent on its behalf. The term "client" refers to the organization's role in
  the clearing process in relation to its clearing broker, and not whether it is
  a price maker or taker in the execution process.

- Code: Clearing
- Description: ExceptionParty A party to the trade that claims a clearing
  exception, such as an end-user exception under Dodd-Frank Act provisions.

- Code: Clearing
- Description: Firm Organization that submits the trade to a clearing house on
  behalf of the principal. Synonyms/alternates: Futures Commission Merchant
  (FCM), Clearing Broker, Clearing Member Firm. Some implementations use
  "Clearing Broker" as synonym.

- Code: Clearing
- Description: Organization The organization that acts as a central counterparty
  to clear a derivatives contract. This is used to represent the role of Central
  Counterparties (CCPs) or Derivative Clearing Organizations (DCOs). Sometimes
  called "ClearingService". Some implementations also use the term "Clearer".

- Code: Client
- Description: Client as defined under ESMA MIFIR. This is generally the
  investor or other client of an investment firm, and is synonymous with the
  Beneficiary in many circumstances.

- Code: Client
- Description: DecisionMaker The party or person who, having legal authority to
  act on behalf of a trade counterparty, made the decision to acquire or sell
  the financial instrument.

- Code: Confirmation
- Description: Platform Organization serving as a financial intermediary for the
  purposes of electronic confirmation or providing services for post-processing
  of transactional data.

- Code: Contractual
- Description: Party A party to a contractual document. If the intended usage
  relates to the context of the trade lifecycle, more specific annotations have
  been defined which might be more appropriate.

- Code: Counterparty
- Description: An economic counterparty to the trade. Synonym: principal.

- Code: Counter
- Description: PartyAffiliate Organization offiially attached to the
  counterparty. e.g. partner, branch, subsidiary.

- Code: Counter
- Description: PartyUltimateParent The topmost entity or organization, within
  the corporate hierarchy, responsible for the reporting party.

- Code: Credit
- Description: SupportProvider Organization that enhances the credit of another
  organization (similar to guarantor, but may not fully guarantee the
  obligation).

- Code: Custodian
- Description: Organization that maintains custody of the asset represented by
  the trade on behalf of the owner/principal.

- Code: Data
- Description: Submitter Entity submitting the transaction report to the
  competent authority.

- Code: Disputing
- Description: Party Organization that is disputing the trade or transaction.

- Code: Document
- Description: Repository A marketplace organization which purpose is to
  maintain document records. If the intended usage relates to the context of the
  trade lifecycle, more specific annotations have been defined which might be
  more appropriate.

- Code: Executing
- Description: Broker The (generally sell-side) organization that executed the
  trade; the price-making party.

- Code: Executing
- Description: Entity Entity executing the transaction. If the transaction is
  executed directly by the reporting party, it will be the reporting party. If
  it is executed by an execution agent or an affiliated party on behalf of the
  reporting party, it will be that affiliate or agent.

- Code: Execution
- Description: Agent The (generally buy-side) organization that acts to execute
  trades on behalf of an investor. Typically this is an investment manager or
  asset manager, and also makes the investment decisions for the investor. If
  required, a separate InvestmentDecision role can be specified to distinguish
  that the party making the investment decision is different.

- Code: Execution
- Description: Facility The facility, exchange, or market where the trade was
  executed. Synonym: Swap Execution Facility, Designated Contract Market,
  Execution Venue.

- Code: Guarantor
- Description: Organization that backs (guarantees) the credit risk of the
  trade.

- Code: Margin
- Description: Affiliate Margin affiliate as defined by U.S. margin and capital
  rules Â§23.151.

- Code: Order
- Description: Transmitter The entity transmitting the order to the reporting
  firm. Synonym: Transmitting Firm.

- Code: Prime
- Description: Broker The organization that takes on or took on the credit risk
  for this trade by stepping in between the two economic parties (without a
  central counterparty clearing mechanism).

- Code: Prior
- Description: TradeRepository The trade repository at which the trade was
  reported previous to the current trade repository.

- Code: PTRR
- Description: CompressionProvider A party providing a post trade risk reduction
  service in the form of compression.

- Code: PTRR
- Description: RebalancingProvider A party providing a post trade risk reduction
  service in the form of portfolio rebalancing.

- Code: Publication
- Description: Venue The reporting service (whether trade repository, market
  data service, or exchange/facility/venue data distribution service) that
  published the report of this trade.

- Code: Reporting
- Description: Party The party with the regulatory responsibility to report this
  trade.

- Code: Reporting
- Description: PartyAffiliate Organization offiially attached to the reporting
  party e.g. partner, branch, subsidiary.

- Code: Reporting
- Description: PartyUltimateParent The topmost entity or organization, within
  the corporate hierarchy, responsible for the reporting party.

- Code: Seller
- Description: A counterparty in a trade, which performs in one of the following
  capacities: 1) it transfers or agrees to transfer in the future an instrument
  or title to that instrument in exchange for payment, 2) it writes a
  derivatives instrument such as an option or a swap in which it provides risk
  protection to the buyer. This does not refer to the broker/dealer or other
  organization on what is typically called the "Sell side"; for that, see the
  "Executing Broker" role. Corresponds to "Seller" as defined in certain
  regulations such as ESMA MiFID II/MIFIR RTS 22 field 16.

- Code: Seller
- Description: DecisionMaker The party or person who, having legal authority to
  act on behalf of the trade counterparty acting as Seller as defined in this
  coding scheme, made the decision to sell the financial instrument. Corresponds
  to "seller decision maker" as defined in ESMA's MIFIR RTS 23 report. This does
  not refer to the decision maker for what is traditionally called the "Sell
  side"; for that, see the "Trader" person role.

- Code: Settlement
- Description: Agent The organization that makes or receives payments on behalf
  of the given principal party.

- Code: Trade
- Description: Repository An organization that maintains records of the trade
  for regulatory reporting purposes.

- Code: Trade
- Description: Source The organization that originally supplied the record of
  the trade. In the context of regulatory reporting, it is the submitter of the
  trade record to a regulator or TR.

- Code: Trading
- Description: Manager The entity responsible for managing the
  assets/investments of this party. Synonnym: Asset Manager, Investment Manager,
  Trading Advisory.

- Code: Trading
- Description: Partner An entity with which this party trades from time to time,
  ie. with which it acts as a counterparty on some transactions. This role is
  used for static reference data, not individual transactions.


*** Accounts need to have a human or robot field                       :code:

Look for correct terminology (actor type?).


*** Add sub-menus to shell                                             :code:

There are a lot of entries in the shell main menu, we need to group them. These
could be based on the component.

Notes:

- shell has no parties or counterparties commands.
- It should be possible to set the "output type" or format in the shell, from
  json to table. Find the correct terminology for this.

*** System provisioner needs an icon                                   :code:

Dialog is using default ORE icon.

*** Add a organisation type scheme entity                              :code:

Indicates a type of organization.

- Obtained on 2016-06-13
- Version 2-0
- URL: http://www.fpml.org/coding-scheme/organization-type-2-0.xml

- Code: MSP
- Name: Major Swap Participant
- Description: A significant participant in the swaps market, for example as
  defined by the Dodd-Frank Act.

- Code: NaturalPerson
- Name: Natural Person
- Description: A human being.

- Code: non-SD/MSP
- Name: Non Swap Dealer or Major Swap Participant
- Description: A firm that is neither a swap dealer nor a major swaps participant under the Dodd-Frank Act.

- Code: SD
- Name: Swap Dealer
- Description: Registered swap dealer.

*** Add currency and country party-visibility junctions                :code:

Add junction tables (=party_currencies=, =party_countries=) that control which
currencies and countries a given party can see and use. The underlying reference
data definitions remain shared at the tenant level; only visibility is
per-party.

**** Acceptance Criteria

- Junction tables created with proper constraints.
- Party-scoped queries for currencies and countries filter through junctions.
- Default: all currencies/countries visible to all parties (opt-in restriction).

*** Update currency details to use tabs                                :code:

We need a main tab with the currency related properties, then a "system" tab
with temporal data which is read-only even on edit and a "image" tab with the
image used to represent the currency. It could also contain some description or
notes.

*** Currencies: Country relationship                                   :code:

At present currencies are linked to flags directly via an image id. We should
also be linked to a country, where such a linkage exists.

*** Currencies: Currency Taxonomy Enrichment                           :code:

- Goal: Enhance the ores_refdata_currencies_tbl to support logical grouping,
  reporting, and basic behavior defaults.
- Requirements:
  - Field 1: asset_class (Enum/Varchar)
    Purpose: Defines the nature of the instrument.
    Allowed Values: fiat, commodity (for XAU/XAG), synthetic, supranational.
  - Field 2: market_tier (Enum/Varchar)
    Purpose: Drives UI priority, liquidity expectations, and risk limits.
    Allowed Values: majors (g10), emerging, exotic, frontier, historical.
- Example Entries:
  : USD | fiat | g10
  :  BRL | fiat | emerging

*** Currencies: Party-Specific Settlement Rules                        :code:

- Goal: Define the "Where." This models what a specific "House" entity (or
  child) is capable of doing.
- Table: =ores_refdata_settlement_capabilities=.
- Logic: Does "London Desk" have a local Vostro account for "BRL"?

| Field Name              | Type       | Description                                                                        |
|-------------------------+------------+------------------------------------------------------------------------------------|
| capability_id           | UUID       | PK                                                                                 |
| party_id                | INT/FK     | Reference to internal parties. This can be "The House" or a specific child entity. |
| currency_code           | CHAR(3)/FK | Reference to =ores_refdata_currencies_tbl=.                                        |
| can_settle_physically   | Boolean    | If true we can settle in this currency.                                            |
| can_cash_settle         | Boolean    | If true, we can settle in cash on another currency.                                |
| default_settlement_mode | ENUM       | physical (Deliverable) or cash_settled (Non-Deliverable/NDF).                      |
| is_active               | BOOL       | To disable capabilities if an account is frozen or closed.                         |

Then, to determine which account to use to settle we need something like
=ores_refdata_party_nostro_accounts=:

| Field          | Description                                             |
|----------------+---------------------------------------------------------|
| party_id       | Which branch of yours owns this account?                |
| currency_code  | The currency of the account.                            |
| agent_bank_id  | The external bank (e.g., HSBC, Citi).                   |
| account_number | The actual IBAN/Account string.                         |
| is_primary     | Boolean to tell the system which one to use by default. |
| purpose        | "ENUM: General, CLS, Intercompany, Custody."            |

This tells us what account to use when settlement comes. We cannot have a
capability without at least one account.

Then, for each currency which can be cash settled, we need to know into which
currencies they can be cash settled. For that we have
=ores_refdata_settlement_cash_options=. This is a Junction Table that defines
the valid "Settlement Pairs." This table answers: "If we are cash-settling
Currency X, what are the allowed 'Destination' currencies for this House
Entity?"

| Schema              | FieldType | Description                                                       |
|---------------------+-----------+-------------------------------------------------------------------|
| capability_id       | FK        | Links to =ores_refdata_settlement_capabilities=.                  |
| settlement_currency | CHAR(3)   | The "Destination" currency (e.g., USD, EUR).                      |
| is_primary          | BOOLEAN   | The default currency the desk prefers to use for NDFs.            |
| fixing_source_id    | FK        | Which index provides the rate to convert X to the Settlement CCY? |

If cash settled is true, we must have a corresponding entry in this table.

**** The "Relative" Logic Requirement:

The system must perform a Hierarchical Lookup: Check for a rule specific to the
Child Party + Currency. If not found, check for a rule for The House +
Currency. If still not found, default to physical for g10 and cash_settled for
exotic.

*** Currencies: Contractual Settlement (The "Agreements" Table)        :code:

- Goal: Define the "How." This is the bridge you mentioned for specific
  counterparties.
- Table: =ores_refdata_settlement_agreements.=
- Logic: "Even though London can settle NDFs, for this specific Hedge Fund, we
  always settle in USD."

Fields:

| Schema                 | Description             |
|------------------------+-------------------------|
| party_id               | Our side.               |
| counterparty_id        | Their side.             |
| currency_code          | The currency.           |
| agreed_settlement_type | NDF, Physical, Net_USD. |
| agreement_ref          | e.g., "ISDA-2023-GS".   |



* Footer

| Previous: [[id:1B387E8C-8EC1-4C2A-A321-1593C35A9A77][Sprint Backlog 12]] |
