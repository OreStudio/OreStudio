:PROPERTIES:
:ID: A9FB22A0-E067-46D4-A217-AF10C20DFB90
:END:
#+title: Sprint Backlog 08
#+options: <:nil c:nil ^:nil d:nil date:nil author:nil toc:nil html-postamble:nil
#+todo: STARTED | COMPLETED CANCELLED POSTPONED BLOCKED
#+tags: { code(c) infra(i) analysis(n) agile(a) }
#+startup: inlineimages

* Sprint Mission

- implement reference data.

* Stories

** Active

#+begin: clocktable :maxlevel 3 :scope subtree :tags t :indent nil :emphasize nil :scope file :narrow 75 :formula % :block today
#+TBLNAME: today_summary
#+CAPTION: Clock summary at [2026-01-01 Thu 19:08], for Thursday, January 01, 2026.
|      | <75>                           |        |      |      |       |
| Tags | Headline                       | Time   |      |      |     % |
|------+--------------------------------+--------+------+------+-------|
|      | *Total time*                   | *2:34* |      |      | 100.0 |
|------+--------------------------------+--------+------+------+-------|
|      | Stories                        | 2:34   |      |      | 100.0 |
|      | Active                         |        | 2:34 |      | 100.0 |
| code | Rerun SQL scripts from scratch |        |      | 2:34 | 100.0 |
#+end:

#+begin: clocktable :maxlevel 3 :scope subtree :tags t :indent nil :emphasize nil :scope file :narrow 75 :formula %
#+TBLNAME: sprint_summary
#+CAPTION: Clock summary at [2026-01-01 Thu 19:08]
|       | <75>                                  |        |      |      |       |
| Tags  | Headline                              | Time   |      |      |     % |
|-------+---------------------------------------+--------+------+------+-------|
|       | *Total time*                          | *6:06* |      |      | 100.0 |
|-------+---------------------------------------+--------+------+------+-------|
|       | Stories                               | 6:06   |      |      | 100.0 |
|       | Active                                |        | 6:06 |      | 100.0 |
| agile | Sprint and product backlog refinement |        |      | 1:05 |  17.8 |
| code  | Rerun SQL scripts from scratch        |        |      | 5:01 |  82.2 |
#+end:

*** STARTED Sprint and product backlog refinement                     :agile:
    :LOGBOOK:
    CLOCK: [2025-12-31 Wed 10:21]--[2025-12-31 Wed 11:26] =>  1:05
    :END:

Updates to sprint and product backlog.

#+begin_src emacs-lisp :exports none
;; agenda
(org-agenda-file-to-front)
#+end_src

#+name: pie-stories-chart
#+begin_src R :var sprint_summary=sprint_summary :results file graphics :exports results :file sprint_backlog_08_stories_pie_sorted.png :width 1920 :height 1080
library(conflicted)
library(ggplot2)
library(tidyverse)
library(tibble)

# Filter to only rows with actual story data (non-empty Tags column)
clean_sprint_summary <- sprint_summary %>% dplyr::filter(Tags != "")
stories <- unlist(clean_sprint_summary[2])
percent_values <- as.numeric(unlist(clean_sprint_summary[6]))

# Create a data frame and explicitly sort the stories by defining factor levels
df <- data.frame(
  stories = stories,
  percent = percent_values
) %>%
  # 1. Sort the data frame by percentage in descending order
  arrange(desc(percent)) %>%
  # 2. Convert 'stories' to a factor, setting the levels based on the sorted order.
  # This makes the order of the slices explicit for ggplot.
  mutate(
    stories = factor(stories, levels = stories),
    lab.pos = cumsum(percent) - 0.5 * percent
  )

# Manually selected colors to resemble the screenshot
custom_palette <- c(
  "#21518f", "#f37735", "#ffc425", "#81b214", "#d7385e",
  "#662e91", "#00a9ae", "#5c5c5c", "#a0c6e0", "#f8b195",
  "#ffe385", "#bde0fe", "#c5e0d4", "#e0b8a0", "#a56f8f",
  "#7a448a", "#4a9a9b", "#9b9b9b", "#6fa8dc", "#f7a072",
  "#ffd166", "#99d98c", "#ef5d60", "#9d529f", "#3a86ff",
  "#c1d6e1", "#f9e0ac", "#c2d6a4", "#e69a8d", "#a07d9f"
)

# Ensure the palette has enough colors for all stories.
if (length(custom_palette) < length(df$stories)) {
  warning("Not enough custom colors for all stories. Colors will repeat.")
  custom_palette <- rep(custom_palette, length.out = length(df$stories))
}


p <- ggplot(df, aes(x = "", y = percent, fill = stories)) +
  geom_bar(width = 1, stat = "identity") +
  coord_polar("y", start = 0) +
  scale_fill_manual(values = custom_palette) +
  ggtitle("Sprint 8: Resourcing per Story")  +
  labs(x = NULL, y = NULL, fill = "Stories") +
  theme_minimal() +
  theme(
    axis.text.x = element_blank(),
    panel.grid.major = element_blank(),
    panel.grid.minor = element_blank(),
    plot.title = element_text(hjust = 0.5, size = 18),
    legend.position = "right",
    legend.title = element_text(size = 14),
    legend.text = element_text(size = 12)
  )

print(p)
#+end_src

#+RESULTS: pie-stories-chart
[[file:sprint_backlog_08_stories_pie_sorted.png]]

#+name: stories-chart
#+begin_src R :var sprint_summary=sprint_summary :results file graphics :exports results :file sprint_backlog_08_stories.png :width 1200 :height 650
library(conflicted)
library(grid)
library(tidyverse)
library(tibble)

# Filter to only rows with actual story data (non-empty Tags column)
clean_sprint_summary <- sprint_summary %>% dplyr::filter(Tags != "")
names <- unlist(clean_sprint_summary[2])
values <- as.numeric(unlist(clean_sprint_summary[6]))

# Create a data frame.
df <- data.frame(
  cost = values,
  stories = factor(names, levels = names[order(values, decreasing = FALSE)]),
  y = seq(length(names)) * 0.9
)

# Setup the colors
blue <- "#076fa2"

p <- ggplot(df) +
  aes(x = cost, y = stories) +
  geom_col(fill = blue, width = 0.6) +
  ggtitle("Sprint 8: Resourcing per Story") +
  xlab("Resourcing (%)") + ylab("Stories") +
  theme(text = element_text(size = 15))

print(p)
#+end_src

#+RESULTS: stories-chart
[[file:sprint_backlog_08_stories.png]]

#+name: tags-chart
#+begin_src R :var sprint_summary=sprint_summary :results file graphics :exports results :file sprint_backlog_08_tags.png :width 600 :height 400
library(conflicted)
library(grid)
library(tidyverse)
library(tibble)

# Filter to only rows with actual story data (non-empty Tags column)
clean_sprint_summary <- sprint_summary %>% dplyr::filter(Tags != "")
names <- unlist(clean_sprint_summary[1])
values <- as.numeric(unlist(clean_sprint_summary[6]))

# Create a data frame.
df <- data.frame(
  cost = values,
  tags = names,
  y = seq(length(names)) * 0.9
)
# factor(names, levels = names[order(values, decreasing = FALSE)])

df2 <- setNames(aggregate(df$cost, by = list(df$tags), FUN = sum),  c("cost", "tags"))
# Setup the colors
blue <- "#076fa2"

p <- ggplot(df2) +
  aes(x = cost, y = tags) +
  geom_col(fill = blue, width = 0.6) +
  ggtitle("Sprint 8: Resourcing per Tag") +
  xlab("Resourcing (%)") + ylab("Story types") +
  theme(text = element_text(size = 15))

print(p)
#+end_src

#+RESULTS: tags-chart
[[file:sprint_backlog_08_tags.png]]

*** OCR scan notebooks for this sprint                                :infra:

We need to scan all of our finance notebooks so we can use them with AI. Each
sprint will have a story similar to this until we scan and process them all.

*** Add AI generated sprint summary                                   :infra:

At the end of the sprint, generate the sprint summary using the prompt.

*** Sprint Demo                                                       :infra:

Time spent doing the demo. This is the first one so it will be very basic.

**** Presentation

***** ORE Studio v0.0.4, "Fazenda Camilunga"

    Marco Craveiro
    Moimba Software Engineering
    Released on 16th November 2025



*** COMPLETED Rerun SQL scripts from scratch                           :code:
    :LOGBOOK:
    CLOCK: [2026-01-01 Thu 22:30]--[2026-01-01 Thu 23:59] =>  1:29
    CLOCK: [2026-01-01 Thu 20:15]--[2026-01-01 Thu 21:10] =>  0:55
    CLOCK: [2026-01-01 Thu 19:08]--[2026-01-01 Thu 19:35] =>  0:27
    CLOCK: [2026-01-01 Thu 17:29]--[2026-01-01 Thu 19:05] =>  1:36
    CLOCK: [2026-01-01 Thu 16:30]--[2026-01-01 Thu 17:28] =>  0:58
    CLOCK: [2025-12-31 Wed 11:27]--[2025-12-31 Wed 13:54] =>  2:27
    :END:

We need to validate the scripts and fix all issues we find.

#+begin_quote
This pull request significantly refines the integration of TimescaleDB within
the ORES SQL schema, making it more adaptable to different TimescaleDB license
tiers and ensuring robust functionality. It introduces runtime license detection
to intelligently enable or disable advanced TimescaleDB features, alongside
implementing per-database extension installation for PostgreSQL. Furthermore,
this PR substantially expands the project's documentation by adding detailed
architectural overviews for the ores.assets and ores.comms.analyser components,
and a comprehensive guide to the overall SQL schema, enhancing clarity and
maintainability for developers and users alike.

Highlights:

- Enhanced TimescaleDB Integration: The system now correctly integrates with
  both Apache and Timescale license editions of TimescaleDB, dynamically
  adjusting features based on the detected license.
- Per-Database Extension Installation: PostgreSQL extensions are now installed
  on a per-database basis, ensuring proper functionality within each ORES
  database instance, including the template.
- Runtime License Detection: SQL scripts now include runtime checks for the
  TimescaleDB license, gracefully skipping advanced features like compression,
  retention policies, and continuous aggregates if only the Apache license is
  present.
- New Component Documentation: Detailed Org-mode documentation has been added
  for the ores.assets and ores.comms.analyser components, outlining their
  architecture, domain types, and usage.
- Comprehensive SQL Schema Documentation: The ores.sql.org file has been added,
  providing extensive documentation on the ORES SQL schema, including
  architecture, design patterns, PostgreSQL extensions (especially TimescaleDB),
  and database creation processes. Schema Prefix for TimescaleDB Functions:
  TimescaleDB function calls in sessions_create.sql and session_stats_create.sql
  now explicitly use the public. schema prefix to avoid issues when search_path
  is set to 'ores'.
#+end_quote

*** STARTED Run qt client and validate all new features                :code:

We added quite a few new features during the holidays but due to the laptop
constraints we could not validate them properly. Check they all work correctly
and fix what needs fixing. Features:

- session monitoring
- flags display
-

*** Remove seeders in code                                             :code:

Since we have to seed from SQL scripts, having code seeding as well is just
confusing.

*** Rename =ores.shell= to =ores.comms.shell=                          :code:

The shell is specific to the binary protocol.

* Footer

| Previous: [[id:154212FF-BB02-8D84-1E33-9338B458380A][Version Zero]] |
