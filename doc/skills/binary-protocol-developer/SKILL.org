:PROPERTIES:
:ID: f8a12c4e-9b3d-4e5f-a1c2-8d7e6f5a4b3c
:END:
#+title: Binary Protocol Developer
#+author: Marco Craveiro
#+options: <:nil c:nil todo:nil ^:nil d:nil date:nil author:nil toc:nil
#+startup: inlineimages
#+export_exclude_tags: noexport

#+begin_export markdown
---
name: binary-protocol-developer
description: Guide for extending and modifying the ORE Studio binary messaging protocol.
license: Complete terms in LICENSE.txt
---
#+end_export

* When to use this skill

When you need to add new message types, modify existing protocol messages, or
make any changes to the binary messaging protocol used for client-server
communication in ORE Studio.

* How to use this skill

1. Determine if your change is breaking (major version bump) or backward
   compatible (minor version bump).
2. Follow the detailed instructions to add or modify protocol messages.
3. Update the protocol version appropriately.
4. Build and test the changes.

* Detailed instructions

** Understanding the protocol architecture

The ORE Studio binary protocol is organized into subsystems, each with a
dedicated message type range:

| Subsystem   | Range           | Example                                                    |
|-------------+-----------------+------------------------------------------------------------|
| Core        | 0x0000 - 0x0FFF | handshake, error, ping/pong, subscribe, notification       |
| Refdata     | 0x1000 - 0x1FFF | currencies, currency history, countries                    |
| IAM         | 0x2000 - 0x2FFF | login, accounts, lock/unlock, rbac, signup, sessions       |
| Variability | 0x3000 - 0x3FFF | feature flags, feature flag history                        |
| Assets      | 0x4000 - 0x4FFF | images, image management                                   |
| Telemetry   | 0x5000 - 0x5FFF | log records, telemetry stats                               |
| DQ          | 0x6000 - 0x6FFF | catalogs, datasets, coding schemes, dimensions, change mgmt|

Protocol definitions are located in:

- [[proj:projects/ores.comms/include/ores.comms/messaging/message_types.hpp][ores.comms/messaging/message_types.hpp]] - Message type enum and protocol
  version
- =projects/COMPONENT/include/COMPONENT/messaging/*_protocol.hpp= - Protocol
  structs for each subsystem, e.g. [[proj:projects/ores.iam/include/ores.iam/messaging/login_protocol.hpp][ores.iam/messaging/login_protocol.hpp]]

** Step 1: Determine version impact

Before making changes, understand the versioning requirements:

*** Major version bump (breaking change)

Bump the major version and reset minor to 0 when:

- Removing fields from existing request/response structs
- Changing the order of serialized fields
- Changing field types in a way that changes wire format
- Removing message types
- Changing the semantics of existing fields

*** Minor version bump (backward compatible)

Bump the minor version when:

- Adding new message types
- Adding new optional fields to the end of existing structs
- Adding new subsystems

** Step 2: Update message types enum

Add new message types to [[proj:projects/ores.comms/include/ores.comms/messaging/message_types.hpp][message_types.hpp]]:

#+begin_src cpp
enum class message_type {
    // ... existing types ...

    // Accounts subsystem messages (0x2000 - 0x2FFF)
    your_new_request = 0x2015,   // Use next available hex value
    your_new_response = 0x2016,

    last_value
};
#+end_src

*** Naming conventions for message types

- Request/response pairs: =action_request= / =action_response=
- Use snake_case for all enum values
- Requests end with =_request=, responses end with =_response=
- Use verbs that describe the action: =create_=, =list_=, =delete_=, =get_=,
  =update_=, =lock_=, =unlock_=

** Step 3: Create protocol structs

Create request and response structs in the appropriate protocol header.

*** File organization

Protocol files are named by feature:

- =projects/COMPONENT/include/COMPONENT/messaging/FEATURE_protocol.hpp=
- =projects/COMPONENT/src/messaging/FEATURE_protocol.cpp=

For example:

- [[proj:projects/ores.iam/include/ores.iam/messaging/account_protocol.hpp][account_protocol.hpp]] - Account CRUD operations
- [[proj:projects/ores.iam/include/ores.iam/messaging/login_protocol.hpp][login_protocol.hpp]] - Authentication operations
- [[proj:projects/ores.iam/include/ores.iam/messaging/bootstrap_protocol.hpp][bootstrap_protocol.hpp]] - Initial admin setup

*** Struct naming conventions

- Struct names match the enum value exactly: =lock_account_request=,
  =lock_account_response=
- Use =final= keyword on all protocol structs
- Requests contain input data, responses contain results

*** Request struct pattern

#+begin_src cpp
/**
 * @brief Request to perform action on resource.
 *
 * Describe authorization requirements if any.
 */
struct action_resource_request final {
    boost::uuids::uuid resource_id;  // Primary identifier
    // Additional fields as needed

    /**
     * @brief Serialize request to bytes.
     *
     * Format:
     * - 16 bytes: resource_id (UUID)
     * - N bytes: additional fields...
     */
    std::vector<std::byte> serialize() const;

    /**
     * @brief Deserialize request from bytes.
     */
    static std::expected<action_resource_request, comms::messaging::error_code>
    deserialize(std::span<const std::byte> data);
};

std::ostream& operator<<(std::ostream& s, const action_resource_request& v);
#+end_src

*** Response struct pattern

#+begin_src cpp
/**
 * @brief Response indicating operation result.
 */
struct action_resource_response final {
    bool success = false;
    std::string error_message;  // Empty on success
    // Additional result fields as needed

    /**
     * @brief Serialize response to bytes.
     *
     * Format:
     * - 1 byte: success (boolean)
     * - 2 bytes: error_message length
     * - N bytes: error_message (UTF-8)
     */
    std::vector<std::byte> serialize() const;

    /**
     * @brief Deserialize response from bytes.
     */
    static std::expected<action_resource_response, comms::messaging::error_code>
    deserialize(std::span<const std::byte> data);
};

std::ostream& operator<<(std::ostream& s, const action_resource_response& v);
#+end_src

*** Adding message_traits specialization

After defining the request/response pair, add a =message_traits= specialization
to enable the simplified =process_request= API. This should be added at the end
of the protocol header, in the =ores::comms::messaging= namespace:

#+begin_src cpp
namespace ores::comms::messaging {

/**
 * @brief Message traits specialization for action_resource_request.
 */
template<>
struct message_traits<COMPONENT::messaging::action_resource_request> {
    using request_type = COMPONENT::messaging::action_resource_request;
    using response_type = COMPONENT::messaging::action_resource_response;
    static constexpr message_type request_message_type =
        message_type::action_resource_request;
};

}
#+end_src

Include the traits header at the top of your protocol file:

#+begin_src cpp
#include "ores.comms/messaging/message_traits.hpp"
#+end_src

The =message_traits= template provides:

- =request_type=: The request struct type
- =response_type=: The corresponding response struct type
- =request_message_type=: The =message_type= enum value for the request

This enables using the simplified client API:

#+begin_src cpp
// Old verbose API (still works):
auto result = client_->process_request<
    action_resource_request,
    action_resource_response,
    messaging::message_type::action_resource_request>(std::move(req));

// New simplified API using traits:
auto result = client_->process_request(std::move(req));
#+end_src

The =has_message_traits= concept can be used to constrain templates:

#+begin_src cpp
template <typename RequestType>
    requires messaging::has_message_traits<RequestType>
void process(RequestType request) {
    using traits = messaging::message_traits<RequestType>;
    // Use traits::response_type, traits::request_message_type, etc.
}
#+end_src

** Step 4: Implement serialization

Use the reader/writer utilities for consistent serialization:

#+begin_src cpp
#include "ores.comms/messaging/reader.hpp"
#include "ores.comms/messaging/writer.hpp"

std::vector<std::byte> action_resource_request::serialize() const {
    std::vector<std::byte> buffer;
    writer::write_uuid(buffer, resource_id);
    writer::write_string(buffer, some_string);
    writer::write_bool(buffer, some_flag);
    writer::write_uint32(buffer, some_number);
    return buffer;
}

std::expected<action_resource_request, comms::messaging::error_code>
action_resource_request::deserialize(std::span<const std::byte> data) {
    action_resource_request request;

    auto id_result = reader::read_uuid(data);
    if (!id_result) return std::unexpected(id_result.error());
    request.resource_id = *id_result;

    auto str_result = reader::read_string(data);
    if (!str_result) return std::unexpected(str_result.error());
    request.some_string = *str_result;

    // Continue for all fields...

    return request;
}
#+end_src

*** Field serialization formats

| C++ Type             | Wire Format                    | Writer/Reader            |
|----------------------+--------------------------------+--------------------------|
| =bool=               | 1 byte (0x00/0x01)             | write_bool/read_bool     |
| =std::uint16_t=      | 2 bytes big-endian             | write_uint16/read_uint16 |
| =std::uint32_t=      | 4 bytes big-endian             | write_uint32/read_uint32 |
| =boost::uuids::uuid= | 16 bytes raw                   | write_uuid/read_uuid     |
| =std::string=        | 2 bytes length + N bytes UTF-8 | write_string/read_string |
| =std::vector<T>=     | 4 bytes count + N * T elements | write_uint32/read_count  |

*** Important serialization rules

1. Fields must be serialized in declaration order
2. Document the wire format in the =serialize()= method's doxygen comment
3. Deserialization must read fields in the same order as serialization
4. Always check for errors during deserialization
5. Use =std::unexpected= to propagate errors
6. Use =read_count()= instead of =read_uint32()= for collection sizes

*** Defensive limits for collections

To prevent memory exhaustion from corrupted or malicious data, always use
=reader::read_count()= when reading collection sizes. This function validates
the count against =MAX_ELEMENT_COUNT= (100,000) before the collection is
allocated.

#+begin_src cpp
#include "ores.utility/serialization/reader.hpp"

// In reader.hpp:
// constexpr std::uint32_t MAX_ELEMENT_COUNT = 100'000;

std::expected<get_items_response, error_code>
get_items_response::deserialize(std::span<const std::byte> data) {
    get_items_response response;

    // Use read_count() instead of read_uint32() for collection sizes
    auto count_result = reader::read_count(data);
    if (!count_result) return std::unexpected(count_result.error());
    auto count = *count_result;

    response.items.reserve(count);
    for (std::uint32_t i = 0; i < count; ++i) {
        // Deserialize each item...
        auto item_result = deserialize_item(data);
        if (!item_result) return std::unexpected(item_result.error());
        response.items.push_back(std::move(*item_result));
    }

    return response;
}
#+end_src

If the count exceeds the limit, =read_count()= returns
=error_code::limit_exceeded=, preventing a huge memory allocation.

For custom limits, pass a second argument:

#+begin_src cpp
// Allow at most 1000 items
auto count_result = reader::read_count(data, 1000);
#+end_src

*** Decompression limits

Compressed payloads are also protected. The =decompress()= function in
=ores.comms/messaging/compression.hpp= limits decompressed output to
=MAX_DECOMPRESSED_SIZE= (16 MB) to prevent zip bomb attacks.

** Step 5: Add JSON output support

For debugging and logging, implement the stream operator using reflect-cpp:

#+begin_src cpp
#include <rfl.hpp>
#include <rfl/json.hpp>
#include "ores.utility/rfl/reflectors.hpp"

std::ostream& operator<<(std::ostream& s, const action_resource_request& v) {
    rfl::json::write(v, s);
    return s;
}
#+end_src

** Step 6: Create message handler

Add a handler method to the appropriate message handler class:

#+begin_src cpp
// In COMPONENT_message_handler.hpp

handler_result
handle_action_resource_request(std::span<const std::byte> payload,
    const std::string& remote_address);

// In COMPONENT_message_handler.cpp

case message_type::action_resource_request:
    co_return co_await handle_action_resource_request(payload, remote_address);
#+end_src

** Step 7: Update protocol version

After making changes, update the version in =message_types.hpp=:

#+begin_src cpp
// Breaking change: bump major, reset minor
constexpr std::uint16_t PROTOCOL_VERSION_MAJOR = 8;
constexpr std::uint16_t PROTOCOL_VERSION_MINOR = 0;

// Backward compatible: bump minor only
constexpr std::uint16_t PROTOCOL_VERSION_MAJOR = 8;
constexpr std::uint16_t PROTOCOL_VERSION_MINOR = 1;
#+end_src

Add a comment documenting what changed:

#+begin_src cpp
// Version 8.0 removes requester_account_id from lock_account_request and
// unlock_account_request. Authorization is now handled via server-side session
// tracking instead of client-provided identity. This is a breaking change.
#+end_src

** Step 8: Write tests

Create tests in =projects/COMPONENT/tests/messaging_protocol_tests.cpp=:

#+begin_src cpp
TEST_CASE("action_resource_request_serialize_deserialize", tags) {
    auto lg(make_logger(test_suite));

    action_resource_request e;
    e.resource_id = boost::uuids::random_generator()();
    BOOST_LOG_SEV(lg, info) << "Expected: " << e;

    const auto serialized = e.serialize();
    const auto r = action_resource_request::deserialize(serialized);

    REQUIRE(r.has_value());
    const auto& a = r.value();
    BOOST_LOG_SEV(lg, info) << "Actual: " << a;

    CHECK(a.resource_id == e.resource_id);
}
#+end_src

** Step 9: Update umbrella protocol header

Add the new protocol header to the subsystem's umbrella header:

#+begin_src cpp
// In projects/COMPONENT/include/COMPONENT/messaging/protocol.hpp
#include "COMPONENT/messaging/FEATURE_protocol.hpp"
#+end_src

* Security considerations

** Never trust client-provided identity

The requester's identity should be determined from server-side session context,
not from fields in the request. This prevents identity forgery attacks.

** Authorization checks

Always perform authorization checks in the message handler, not in the client.
The server is the authority for access control decisions.

*** Passing authorization_service to message handlers

Message handlers that perform write, delete, or sensitive operations should
receive =auth_service= for RBAC permission checks:

1. Update the registrar to accept =auth_service=:

#+begin_src cpp
// In registrar.hpp
#include "ores.iam/service/authorization_service.hpp"

static void register_handlers(comms::net::server& server,
    database::context ctx,
    std::shared_ptr<iam::service::authorization_service> auth_service);
#+end_src

2. Update the message handler constructor:

#+begin_src cpp
// In message_handler.hpp
#include "ores.iam/service/authorization_service.hpp"

message_handler(database::context ctx,
    std::shared_ptr<comms::service::auth_session_service> sessions,
    std::shared_ptr<iam::service::authorization_service> auth_service);

private:
    std::shared_ptr<iam::service::authorization_service> auth_service_;
#+end_src

3. Pass =auth_service= when creating the handler:

#+begin_src cpp
// In registrar.cpp
auto handler = std::make_shared<message_handler>(
    std::move(ctx), server.sessions(), std::move(auth_service));
#+end_src

4. Update the call site in =application.cpp=:

#+begin_src cpp
ores::COMPONENT::messaging::registrar::register_handlers(*srv, ctx, auth_service);
#+end_src

5. Add the =ores.iam= dependency to CMakeLists.txt:

#+begin_src cmake
target_link_libraries(${lib_target_name}
    PRIVATE
        ores.iam.lib
        # ... other dependencies
)
#+end_src

** Sensitive data

Never include passwords or secrets in plain text in protocol messages. Use
secure hashing and proper authentication flows.

* Common patterns and conventions

** Error handling

- Use =std::expected= for all deserialization results
- Return =comms::messaging::error_code= for failures
- Provide meaningful error messages in response structs

** Logging

- Log requests at =debug= level on receipt
- Log successful operations at =info= level
- Log failures at =warn= or =error= level

** Code organization

- Keep protocol structs separate from service logic
- Use mappers to convert between protocol types and domain types
- Group related message types in the same protocol file

* Traits systems in ORE Studio

ORE Studio uses two complementary traits systems for different purposes:

** message_traits (ores.comms)

Maps request types to their corresponding response types and =message_type= enum
values. Used for RPC-style request/response messaging.

| Provides               | Description                            |
|------------------------+----------------------------------------|
| =request_type=         | The request struct type                |
| =response_type=        | The corresponding response struct type |
| =request_message_type= | The =message_type= enum value          |

Location: =ores.comms/messaging/message_traits.hpp=

** event_traits (ores.eventing)

Maps domain events to string names for the pub/sub notification system. Used
when subscribing to server-push notifications.

| Provides | Description                                                 |
|----------+-------------------------------------------------------------|
| =name=   | The event type name (e.g., "ores.refdata.currency_changed") |

Location: =ores.eventing/domain/event_traits.hpp=

** How they work together

These traits are orthogonal but work together for the subscription system:

1. Client uses =event_traits= to get the event name string for a domain event
2. Client builds =subscribe_request= with that event name
3. Client uses =message_traits= (via =process_request=) to send the request
4. Server uses =event_traits= when publishing events to match subscribers

Example flow:

#+begin_src cpp
// 1. Get event name from event_traits
constexpr auto event_name = event_traits<currency_changed_event>::name;
// Result: "ores.refdata.currency_changed"

// 2. Build subscribe request
subscribe_request req{.event_type = std::string{event_name}};

// 3. Send using message_traits (process_request infers types)
auto result = client_->process_request(std::move(req));
// message_traits<subscribe_request> provides:
//   response_type = subscribe_response
//   request_message_type = message_type::subscribe_request
#+end_src

* Artefacts                                                        :noexport:

** Licence

#+BEGIN_SRC fundamental :tangle LICENSE.txt
This program is free software; you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation; either version 3 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program; if not, write to the Free Software
Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston,
MA 02110-1301, USA.
#+END_SRC
