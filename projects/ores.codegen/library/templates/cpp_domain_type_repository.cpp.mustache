{{{cpp_license}}}
{{#domain_entity}}
#include "ores.{{component}}/repository/{{entity_singular}}_repository.hpp"

#include <sqlgen/postgres.hpp>
#include "ores.database/repository/helpers.hpp"
#include "ores.database/repository/bitemporal_operations.hpp"
#include "ores.{{component}}/domain/{{entity_singular}}_json_io.hpp" // IWYU pragma: keep.
#include "ores.{{component}}/repository/{{entity_singular}}_entity.hpp"
#include "ores.{{component}}/repository/{{entity_singular}}_mapper.hpp"

namespace ores::{{component}}::repository {

using namespace sqlgen;
using namespace sqlgen::literals;
using namespace ores::logging;
using namespace ores::database::repository;

std::string {{entity_singular}}_repository::sql() {
    return generate_create_table_sql<{{entity_singular}}_entity>(lg());
}

void {{entity_singular}}_repository::write(context ctx, const domain::{{entity_singular}}& v) {
    BOOST_LOG_SEV(lg(), debug) << "Writing {{entity_singular_words}}: " << v.{{primary_key.column}};
    execute_write_query(ctx, {{entity_singular}}_mapper::map(v),
        lg(), "Writing {{entity_singular_words}} to database.");
}

void {{entity_singular}}_repository::write(
    context ctx, const std::vector<domain::{{entity_singular}}>& v) {
    BOOST_LOG_SEV(lg(), debug) << "Writing {{entity_plural_words}}. Count: " << v.size();
    execute_write_query(ctx, {{entity_singular}}_mapper::map(v),
        lg(), "Writing {{entity_plural_words}} to database.");
}

std::vector<domain::{{entity_singular}}>
{{entity_singular}}_repository::read_latest(context ctx) {
    static auto max(make_timestamp(MAX_TIMESTAMP, lg()));
{{#has_tenant_id}}
    const auto tid = ctx.tenant_id().to_string();
    const auto query = sqlgen::read<std::vector<{{entity_singular}}_entity>> |
        where("tenant_id"_c == tid && "valid_to"_c == max.value()) |
        order_by("{{primary_key.column}}"_c);
{{/has_tenant_id}}
{{^has_tenant_id}}
    const auto query = sqlgen::read<std::vector<{{entity_singular}}_entity>> |
        where("valid_to"_c == max.value()) |
        order_by("{{primary_key.column}}"_c);
{{/has_tenant_id}}

    return execute_read_query<{{entity_singular}}_entity, domain::{{entity_singular}}>(
        ctx, query,
        [](const auto& entities) { return {{entity_singular}}_mapper::map(entities); },
        lg(), "Reading latest {{entity_plural_words}}");
}

std::vector<domain::{{entity_singular}}>
{{entity_singular}}_repository::read_latest(context ctx, const std::string& {{primary_key.column}}) {
    BOOST_LOG_SEV(lg(), debug) << "Reading latest {{entity_singular_words}}. {{primary_key.column}}: " << {{primary_key.column}};
    static auto max(make_timestamp(MAX_TIMESTAMP, lg()));
{{#has_tenant_id}}
    const auto tid = ctx.tenant_id().to_string();
    const auto query = sqlgen::read<std::vector<{{entity_singular}}_entity>> |
        where("tenant_id"_c == tid && "{{primary_key.column}}"_c == {{primary_key.column}} && "valid_to"_c == max.value());
{{/has_tenant_id}}
{{^has_tenant_id}}
    const auto query = sqlgen::read<std::vector<{{entity_singular}}_entity>> |
        where("{{primary_key.column}}"_c == {{primary_key.column}} && "valid_to"_c == max.value());
{{/has_tenant_id}}

    return execute_read_query<{{entity_singular}}_entity, domain::{{entity_singular}}>(
        ctx, query,
        [](const auto& entities) { return {{entity_singular}}_mapper::map(entities); },
        lg(), "Reading latest {{entity_singular_words}} by {{primary_key.column}}.");
}

std::vector<domain::{{entity_singular}}>
{{entity_singular}}_repository::read_all(context ctx, const std::string& {{primary_key.column}}) {
    BOOST_LOG_SEV(lg(), debug) << "Reading all {{entity_singular_words}} versions. {{primary_key.column}}: " << {{primary_key.column}};
{{#has_tenant_id}}
    const auto tid = ctx.tenant_id().to_string();
    const auto query = sqlgen::read<std::vector<{{entity_singular}}_entity>> |
        where("tenant_id"_c == tid && "{{primary_key.column}}"_c == {{primary_key.column}}) |
        order_by("version"_c.desc());
{{/has_tenant_id}}
{{^has_tenant_id}}
    const auto query = sqlgen::read<std::vector<{{entity_singular}}_entity>> |
        where("{{primary_key.column}}"_c == {{primary_key.column}}) |
        order_by("version"_c.desc());
{{/has_tenant_id}}

    return execute_read_query<{{entity_singular}}_entity, domain::{{entity_singular}}>(
        ctx, query,
        [](const auto& entities) { return {{entity_singular}}_mapper::map(entities); },
        lg(), "Reading all {{entity_singular_words}} versions by {{primary_key.column}}.");
}

void {{entity_singular}}_repository::remove(context ctx, const std::string& {{primary_key.column}}) {
    BOOST_LOG_SEV(lg(), debug) << "Removing {{entity_singular_words}}: " << {{primary_key.column}};
    static auto max(make_timestamp(MAX_TIMESTAMP, lg()));
{{#has_tenant_id}}
    const auto tid = ctx.tenant_id().to_string();
    const auto query = sqlgen::delete_from<{{entity_singular}}_entity> |
        where("tenant_id"_c == tid && "{{primary_key.column}}"_c == {{primary_key.column}} && "valid_to"_c == max.value());
{{/has_tenant_id}}
{{^has_tenant_id}}
    const auto query = sqlgen::delete_from<{{entity_singular}}_entity> |
        where("{{primary_key.column}}"_c == {{primary_key.column}} && "valid_to"_c == max.value());
{{/has_tenant_id}}

    execute_delete_query(ctx, query, lg(), "Removing {{entity_singular_words}} from database.");
}

}
{{/domain_entity}}
{{#junction}}
#include "ores.{{component}}/repository/{{name_singular}}_repository.hpp"

#include <sqlgen/postgres.hpp>
{{#has_uuid_left_or_right}}
#include <boost/uuid/uuid_io.hpp>
{{/has_uuid_left_or_right}}
#include "ores.database/repository/helpers.hpp"
#include "ores.database/repository/bitemporal_operations.hpp"
#include "ores.{{component}}/domain/{{name_singular}}_json_io.hpp" // IWYU pragma: keep.
#include "ores.{{component}}/repository/{{name_singular}}_entity.hpp"
#include "ores.{{component}}/repository/{{name_singular}}_mapper.hpp"

namespace ores::{{component}}::repository {

using namespace sqlgen;
using namespace sqlgen::literals;
using namespace ores::logging;
using namespace ores::database::repository;

std::string {{name_singular}}_repository::sql() {
    return generate_create_table_sql<{{name_singular}}_entity>(lg());
}

{{name_singular}}_repository::{{name_singular}}_repository(context ctx)
    : ctx_(std::move(ctx)) {}

void {{name_singular}}_repository::write(
    const domain::{{name_singular}}& {{name_singular_short}}) {
    BOOST_LOG_SEV(lg(), debug) << "Writing {{name_singular_words}} to database: "
                               << {{name_singular_short}}.{{left.column}} << "/" << {{name_singular_short}}.{{right.column}};
    execute_write_query(ctx_, {{name_singular}}_mapper::map({{name_singular_short}}),
        lg(), "writing {{name_singular_words}} to database");
}

void {{name_singular}}_repository::write(
    const std::vector<domain::{{name_singular}}>& {{name_short}}) {
    BOOST_LOG_SEV(lg(), debug) << "Writing {{name_words}} to database. Count: "
                               << {{name_short}}.size();
    execute_write_query(ctx_, {{name_singular}}_mapper::map({{name_short}}),
        lg(), "writing {{name_words}} to database");
}

std::vector<domain::{{name_singular}}>
{{name_singular}}_repository::read_latest() {
    static auto max(make_timestamp(MAX_TIMESTAMP, lg()));
    const auto query = sqlgen::read<std::vector<{{name_singular}}_entity>> |
        where("valid_to"_c == max.value()) |
        order_by("{{left.column}}"_c, "{{order_column}}"_c);

    return execute_read_query<{{name_singular}}_entity, domain::{{name_singular}}>(
        ctx_, query,
        [](const auto& entities) { return {{name_singular}}_mapper::map(entities); },
        lg(), "Reading latest {{name_words}}");
}

std::vector<domain::{{name_singular}}>
{{name_singular}}_repository::read_latest_by_{{left.column_short}}(
{{#left.is_uuid}}
    const boost::uuids::uuid& {{left.column}}) {
{{/left.is_uuid}}
{{^left.is_uuid}}
    const std::string& {{left.column}}) {
{{/left.is_uuid}}
    BOOST_LOG_SEV(lg(), debug) << "Reading latest {{name_words}}. {{left.column_title}}: "
                               << {{left.column}};

    static auto max(make_timestamp(MAX_TIMESTAMP, lg()));
{{#left.is_uuid}}
    const auto {{left.column}}_str = boost::uuids::to_string({{left.column}});
    const auto query = sqlgen::read<std::vector<{{name_singular}}_entity>> |
        where("{{left.column}}"_c == {{left.column}}_str && "valid_to"_c == max.value()) |
{{/left.is_uuid}}
{{^left.is_uuid}}
    const auto query = sqlgen::read<std::vector<{{name_singular}}_entity>> |
        where("{{left.column}}"_c == {{left.column}} && "valid_to"_c == max.value()) |
{{/left.is_uuid}}
        order_by("{{order_column}}"_c);

    return execute_read_query<{{name_singular}}_entity, domain::{{name_singular}}>(
        ctx_, query,
        [](const auto& entities) { return {{name_singular}}_mapper::map(entities); },
        lg(), "Reading latest {{name_words}} by {{left.column_short}}.");
}

std::vector<domain::{{name_singular}}>
{{name_singular}}_repository::read_latest_by_{{right.column_short}}(
{{#right.is_uuid}}
    const boost::uuids::uuid& {{right.column}}) {
{{/right.is_uuid}}
{{^right.is_uuid}}
    const std::string& {{right.column}}) {
{{/right.is_uuid}}
    BOOST_LOG_SEV(lg(), debug) << "Reading latest {{name_words}}. {{right.column_title}}: "
                               << {{right.column}};

    static auto max(make_timestamp(MAX_TIMESTAMP, lg()));
{{#right.is_uuid}}
    const auto {{right.column}}_str = boost::uuids::to_string({{right.column}});
    const auto query = sqlgen::read<std::vector<{{name_singular}}_entity>> |
        where("{{right.column}}"_c == {{right.column}}_str && "valid_to"_c == max.value()) |
{{/right.is_uuid}}
{{^right.is_uuid}}
    const auto query = sqlgen::read<std::vector<{{name_singular}}_entity>> |
        where("{{right.column}}"_c == {{right.column}} && "valid_to"_c == max.value()) |
{{/right.is_uuid}}
        order_by("{{left.column}}"_c);

    return execute_read_query<{{name_singular}}_entity, domain::{{name_singular}}>(
        ctx_, query,
        [](const auto& entities) { return {{name_singular}}_mapper::map(entities); },
        lg(), "Reading latest {{name_words}} by {{right.column_short}}.");
}

void {{name_singular}}_repository::remove(
{{#left.is_uuid}}
    const boost::uuids::uuid& {{left.column}},
{{/left.is_uuid}}
{{^left.is_uuid}}
    const std::string& {{left.column}},
{{/left.is_uuid}}
{{#right.is_uuid}}
    const boost::uuids::uuid& {{right.column}}) {
{{/right.is_uuid}}
{{^right.is_uuid}}
    const std::string& {{right.column}}) {
{{/right.is_uuid}}
    BOOST_LOG_SEV(lg(), debug) << "Removing {{name_singular_words}} from database: "
                               << {{left.column}} << "/" << {{right.column}};

{{#left.is_uuid}}
    const auto {{left.column}}_str = boost::uuids::to_string({{left.column}});
{{/left.is_uuid}}
{{#right.is_uuid}}
    const auto {{right.column}}_str = boost::uuids::to_string({{right.column}});
{{/right.is_uuid}}
    const auto query = sqlgen::delete_from<{{name_singular}}_entity> |
{{#left.is_uuid}}
{{#right.is_uuid}}
        where("{{left.column}}"_c == {{left.column}}_str &&
              "{{right.column}}"_c == {{right.column}}_str);
{{/right.is_uuid}}
{{^right.is_uuid}}
        where("{{left.column}}"_c == {{left.column}}_str &&
              "{{right.column}}"_c == {{right.column}});
{{/right.is_uuid}}
{{/left.is_uuid}}
{{^left.is_uuid}}
{{#right.is_uuid}}
        where("{{left.column}}"_c == {{left.column}} &&
              "{{right.column}}"_c == {{right.column}}_str);
{{/right.is_uuid}}
{{^right.is_uuid}}
        where("{{left.column}}"_c == {{left.column}} &&
              "{{right.column}}"_c == {{right.column}});
{{/right.is_uuid}}
{{/left.is_uuid}}

    execute_delete_query(ctx_, query, lg(),
        "removing {{name_singular_words}} from database");
}

void {{name_singular}}_repository::remove_by_{{left.column_short}}(
{{#left.is_uuid}}
    const boost::uuids::uuid& {{left.column}}) {
{{/left.is_uuid}}
{{^left.is_uuid}}
    const std::string& {{left.column}}) {
{{/left.is_uuid}}
    BOOST_LOG_SEV(lg(), debug) << "Removing all {{name_words}} from database: "
                               << {{left.column}};

{{#left.is_uuid}}
    const auto {{left.column}}_str = boost::uuids::to_string({{left.column}});
    const auto query = sqlgen::delete_from<{{name_singular}}_entity> |
        where("{{left.column}}"_c == {{left.column}}_str);
{{/left.is_uuid}}
{{^left.is_uuid}}
    const auto query = sqlgen::delete_from<{{name_singular}}_entity> |
        where("{{left.column}}"_c == {{left.column}});
{{/left.is_uuid}}

    execute_delete_query(ctx_, query, lg(),
        "removing all {{name_words}} from database");
}

}
{{/junction}}
