{{! Template to generate Qt detail dialog source for domain entities }}
{{{cpp_license}}}
#include "ores.qt/{{domain_entity.entity_pascal}}DetailDialog.hpp"

#include <QMessageBox>
#include <QtConcurrent>
#include <QFutureWatcher>
#include "ui_{{domain_entity.entity_pascal}}DetailDialog.h"
#include "ores.qt/IconUtils.hpp"
#include "ores.qt/MessageBoxHelper.hpp"
#include "ores.qt/RelativeTimeHelper.hpp"
#include "{{domain_entity.qt.protocol_include}}"
#include "ores.comms/messaging/frame.hpp"

namespace ores::qt {

using namespace ores::logging;

{{domain_entity.entity_pascal}}DetailDialog::{{domain_entity.entity_pascal}}DetailDialog(QWidget* parent)
    : DetailDialogBase(parent),
      ui_(new Ui::{{domain_entity.entity_pascal}}DetailDialog),
      clientManager_(nullptr) {

    ui_->setupUi(this);
    setupUi();
    setupConnections();
}

{{domain_entity.entity_pascal}}DetailDialog::~{{domain_entity.entity_pascal}}DetailDialog() {
    delete ui_;
}

void {{domain_entity.entity_pascal}}DetailDialog::setupUi() {
    ui_->saveButton->setIcon(
        IconUtils::createRecoloredIcon(Icon::Save, IconUtils::DefaultIconColor));
    ui_->saveButton->setEnabled(false);

    ui_->deleteButton->setIcon(
        IconUtils::createRecoloredIcon(Icon::Delete, IconUtils::DefaultIconColor));
}

void {{domain_entity.entity_pascal}}DetailDialog::setupConnections() {
    connect(ui_->saveButton, &QPushButton::clicked, this,
            &{{domain_entity.entity_pascal}}DetailDialog::onSaveClicked);
    connect(ui_->deleteButton, &QPushButton::clicked, this,
            &{{domain_entity.entity_pascal}}DetailDialog::onDeleteClicked);

{{#domain_entity.qt.detail_fields}}
{{#is_key}}
{{#is_line_edit}}
    connect(ui_->{{widget}}, &QLineEdit::textChanged, this,
            &{{domain_entity.entity_pascal}}DetailDialog::onCodeChanged);
{{/is_line_edit}}
{{/is_key}}
{{^is_key}}
{{#is_line_edit}}
    connect(ui_->{{widget}}, &QLineEdit::textChanged, this,
            &{{domain_entity.entity_pascal}}DetailDialog::onFieldChanged);
{{/is_line_edit}}
{{#is_text_edit}}
    connect(ui_->{{widget}}, &QTextEdit::textChanged, this,
            &{{domain_entity.entity_pascal}}DetailDialog::onFieldChanged);
{{/is_text_edit}}
{{/is_key}}
{{/domain_entity.qt.detail_fields}}
}

void {{domain_entity.entity_pascal}}DetailDialog::setClientManager(ClientManager* clientManager) {
    clientManager_ = clientManager;
}

void {{domain_entity.entity_pascal}}DetailDialog::setUsername(const std::string& username) {
    username_ = username;
}

void {{domain_entity.entity_pascal}}DetailDialog::set{{domain_entity.entity_pascal_short}}(
    const {{domain_entity.qt.domain_class}}& {{domain_entity.qt.item_var}}) {
    {{domain_entity.qt.item_var}}_ = {{domain_entity.qt.item_var}};
    updateUiFrom{{domain_entity.entity_pascal_short}}();
}

void {{domain_entity.entity_pascal}}DetailDialog::setCreateMode(bool createMode) {
    createMode_ = createMode;
    ui_->codeEdit->setReadOnly(!createMode);
    ui_->deleteButton->setVisible(!createMode);

    if (createMode) {
        ui_->metadataGroup->setVisible(false);
    }

    hasChanges_ = false;
    updateSaveButtonState();
}

void {{domain_entity.entity_pascal}}DetailDialog::setReadOnly(bool readOnly) {
    readOnly_ = readOnly;
{{#domain_entity.qt.detail_fields}}
{{#is_key}}
    ui_->{{widget}}->setReadOnly(true);
{{/is_key}}
{{^is_key}}
    ui_->{{widget}}->setReadOnly(readOnly);
{{/is_key}}
{{/domain_entity.qt.detail_fields}}
    ui_->saveButton->setVisible(!readOnly);
    ui_->deleteButton->setVisible(!readOnly);
}

void {{domain_entity.entity_pascal}}DetailDialog::updateUiFrom{{domain_entity.entity_pascal_short}}() {
{{#domain_entity.qt.detail_fields}}
{{#is_line_edit}}
    ui_->{{widget}}->setText(QString::fromStdString({{domain_entity.qt.item_var}}_.{{field}}));
{{/is_line_edit}}
{{#is_text_edit}}
    ui_->{{widget}}->setPlainText(QString::fromStdString({{domain_entity.qt.item_var}}_.{{field}}));
{{/is_text_edit}}
{{/domain_entity.qt.detail_fields}}

    ui_->versionEdit->setText(QString::number({{domain_entity.qt.item_var}}_.version));
    ui_->recordedByEdit->setText(QString::fromStdString({{domain_entity.qt.item_var}}_.recorded_by));
    ui_->recordedAtEdit->setText(relative_time_helper::format({{domain_entity.qt.item_var}}_.recorded_at));
    ui_->commentaryEdit->setText(QString::fromStdString({{domain_entity.qt.item_var}}_.change_commentary));
}

void {{domain_entity.entity_pascal}}DetailDialog::update{{domain_entity.entity_pascal_short}}FromUi() {
{{#domain_entity.qt.detail_fields}}
{{#is_key}}
    if (createMode_) {
{{#is_line_edit}}
        {{domain_entity.qt.item_var}}_.{{field}} = ui_->{{widget}}->text().trimmed().toStdString();
{{/is_line_edit}}
    }
{{/is_key}}
{{^is_key}}
{{#is_line_edit}}
    {{domain_entity.qt.item_var}}_.{{field}} = ui_->{{widget}}->text().trimmed().toStdString();
{{/is_line_edit}}
{{#is_text_edit}}
    {{domain_entity.qt.item_var}}_.{{field}} = ui_->{{widget}}->toPlainText().trimmed().toStdString();
{{/is_text_edit}}
{{/is_key}}
{{/domain_entity.qt.detail_fields}}
    {{domain_entity.qt.item_var}}_.recorded_by = username_;
    {{domain_entity.qt.item_var}}_.performed_by = username_;
}

void {{domain_entity.entity_pascal}}DetailDialog::onCodeChanged(const QString& /* text */) {
    hasChanges_ = true;
    updateSaveButtonState();
}

void {{domain_entity.entity_pascal}}DetailDialog::onFieldChanged() {
    hasChanges_ = true;
    updateSaveButtonState();
}

void {{domain_entity.entity_pascal}}DetailDialog::updateSaveButtonState() {
    bool canSave = hasChanges_ && validateInput() && !readOnly_;
    ui_->saveButton->setEnabled(canSave);
}

bool {{domain_entity.entity_pascal}}DetailDialog::validateInput() {
{{#domain_entity.qt.required_fields}}
    const QString {{field}}_val = ui_->{{widget}}->text().trimmed();
{{/domain_entity.qt.required_fields}}

    return {{#domain_entity.qt.required_fields}}!{{field}}_val.isEmpty(){{^_is_last}} && {{/_is_last}}{{/domain_entity.qt.required_fields}};
}

void {{domain_entity.entity_pascal}}DetailDialog::onSaveClicked() {
    if (!clientManager_ || !clientManager_->isConnected()) {
        MessageBoxHelper::warning(this, "Disconnected",
            "Cannot save {{domain_entity.entity_singular_words}} while disconnected from server.");
        return;
    }

    if (!validateInput()) {
        MessageBoxHelper::warning(this, "Invalid Input",
            "Please fill in all required fields.");
        return;
    }

    update{{domain_entity.entity_pascal_short}}FromUi();

    BOOST_LOG_SEV(lg(), info) << "Saving {{domain_entity.entity_singular_words}}: " << {{domain_entity.qt.item_var}}_.{{domain_entity.qt.key_field}};

    QPointer<{{domain_entity.entity_pascal}}DetailDialog> self = this;

    struct SaveResult {
        bool success;
        std::string message;
    };

    auto task = [self, {{domain_entity.qt.item_var}} = {{domain_entity.qt.item_var}}_]() -> SaveResult {
        if (!self || !self->clientManager_) {
            return {false, "Dialog closed"};
        }

        {{domain_entity.qt.save_request_class}} request;
        request.{{domain_entity.qt.item_var}} = {{domain_entity.qt.item_var}};
        auto payload = request.serialize();

        comms::messaging::frame request_frame(
            comms::messaging::message_type::{{domain_entity.qt.save_message_type}},
            0, std::move(payload)
        );

        auto response_result = self->clientManager_->sendRequest(
            std::move(request_frame));

        if (!response_result) {
            return {false, "Failed to communicate with server"};
        }

        auto payload_result = response_result->decompressed_payload();
        if (!payload_result) {
            return {false, "Failed to decompress response"};
        }

        auto response = {{domain_entity.qt.save_response_class}}::
            deserialize(*payload_result);

        if (!response) {
            return {false, "Invalid server response"};
        }

        return {response->success, response->message};
    };

    auto* watcher = new QFutureWatcher<SaveResult>(self);
    connect(watcher, &QFutureWatcher<SaveResult>::finished,
            self, [self, watcher]() {
        auto result = watcher->result();
        watcher->deleteLater();

        if (result.success) {
            BOOST_LOG_SEV(lg(), info) << "{{domain_entity.entity_title}} saved successfully";
            QString code = QString::fromStdString(self->{{domain_entity.qt.item_var}}_.{{domain_entity.qt.key_field}});
            emit self->{{domain_entity.qt.item_var}}Saved(code);
            self->notifySaveSuccess(tr("{{domain_entity.entity_title}} '%1' saved").arg(code));
        } else {
            BOOST_LOG_SEV(lg(), error) << "Save failed: " << result.message;
            QString errorMsg = QString::fromStdString(result.message);
            emit self->errorMessage(errorMsg);
            MessageBoxHelper::critical(self, "Save Failed", errorMsg);
        }
    });

    QFuture<SaveResult> future = QtConcurrent::run(task);
    watcher->setFuture(future);
}

void {{domain_entity.entity_pascal}}DetailDialog::onDeleteClicked() {
    if (!clientManager_ || !clientManager_->isConnected()) {
        MessageBoxHelper::warning(this, "Disconnected",
            "Cannot delete {{domain_entity.entity_singular_words}} while disconnected from server.");
        return;
    }

    QString code = QString::fromStdString({{domain_entity.qt.item_var}}_.{{domain_entity.qt.key_field}});
    auto reply = MessageBoxHelper::question(this, "Delete {{domain_entity.entity_title}}",
        QString("Are you sure you want to delete {{domain_entity.entity_singular_words}} '%1'?").arg(code),
        QMessageBox::Yes | QMessageBox::No);

    if (reply != QMessageBox::Yes) {
        return;
    }

    BOOST_LOG_SEV(lg(), info) << "Deleting {{domain_entity.entity_singular_words}}: " << {{domain_entity.qt.item_var}}_.{{domain_entity.qt.key_field}};

    QPointer<{{domain_entity.entity_pascal}}DetailDialog> self = this;

    struct DeleteResult {
        bool success;
        std::string message;
    };

{{#domain_entity.qt.has_uuid_primary_key}}
    auto task = [self, id = {{domain_entity.qt.item_var}}_.id]() -> DeleteResult {
        if (!self || !self->clientManager_) {
            return {false, "Dialog closed"};
        }

        {{domain_entity.qt.delete_request_class}} request;
        request.ids = {id};
        auto payload = request.serialize();
{{/domain_entity.qt.has_uuid_primary_key}}
{{^domain_entity.qt.has_uuid_primary_key}}
    auto task = [self, code = {{domain_entity.qt.item_var}}_.{{domain_entity.qt.key_field}}]() -> DeleteResult {
        if (!self || !self->clientManager_) {
            return {false, "Dialog closed"};
        }

        {{domain_entity.qt.delete_request_class}} request;
        request.codes = {code};
        auto payload = request.serialize();
{{/domain_entity.qt.has_uuid_primary_key}}

        comms::messaging::frame request_frame(
            comms::messaging::message_type::{{domain_entity.qt.delete_message_type}},
            0, std::move(payload)
        );

        auto response_result = self->clientManager_->sendRequest(
            std::move(request_frame));

        if (!response_result) {
            return {false, "Failed to communicate with server"};
        }

        auto payload_result = response_result->decompressed_payload();
        if (!payload_result) {
            return {false, "Failed to decompress response"};
        }

        auto response = {{domain_entity.qt.delete_response_class}}::
            deserialize(*payload_result);

        if (!response || response->results.empty()) {
            return {false, "Invalid server response"};
        }

        return {response->results[0].success, response->results[0].message};
    };

    auto* watcher = new QFutureWatcher<DeleteResult>(self);
    connect(watcher, &QFutureWatcher<DeleteResult>::finished,
            self, [self, code, watcher]() {
        auto result = watcher->result();
        watcher->deleteLater();

        if (result.success) {
            BOOST_LOG_SEV(lg(), info) << "{{domain_entity.entity_title}} deleted successfully";
            emit self->statusMessage(QString("{{domain_entity.entity_title}} '%1' deleted").arg(code));
            emit self->{{domain_entity.qt.item_var}}Deleted(code);
            self->requestClose();
        } else {
            BOOST_LOG_SEV(lg(), error) << "Delete failed: " << result.message;
            QString errorMsg = QString::fromStdString(result.message);
            emit self->errorMessage(errorMsg);
            MessageBoxHelper::critical(self, "Delete Failed", errorMsg);
        }
    });

    QFuture<DeleteResult> future = QtConcurrent::run(task);
    watcher->setFuture(future);
}

}
