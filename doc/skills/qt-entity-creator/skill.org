:PROPERTIES:
:ID: c6adac80-f4e6-44e8-9525-3760cb98c41d
:END:
#+title: Qt Entity Creator
#+author: Marco Craveiro
#+options: <:nil c:nil todo:nil ^:nil d:nil date:nil author:nil toc:nil
#+startup: inlineimages
#+export_exclude_tags: noexport

#+begin_export markdown
---
name: qt-entity-creator
description: Create Qt UI components for domain entities including list windows, detail dialogs, history dialogs, and controllers.
license: Complete terms in LICENSE.txt
---
#+end_export

* When to use this skill

When you need to add a new entity to the Qt UI layer in ORE Studio. This skill
guides you through creating all the necessary Qt components to display, edit,
and manage a domain entity, following established patterns in the codebase.

Prerequisites:
- The domain type must already exist (see =domain-type-creator= skill)
- The messaging protocol for CRUD operations must exist (see =binary-protocol-developer= skill)
- The server-side handlers must be implemented


* How to use this skill

1. Gather entity requirements (name, fields, features needed).
2. Follow the detailed instructions to create components in order.
3. Each step produces independently committable code.
4. Build and test after each major step.


* Detailed instructions

The following sections describe the step-by-step process for creating a complete
Qt entity. Each step can be committed independently.


** Gather Requirements

Before starting, gather the following information:

- *Entity name*: The name of the entity (e.g., =currency=, =country=, =account=).
- *Component location*: Which domain the entity belongs to (e.g., =ores.risk=, =ores.iam=).
- *Display fields*: Which fields to show in the list view table.
- *Editable fields*: Which fields can be edited in the detail dialog.
- *Primary key*: The unique identifier field (e.g., =iso_code=, =id=, =alpha2_code=).
- *Features needed*:
  - [ ] List view with pagination (for large datasets)
  - [ ] Detail dialog (create/edit/view)
  - [ ] History dialog (version tracking)
  - [ ] Server notifications (real-time updates)
  - [ ] Image/flag support
  - [ ] Change reason tracking


** Step 1: Create Client Model

Create the model that fetches and stores entity data from the server.

*** File locations

- Header: =projects/ores.qt/include/ores.qt/Client<Entity>Model.hpp=
- Implementation: =projects/ores.qt/src/Client<Entity>Model.cpp=

*** Header structure

#+begin_src cpp
#ifndef ORES_QT_CLIENT_<ENTITY>_MODEL_HPP
#define ORES_QT_CLIENT_<ENTITY>_MODEL_HPP

#include <vector>
#include <QFutureWatcher>
#include <QAbstractTableModel>
#include "ores.qt/ClientManager.hpp"
#include "ores.logging/make_logger.hpp"
#include "<component>/domain/<entity>.hpp"

namespace ores::qt {

class Client<Entity>Model final : public QAbstractTableModel {
    Q_OBJECT

private:
    inline static std::string_view logger_name = "ores.qt.client_<entity>_model";

    [[nodiscard]] static auto& lg() {
        using namespace ores::logging;
        static auto instance = make_logger(logger_name);
        return instance;
    }

public:
    enum Column {
        // Define columns matching display fields
        // Example: IsoCode, Name, Symbol, ..., ColumnCount
        ColumnCount
    };

    explicit Client<Entity>Model(ClientManager* clientManager,
                                  QObject* parent = nullptr);
    ~Client<Entity>Model() override = default;

    // QAbstractTableModel interface
    int rowCount(const QModelIndex& parent = QModelIndex()) const override;
    int columnCount(const QModelIndex& parent = QModelIndex()) const override;
    QVariant data(const QModelIndex& index, int role = Qt::DisplayRole) const override;
    QVariant headerData(int section, Qt::Orientation orientation,
                        int role = Qt::DisplayRole) const override;

    // Data access
    const <component>::domain::<entity>* get<Entity>(int row) const;
    void refresh();
    void clear();

    // Pagination (if needed)
    std::uint32_t page_size() const { return page_size_; }
    void set_page_size(std::uint32_t size);
    std::uint64_t total_available_count() const { return total_available_count_; }
    void load_page(std::uint32_t offset, std::uint32_t limit);

signals:
    void dataLoaded();
    void loadError(const QString& error_message);

private slots:
    void onDataLoaded();

private:
    struct FetchResult {
        bool success;
        std::vector<<component>::domain::<entity>> entries;
        std::uint64_t total_count;
    };

    void fetch_data();

    ClientManager* clientManager_;
    std::vector<<component>::domain::<entity>> entries_;
    QFutureWatcher<FetchResult>* watcher_;

    std::uint32_t page_size_{100};
    std::uint32_t current_offset_{0};
    std::uint64_t total_available_count_{0};
    bool is_fetching_{false};
};

}

#endif
#+end_src

*** Implementation patterns

The implementation should:

1. Use =QtConcurrent::run= for async data fetching.
2. Use =QPointer<Client<Entity>Model>= in lambdas for safety.
3. Use =beginResetModel()= / =endResetModel()= when replacing data.
4. Log operations at appropriate levels (debug for start, info for success, error for failures).

*** Commit message

#+begin_example
[qt] Add Client<Entity>Model for <entity> data fetching

Create Qt model for fetching and displaying <entity> data from the
server with async loading and pagination support.
#+end_example


** Step 2: Create MDI Window (List View)

Create the main list window showing entities in a table.

*** File locations

- Header: =projects/ores.qt/include/ores.qt/<Entity>MdiWindow.hpp=
- Implementation: =projects/ores.qt/src/<Entity>MdiWindow.cpp=

*** Header structure

#+begin_src cpp
#ifndef ORES_QT_<ENTITY>_MDI_WINDOW_HPP
#define ORES_QT_<ENTITY>_MDI_WINDOW_HPP

#include <QWidget>
#include <QTableView>
#include <QVBoxLayout>
#include <QToolBar>
#include <QTimer>
#include <QSortFilterProxyModel>
#include <memory>
#include "ores.qt/ClientManager.hpp"
#include "ores.qt/Client<Entity>Model.hpp"
#include "ores.qt/PaginationWidget.hpp"  // If pagination needed
#include "ores.logging/make_logger.hpp"
#include "<component>/domain/<entity>.hpp"

namespace ores::qt {

class <Entity>MdiWindow : public QWidget {
    Q_OBJECT

private:
    inline static std::string_view logger_name = "ores.qt.<entity>_mdi_window";

    [[nodiscard]] static auto& lg() {
        using namespace ores::logging;
        static auto instance = make_logger(logger_name);
        return instance;
    }

public:
    explicit <Entity>MdiWindow(ClientManager* clientManager,
                                const QString& username,
                                QWidget* parent = nullptr);
    ~<Entity>MdiWindow() override;

    Client<Entity>Model* model() const { return model_.get(); }
    QSize sizeHint() const override;

signals:
    void statusChanged(const QString& message);
    void errorOccurred(const QString& error_message);
    void selectionChanged(int selection_count);
    void addNewRequested();
    void show<Entity>Details(const <component>::domain::<entity>& entity);
    void <entity>Deleted(const QString& id);
    void show<Entity>History(const QString& id);

public slots:
    void reload();
    void markAsStale();
    void clearStaleIndicator();

private slots:
    void onDataLoaded();
    void onLoadError(const QString& error);
    void onSelectionChanged();
    void onRowDoubleClicked(const QModelIndex& index);
    void onConnectionStateChanged();
    void addNew();
    void editSelected();
    void deleteSelected();
    void showHistory();

private:
    void setupUi();
    void setupToolbar();
    void setupReloadAction();
    void startPulseAnimation();
    void stopPulseAnimation();
    void updateActionStates();

    // Layout
    QVBoxLayout* verticalLayout_;
    QTableView* tableView_;
    QToolBar* toolBar_;
    PaginationWidget* paginationWidget_;  // If pagination needed

    // Stale indicator
    QAction* reloadAction_;
    QIcon normalReloadIcon_;
    QIcon staleReloadIcon_;
    QTimer* pulseTimer_;
    bool pulseState_{false};
    int pulseCount_{0};

    // Standard actions
    QAction* addAction_;
    QAction* editAction_;
    QAction* deleteAction_;
    QAction* historyAction_;

    // Model
    std::unique_ptr<Client<Entity>Model> model_;
    QSortFilterProxyModel* proxyModel_;
    ClientManager* clientManager_;
    QString username_;
    bool isStale_{false};
};

}

#endif
#+end_src

*** Implementation patterns

**** Constructor setup sequence

1. Initialize member variables.
2. Create toolbar with =setupToolbar()=.
3. Setup reload action with stale indicator.
4. Add standard actions (Add, Edit, Delete, History).
5. Create table view with standard configuration.
6. Setup proxy model for sorting/filtering.
7. Connect model signals.
8. Connect pagination signals (if applicable).
9. Connect connection state signals.
10. Update action states.
11. Load initial data if connected.

**** Standard table configuration

#+begin_src cpp
tableView_->setAlternatingRowColors(true);
tableView_->setSelectionBehavior(QAbstractItemView::SelectRows);
tableView_->setSelectionMode(QAbstractItemView::ExtendedSelection);
tableView_->setWordWrap(false);
tableView_->setSortingEnabled(true);
tableView_->verticalHeader()->setSectionResizeMode(QHeaderView::Fixed);
tableView_->horizontalHeader()->setSectionResizeMode(QHeaderView::ResizeToContents);
#+end_src

**** Stale indicator pattern

#+begin_src cpp
void <Entity>MdiWindow::setupReloadAction() {
    normalReloadIcon_ = IconUtils::createRecoloredIcon(
        ":/icons/ic_fluent_arrow_clockwise_16_regular.svg",
        color_constants::icon_color);
    staleReloadIcon_ = IconUtils::createRecoloredIcon(
        ":/icons/ic_fluent_arrow_clockwise_16_regular.svg",
        color_constants::stale_indicator);

    reloadAction_ = new QAction(normalReloadIcon_, tr("Reload"), this);
    reloadAction_->setToolTip(tr("Reload data from server"));
    connect(reloadAction_, &QAction::triggered, this, &<Entity>MdiWindow::reload);

    pulseTimer_ = new QTimer(this);
    pulseTimer_->setInterval(500);
    connect(pulseTimer_, &QTimer::timeout, this, [this]() {
        pulseState_ = !pulseState_;
        reloadAction_->setIcon(pulseState_ ? staleReloadIcon_ : normalReloadIcon_);
        if (++pulseCount_ >= 6) {
            stopPulseAnimation();
            reloadAction_->setIcon(staleReloadIcon_);
        }
    });
}

void <Entity>MdiWindow::markAsStale() {
    isStale_ = true;
    startPulseAnimation();
    emit statusChanged(tr("Data changed on server - click Reload"));
}

void <Entity>MdiWindow::clearStaleIndicator() {
    isStale_ = false;
    stopPulseAnimation();
    reloadAction_->setIcon(normalReloadIcon_);
}
#+end_src

**** Deletion pattern

#+begin_src cpp
void <Entity>MdiWindow::deleteSelected() {
    auto selection = tableView_->selectionModel()->selectedRows();
    if (selection.isEmpty()) return;

    // Collect identifiers
    QStringList ids;
    for (const auto& proxyIndex : selection) {
        auto sourceIndex = proxyModel_->mapToSource(proxyIndex);
        if (auto* entity = model_->get<Entity>(sourceIndex.row())) {
            ids << QString::fromStdString(entity->identifier());
        }
    }

    // Confirm deletion
    auto result = MessageBoxHelper::question(this, tr("Confirm Deletion"),
        tr("Delete %1 selected item(s)?").arg(ids.size()));
    if (result != QMessageBox::Yes) return;

    // Async delete operation...
}
#+end_src

*** Commit message

#+begin_example
[qt] Add <Entity>MdiWindow for <entity> list view

Create MDI window with table view, toolbar actions (add, edit, delete,
history), stale indicator, and pagination support.
#+end_example


** Step 3: Create Detail Dialog

Create the dialog for creating, editing, and viewing entity details.

*** File locations

- Header: =projects/ores.qt/include/ores.qt/<Entity>DetailDialog.hpp=
- Implementation: =projects/ores.qt/src/<Entity>DetailDialog.cpp=
- UI file: =projects/ores.qt/ui/<Entity>DetailDialog.ui=

*** Header structure

#+begin_src cpp
#ifndef ORES_QT_<ENTITY>_DETAIL_DIALOG_HPP
#define ORES_QT_<ENTITY>_DETAIL_DIALOG_HPP

#include <QWidget>
#include <QToolBar>
#include <memory>
#include "ores.qt/ClientManager.hpp"
#include "ores.logging/make_logger.hpp"
#include "<component>/domain/<entity>.hpp"

namespace Ui { class <Entity>DetailDialog; }

namespace ores::qt {

class <Entity>DetailDialog : public QWidget {
    Q_OBJECT

private:
    inline static std::string_view logger_name = "ores.qt.<entity>_detail_dialog";

    [[nodiscard]] static auto& lg() {
        using namespace ores::logging;
        static auto instance = make_logger(logger_name);
        return instance;
    }

public:
    explicit <Entity>DetailDialog(QWidget* parent = nullptr);
    ~<Entity>DetailDialog() override;

    void setClientManager(ClientManager* clientManager);
    void setUsername(const std::string& username);
    void set<Entity>(const <component>::domain::<entity>& entity);
    <component>::domain::<entity> get<Entity>() const;
    void clearDialog();

    void setReadOnly(bool readOnly, int versionNumber = 0);
    void setCreateMode(bool createMode);
    [[nodiscard]] QString identifier() const;

    // Version navigation (if history support)
    void setHistory(const std::vector<<component>::domain::<entity>>& history);
    void showVersionNavActions(bool visible);

signals:
    void statusMessage(const QString& message);
    void errorMessage(const QString& message);
    void isDirtyChanged(bool isDirty);
    void <entity>Created(const QString& id);
    void <entity>Updated(const QString& id);
    void <entity>Deleted(const QString& id);
    void revertRequested(const <component>::domain::<entity>& entity);

public slots:
    void save();
    void markAsStale();

private slots:
    void onSaveClicked();
    void onDeleteClicked();
    void onRevertClicked();
    void onFieldChanged();
    void onFirstVersionClicked();
    void onPrevVersionClicked();
    void onNextVersionClicked();
    void onLastVersionClicked();

private:
    void setupToolbar();
    void setFieldsReadOnly(bool readOnly);
    void updateSaveResetButtonState();
    void displayCurrentVersion();
    void updateVersionNavButtonStates();

    std::unique_ptr<Ui::<Entity>DetailDialog> ui_;
    QToolBar* toolBar_;

    // Toolbar actions
    QAction* saveAction_;
    QAction* deleteAction_;
    QAction* revertAction_;
    QAction* firstVersionAction_;
    QAction* prevVersionAction_;
    QAction* nextVersionAction_;
    QAction* lastVersionAction_;

    // State
    bool isDirty_{false};
    bool isAddMode_{false};
    bool isReadOnly_{false};
    bool isStale_{false};

    // Data
    ClientManager* clientManager_{nullptr};
    std::string username_;
    <component>::domain::<entity> current<Entity>_;
    std::vector<<component>::domain::<entity>> history_;
    int currentHistoryIndex_{0};
};

}

#endif
#+end_src

*** UI file structure

Create a Qt Designer =.ui= file with:

1. Main vertical layout.
2. Form layout for entity fields.
3. Metadata group box (version, recorded by, recorded at) - hidden in create mode.
4. Appropriate input widgets for each field type:
   - =QLineEdit= for text fields
   - =QSpinBox= / =QDoubleSpinBox= for numbers
   - =QCheckBox= for booleans
   - =QComboBox= for enums or foreign keys
   - =QDateTimeEdit= for timestamps

*** Implementation patterns

**** Mode handling

#+begin_src cpp
void <Entity>DetailDialog::setCreateMode(bool createMode) {
    isAddMode_ = createMode;

    // Primary key editable only in create mode
    ui_->identifierEdit->setReadOnly(!createMode);

    // Metadata hidden in create mode
    ui_->metadataGroup->setVisible(!createMode);

    // Delete disabled in create mode
    deleteAction_->setEnabled(!createMode);

    updateSaveResetButtonState();
}

void <Entity>DetailDialog::setReadOnly(bool readOnly, int versionNumber) {
    isReadOnly_ = readOnly;
    setFieldsReadOnly(readOnly);

    saveAction_->setVisible(!readOnly);
    deleteAction_->setVisible(!readOnly);
    revertAction_->setVisible(readOnly);

    if (readOnly && versionNumber > 0) {
        // Show version info in title or status
    }
}
#+end_src

**** Field change tracking

#+begin_src cpp
void <Entity>DetailDialog::onFieldChanged() {
    if (isReadOnly_) return;

    isDirty_ = true;
    emit isDirtyChanged(true);
    updateSaveResetButtonState();
}
#+end_src

**** Async save pattern

#+begin_src cpp
void <Entity>DetailDialog::onSaveClicked() {
    if (!clientManager_ || !clientManager_->isConnected()) {
        emit errorMessage(tr("Not connected to server"));
        return;
    }

    auto entity = get<Entity>();

    QPointer<<Entity>DetailDialog> self = this;
    QFuture<SaveResult> future = QtConcurrent::run([self, entity]() -> SaveResult {
        if (!self) return {false, "Dialog closed"};

        // Build and send request...
        return {response->success, response->message};
    });

    auto* watcher = new QFutureWatcher<SaveResult>(self);
    connect(watcher, &QFutureWatcher<SaveResult>::finished, self, [self, watcher]() {
        auto [success, message] = watcher->result();
        watcher->deleteLater();

        if (success) {
            self->isDirty_ = false;
            emit self->isDirtyChanged(false);

            if (self->isAddMode_) {
                emit self-><entity>Created(self->identifier());
            } else {
                emit self-><entity>Updated(self->identifier());
            }

            // Close parent MDI window
            // ...
        } else {
            emit self->errorMessage(tr("Save failed: %1").arg(QString::fromStdString(message)));
        }
    });

    watcher->setFuture(future);
}
#+end_src

*** Commit message

#+begin_example
[qt] Add <Entity>DetailDialog for <entity> editing

Create detail dialog with create/edit/view-only modes, version
navigation, and async save/delete operations.
#+end_example


** Step 4: Create History Dialog

Create the dialog for viewing entity version history.

*** File locations

- Header: =projects/ores.qt/include/ores.qt/<Entity>HistoryDialog.hpp=
- Implementation: =projects/ores.qt/src/<Entity>HistoryDialog.cpp=
- UI file: =projects/ores.qt/ui/<Entity>HistoryDialog.ui=

*** Header structure

#+begin_src cpp
#ifndef ORES_QT_<ENTITY>_HISTORY_DIALOG_HPP
#define ORES_QT_<ENTITY>_HISTORY_DIALOG_HPP

#include <QWidget>
#include <QToolBar>
#include <memory>
#include "ores.qt/ClientManager.hpp"
#include "ores.logging/make_logger.hpp"
#include "<component>/domain/<entity>.hpp"

namespace Ui { class <Entity>HistoryDialog; }

namespace ores::qt {

class <Entity>HistoryDialog : public QWidget {
    Q_OBJECT

private:
    inline static std::string_view logger_name = "ores.qt.<entity>_history_dialog";

    [[nodiscard]] static auto& lg() {
        using namespace ores::logging;
        static auto instance = make_logger(logger_name);
        return instance;
    }

public:
    explicit <Entity>HistoryDialog(const QString& identifier,
                                    ClientManager* clientManager,
                                    QWidget* parent = nullptr);
    ~<Entity>HistoryDialog() override;

    void loadHistory();
    void markAsStale();
    QSize sizeHint() const override;

    [[nodiscard]] const QString& identifier() const { return identifier_; }

signals:
    void statusChanged(const QString& message);
    void errorOccurred(const QString& error_message);
    void openVersionRequested(const <component>::domain::<entity>& entity, int versionNumber);
    void revertVersionRequested(const <component>::domain::<entity>& entity);

private slots:
    void onVersionSelected(int row);
    void onHistoryLoaded();
    void onHistoryLoadError(const QString& error);
    void onOpenClicked();
    void onRevertClicked();
    void onReloadClicked();

private:
    using DiffResult = QVector<QPair<QString, QPair<QString, QString>>>;

    void setupToolbar();
    void displayChangesTab(int versionIndex);
    void displayFullDetailsTab(int versionIndex);
    DiffResult calculateDiff(const <component>::domain::<entity>& current,
                             const <component>::domain::<entity>& previous);
    void updateButtonStates();
    int selectedVersionIndex() const;
    const QIcon& getHistoryIcon() const;

    std::unique_ptr<Ui::<Entity>HistoryDialog> ui_;
    QToolBar* toolBar_;

    QAction* reloadAction_;
    QAction* openAction_;
    QAction* revertAction_;

    ClientManager* clientManager_;
    QString identifier_;
    std::vector<<component>::domain::<entity>> history_;
};

}

#endif
#+end_src

*** UI file structure

Create a Qt Designer =.ui= file with:

1. Toolbar area at top.
2. Splitter with:
   - Left: Version list table (version number, timestamp, recorded by).
   - Right: Tab widget with:
     - "Changes" tab: Table showing field/old value/new value.
     - "Full Details" tab: Complete entity fields for selected version.

*** Implementation patterns

**** Diff calculation

#+begin_src cpp
<Entity>HistoryDialog::DiffResult
<Entity>HistoryDialog::calculateDiff(
    const <component>::domain::<entity>& current,
    const <component>::domain::<entity>& previous) {

    DiffResult result;

#define CHECK_DIFF_STRING(FIELD_NAME, FIELD) \
    if (current.FIELD != previous.FIELD) { \
        result.append({FIELD_NAME, \
            {QString::fromStdString(previous.FIELD), \
             QString::fromStdString(current.FIELD)}}); \
    }

#define CHECK_DIFF_BOOL(FIELD_NAME, FIELD) \
    if (current.FIELD != previous.FIELD) { \
        result.append({FIELD_NAME, \
            {previous.FIELD ? "Yes" : "No", \
             current.FIELD ? "Yes" : "No"}}); \
    }

    // Apply macros for each field
    CHECK_DIFF_STRING("Name", name);
    CHECK_DIFF_BOOL("Active", is_active);
    // ... etc

#undef CHECK_DIFF_STRING
#undef CHECK_DIFF_BOOL

    return result;
}
#+end_src

**** Async history loading

#+begin_src cpp
void <Entity>HistoryDialog::loadHistory() {
    QPointer<<Entity>HistoryDialog> self = this;

    QFuture<HistoryResult> future = QtConcurrent::run([self]() -> HistoryResult {
        if (!self || !self->clientManager_) {
            return std::unexpected("Dialog closed or no client");
        }

        // Build and send history request...
        return history_entries;
    });

    auto* watcher = new QFutureWatcher<HistoryResult>(self);
    connect(watcher, &QFutureWatcher<HistoryResult>::finished, self, [self, watcher]() {
        auto result = watcher->result();
        watcher->deleteLater();

        if (result.has_value()) {
            self->history_ = std::move(*result);
            self->onHistoryLoaded();
        } else {
            self->onHistoryLoadError(QString::fromStdString(result.error()));
        }
    });

    watcher->setFuture(future);
}
#+end_src

*** Commit message

#+begin_example
[qt] Add <Entity>HistoryDialog for <entity> version history

Create history dialog with version list, changes diff view, full
details tab, and revert functionality.
#+end_example


** Step 5: Create Controller

Create the controller that coordinates windows and handles events.

*** File locations

- Header: =projects/ores.qt/include/ores.qt/<Entity>Controller.hpp=
- Implementation: =projects/ores.qt/src/<Entity>Controller.cpp=

*** Header structure

#+begin_src cpp
#ifndef ORES_QT_<ENTITY>_CONTROLLER_HPP
#define ORES_QT_<ENTITY>_CONTROLLER_HPP

#include <QPointer>
#include "ores.qt/EntityController.hpp"
#include "ores.qt/DetachableMdiSubWindow.hpp"
#include "ores.logging/make_logger.hpp"
#include "<component>/domain/<entity>.hpp"

namespace ores::qt {

class <Entity>MdiWindow;

class <Entity>Controller : public EntityController {
    Q_OBJECT

private:
    inline static std::string_view logger_name = "ores.qt.<entity>_controller";

    [[nodiscard]] static auto& lg() {
        using namespace ores::logging;
        static auto instance = make_logger(logger_name);
        return instance;
    }

public:
    <Entity>Controller(
        QMainWindow* mainWindow,
        QMdiArea* mdiArea,
        ClientManager* clientManager,
        const QString& username,
        QList<DetachableMdiSubWindow*>& allDetachableWindows,
        QObject* parent = nullptr);

    ~<Entity>Controller() override;

    void showListWindow() override;
    void closeAllWindows() override;

signals:
    void statusMessage(const QString& message);
    void errorMessage(const QString& message);

private slots:
    void onAddNewRequested();
    void onShow<Entity>Details(const <component>::domain::<entity>& entity);
    void onShow<Entity>History(const QString& id);
    void on<Entity>Deleted(const QString& id);
    void onOpenHistoryVersion(const <component>::domain::<entity>& entity, int versionNumber);
    void onRevert<Entity>(const <component>::domain::<entity>& entity);
    void onNotificationReceived(const QString& eventType, const QDateTime& timestamp,
                                const QStringList& entityIds);

private:
    void showDetailWindow(const <component>::domain::<entity>* entity,
                          bool createMode, bool readOnly = false,
                          int versionNumber = 0);

    QList<DetachableMdiSubWindow*>& allDetachableWindows_;
    QPointer<DetachableMdiSubWindow> listWindow_;
    QPointer<<Entity>MdiWindow> listWidget_;
};

}

#endif
#+end_src

*** Implementation patterns

**** Constructor - event subscription

#+begin_src cpp
<Entity>Controller::<Entity>Controller(/* params */)
    : EntityController(mainWindow, mdiArea, clientManager, username, parent),
      allDetachableWindows_(allDetachableWindows) {

    BOOST_LOG_SEV(lg(), debug) << "<Entity> controller created";

    // Subscribe to server notifications
    if (clientManager_) {
        connect(clientManager_, &ClientManager::notificationReceived,
                this, &<Entity>Controller::onNotificationReceived);

        connect(clientManager_, &ClientManager::connected, this, [this]() {
            clientManager_->subscribeToEvent(std::string{event_name});
        });

        connect(clientManager_, &ClientManager::reconnected, this, [this]() {
            clientManager_->subscribeToEvent(std::string{event_name});
        });

        if (clientManager_->isConnected()) {
            clientManager_->subscribeToEvent(std::string{event_name});
        }
    }
}
#+end_src

**** Show list window

#+begin_src cpp
void <Entity>Controller::showListWindow() {
    // Reuse existing window if available
    if (listWindow_) {
        bring_window_to_front(listWindow_);
        return;
    }

    BOOST_LOG_SEV(lg(), info) << "Creating new <entity> MDI window";

    // Create widget
    auto* widget = new <Entity>MdiWindow(clientManager_, username_, nullptr);
    listWidget_ = widget;

    // Connect signals
    connect(widget, &<Entity>MdiWindow::statusChanged,
            this, [this](const QString& msg) { emit statusMessage(msg); });
    connect(widget, &<Entity>MdiWindow::errorOccurred,
            this, [this](const QString& err) { emit errorMessage(err); });
    connect(widget, &<Entity>MdiWindow::addNewRequested,
            this, &<Entity>Controller::onAddNewRequested);
    connect(widget, &<Entity>MdiWindow::show<Entity>Details,
            this, &<Entity>Controller::onShow<Entity>Details);
    connect(widget, &<Entity>MdiWindow::show<Entity>History,
            this, &<Entity>Controller::onShow<Entity>History);
    connect(widget, &<Entity>MdiWindow::<entity>Deleted,
            this, &<Entity>Controller::on<Entity>Deleted);

    // Wrap in MDI sub-window
    listWindow_ = new DetachableMdiSubWindow();
    listWindow_->setAttribute(Qt::WA_DeleteOnClose);
    listWindow_->setWidget(widget);
    listWindow_->setWindowTitle(tr("<Entity>s"));
    listWindow_->setWindowIcon(IconUtils::createRecoloredIcon(
        ":/icons/ic_fluent_<icon>_20_regular.svg", color_constants::icon_color));

    // Track destruction
    connect(listWindow_, &QObject::destroyed, this, [this]() {
        listWindow_ = nullptr;
        listWidget_ = nullptr;
    });

    mdiArea_->addSubWindow(listWindow_);
    allDetachableWindows_.append(listWindow_);
    listWindow_->show();

    widget->reload();
}
#+end_src

**** Notification handling

#+begin_src cpp
void <Entity>Controller::onNotificationReceived(
    const QString& eventType,
    const QDateTime& timestamp,
    const QStringList& entityIds) {

    Q_UNUSED(timestamp);

    if (eventType != QString::fromStdString(std::string{event_name})) {
        return;
    }

    BOOST_LOG_SEV(lg(), debug) << "<Entity> change notification received";

    // Mark list as stale
    if (listWidget_) {
        listWidget_->markAsStale();
    }

    // Mark affected detail/history windows as stale
    for (auto it = managed_windows_.begin(); it != managed_windows_.end(); ++it) {
        const QString& key = it.key();
        auto* window = it.value();

        // Check if this window is affected
        if (entityIds.isEmpty()) {
            // All entities changed
            MdiUtils::markWindowAsStale(window);
        } else {
            // Check specific IDs
            for (const QString& id : entityIds) {
                if (key.contains(id)) {
                    MdiUtils::markWindowAsStale(window);
                    break;
                }
            }
        }
    }
}
#+end_src

*** Commit message

#+begin_example
[qt] Add <Entity>Controller for <entity> window management

Create controller with list window, detail dialogs, history dialogs,
and server notification handling.
#+end_example


** Step 6: MainWindow Integration

Integrate the controller into the main window.

*** Files to modify

- =projects/ores.qt/include/ores.qt/MainWindow.hpp=
- =projects/ores.qt/src/MainWindow.cpp=
- =projects/ores.qt/ui/MainWindow.ui=

*** Header changes

Add to =MainWindow.hpp=:

#+begin_src cpp
// Forward declaration
class <Entity>Controller;

// Member variable
<Entity>Controller* <entity>Controller_;
#+end_src

*** UI changes

Add to =MainWindow.ui=:
- Menu action: =Action<Entity>s=
- Set appropriate icon and shortcut

*** Implementation changes

In =MainWindow.cpp= constructor:

#+begin_src cpp
// Create controller
<entity>Controller_ = new <Entity>Controller(
    this, mdiArea_, clientManager_, username_,
    allDetachableWindows_, this);

// Connect signals
connect(<entity>Controller_, &<Entity>Controller::statusMessage,
        this, [this](const QString& msg) {
            ui_->statusbar->showMessage(msg, 5000);
        });
connect(<entity>Controller_, &<Entity>Controller::errorMessage,
        this, [this](const QString& err) {
            ui_->statusbar->showMessage(err, 5000);
        });

// Connect menu action
connect(ui_->Action<Entity>s, &QAction::triggered,
        <entity>Controller_, &<Entity>Controller::showListWindow);

// Set menu icon
ui_->Action<Entity>s->setIcon(IconUtils::createRecoloredIcon(
    ":/icons/ic_fluent_<icon>_20_regular.svg", iconColor));

// Enable/disable based on connection state
ui_->Action<Entity>s->setEnabled(isConnected);
#+end_src

*** Commit message

#+begin_example
[qt] Integrate <Entity>Controller into MainWindow

Add menu action and controller for <entity> management in main window.
#+end_example


** Step 7: Build and Test

After each step, verify the build succeeds:

#+begin_src shell
cmake --build --preset linux-clang-debug
#+end_src

Test manually:
1. Start the server.
2. Start the Qt client and login.
3. Access the new entity via the menu.
4. Verify list view loads data.
5. Test add/edit/delete operations.
6. Test history view and revert.
7. Test stale indicator with server-side changes.


* Common patterns reference


** Icon paths by entity type

| Entity Type | Icon Path |
|-------------+-----------|
| Currency | =ic_fluent_currency_dollar_euro_20_regular.svg= |
| Country | =ic_fluent_globe_20_regular.svg= |
| Account | =ic_fluent_person_accounts_20_regular.svg= |
| Role | =ic_fluent_lock_closed_20_regular.svg= |
| ChangeReason | =ic_fluent_note_edit_20_regular.svg= |
| ChangeReasonCategory | =ic_fluent_tag_20_regular.svg= |
| FeatureFlag | =ic_fluent_flag_20_regular.svg= |
| History | =ic_fluent_history_20_regular.svg= |
| Reload | =ic_fluent_arrow_clockwise_16_regular.svg= |
| Add | =ic_fluent_add_20_regular.svg= |
| Edit | =ic_fluent_edit_20_regular.svg= |
| Delete | =ic_fluent_delete_20_regular.svg= |
| Save | =ic_fluent_save_20_regular.svg= |
| Revert | =ic_fluent_arrow_rotate_counterclockwise_20_regular.svg= |


** Window size hints

| Window Type | Size |
|-------------+------|
| List (standard) | 900x600 |
| List (large) | 1000x600 |
| List (small) | 700x400 |
| Detail dialog | 600x500 |
| History dialog | 900x600 |


** Color constants

Use =color_constants= from =ColorConstants.hpp=:

- =icon_color= - Light gray (220, 220, 220) for toolbar icons
- =stale_indicator= - Orange (255, 165, 0) for stale data indicator


* Artefacts                                                        :noexport:

** Licence

#+BEGIN_SRC fundamental :tangle LICENCE.txt
This program is free software; you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation; either version 3 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program; if not, write to the Free Software
Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston,
MA 02110-1301, USA.
#+END_SRC
