diff --git a/include/sqlgen/postgres/Connection.hpp b/include/sqlgen/postgres/Connection.hpp
index af50b10..63b0c91 100644
--- sqlgen-0.4.0/include/sqlgen/postgres/Connection.hpp
+++ sqlgen-0.4.0/include/sqlgen/postgres/Connection.hpp
@@ -27,6 +27,18 @@

 namespace sqlgen::postgres {

+enum class NotificationWaitResult {
+ Ready, // Data available (possibly a NOTIFY)
+ Timeout, // Timeout elapsed
+ Error // I/O or connection error
+};
+
+struct Notification {
+ std::string channel;
+ std::string payload;
+ int backend_pid;
+};
+
 class SQLGEN_API Connection {
   using ConnPtr = Ref<PGconn>;

@@ -76,6 +88,16 @@ class SQLGEN_API Connection {
         [&](const auto& _data) { return write_impl(_data); }, _begin, _end);
   }

+  std::list<Notification> get_notifications() noexcept;
+
+  rfl::Result<Nothing> listen(const std::string& channel) noexcept;
+
+  rfl::Result<Nothing> unlisten(const std:: string& channel) noexcept;
+
+  rfl::Result<Nothing> notify(const std::string& channel, const std::string& payload = "") noexcept;
+
+  bool consume_input() noexcept;
+
  private:
   Result<Nothing> insert_impl(
       const dynamic::Insert& _stmt,
@@ -92,6 +114,8 @@ class SQLGEN_API Connection {
   Result<Nothing> write_impl(
       const std::vector<std::vector<std::optional<std::string>>>& _data);

+  bool is_valid_channel_name(const std::string& s) const noexcept;
+
  private:
   ConnPtr conn_;

diff --git a/src/sqlgen/postgres/Connection.cpp b/src/sqlgen/postgres/Connection.cpp
index 6b33ad2..dcd446d 100644
--- sqlgen-0.4.0/src/sqlgen/postgres/Connection.cpp
+++ sqlgen-0.4.0/src/sqlgen/postgres/Connection.cpp
@@ -33,8 +33,11 @@ Result<Nothing> Connection::end_write() {
   }
   const auto res = PQgetResult(conn_.get());
   if (PQresultStatus(res) != PGRES_COMMAND_OK) {
-    return error(PQerrorMessage(conn_.get()));
+    const auto err = error(PQerrorMessage(conn_.get()));
+    PQclear(res);
+    return err;
   }
+  PQclear(res);
   return Nothing{};
 }

@@ -50,16 +53,27 @@ Result<Nothing> Connection::insert_impl(

   const auto sql = to_sql_impl(_stmt);

-  const auto res = PQprepare(conn_.get(), name.c_str(), sql.c_str(),
-                             _data.at(0).size(), nullptr);
+  auto res = PQprepare(conn_.get(), name.c_str(), sql.c_str(),
+                       _data.at(0).size(), nullptr);

   const auto status = PQresultStatus(res);

   if (status != PGRES_COMMAND_OK) {
-    return error("Generating prepared statement for '" + sql +
-                 "' failed: " + PQresultErrorMessage(res));
+    const auto err = error("Generating prepared statement for '" + sql +
+                           "' failed: " + PQresultErrorMessage(res));
+    PQclear(res);
+
+    while ((res = PQgetResult(conn_.get())) != nullptr)
+        PQclear(res);
+
+    return err;
   }

+  PQclear(res);
+
+  while ((res = PQgetResult(conn_.get())) != nullptr)
+    PQclear(res);
+
   std::vector<const char*> current_row(_data[0].size());

   const int n_params = static_cast<int>(current_row.size());
@@ -93,8 +107,10 @@ Result<Nothing> Connection::insert_impl(
       const auto err = error(std::string("Executing INSERT failed: ") +
                              PQresultErrorMessage(res));
       execute("DEALLOCATE " + name + ";");
+      PQclear(res);
       return err;
     }
+    PQclear(res);
   }

   return execute("DEALLOCATE " + name + ";");
@@ -176,4 +192,77 @@ Result<Nothing> Connection::write_impl(
   return Nothing{};
 }

+std::list<Notification> Connection::get_notifications() noexcept {
+  std::list<Notification> notices;
+
+  // Safe to call even if no data — just returns true
+  if (!PQconsumeInput(conn_.get())) {
+    // Note: In pure wait/consume pattern, this should rarely happen if socket is healthy
+    // But we don't error here — just skip
+    return notices;
+  }
+
+  PGnotify* notify;
+  while ((notify = PQnotifies(conn_.get())) != nullptr) {
+    notices.push_back({
+      .channel = std::string(notify->relname),
+      .payload = notify->extra[0] ? std::string(notify->extra) : "",
+      .backend_pid = notify->be_pid
+    });
+    PQfreemem(notify);
+  }
+
+  return notices;
+}
+
+rfl::Result<Nothing> Connection::listen(const std::string& channel) noexcept {
+  if (!is_valid_channel_name(channel)) {
+    return error("Invalid channel name: must be a PostgreSQL identifier");
+  }
+  const std::string sql = "LISTEN " + channel;
+  return execute(sql);
+}
+
+rfl::Result<Nothing> Connection::unlisten(const std::string& channel) noexcept {
+  if (channel == "*") {
+    return execute("UNLISTEN *");
+  }
+  if (!is_valid_channel_name(channel)) {
+    return error("Invalid channel name");
+  }
+  const std::string sql = "UNLISTEN " + channel;
+  return execute(sql);
+}
+
+rfl::Result<Nothing> Connection::notify(const std::string& channel, const std::string& payload) noexcept {
+  if (!is_valid_channel_name(channel)) {
+    return error("Invalid channel name");
+  }
+
+  auto* escaped_payload = PQescapeLiteral(conn_.get(), payload.c_str(), payload.size());
+  if (!escaped_payload) {
+    return error("Failed to escape NOTIFY payload");
+  }
+  const std::string sql = "NOTIFY " + channel + ", " + std::string(escaped_payload);
+  PQfreemem(escaped_payload);
+
+  auto result = execute(sql);
+  PQflush(conn_.get());
+  return result;
+}
+
+bool Connection::consume_input() noexcept {
+  return PQconsumeInput(conn_.get()) == 1;
+}
+
+bool Connection::is_valid_channel_name(const std::string& s) const noexcept {
+  if (s.empty()) return false;
+  const char first = s[0];
+  if (first != '_' && !std::isalpha(static_cast<unsigned char>(first)))
+    return false;
+  return std::all_of(s.begin() + 1, s.end(), [](char c) {
+    return c == '_' || std::isalnum(static_cast<unsigned char>(c));
+  });
+}
+
 }  // namespace sqlgen::postgres
